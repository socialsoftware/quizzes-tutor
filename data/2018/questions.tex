%% =========================================================================
%% exams and tests 2018/2019
%% =========================================================================

% First and Second Exams

% Availability

\newcommand{\qAvailabilityOne}{
\begin{ClosedQuestion}
	Considering the availability architectural quality and the tactics of ping/echo and heartbeat

    \optionA{These tactics cannot be applied in conjunction with the self-test tactic.}
    \optionB{These tactics are used to prevent the occurrence of a fault.}
    \optionC{Heartbeat is more scalable than ping/echo because the monitor does not need to know in advance the addresses of the components.}
    \optionD{In ping/echo the components have the initiative to start the interaction.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qAvailabilityTwo}{
\begin{ClosedQuestion}
	A voting tactic can be used to

    \optionA{Prevent a fault in hardware.}
    \optionB{Prevent a fault in software.}
    \optionC{Prevent a fault in a process.}
    \optionD{Detect a fault.}
 \putOptions
\end{ClosedQuestion}
}


% Performance

\newcommand{\qPerformanceOne}{
  \begin{ClosedQuestion}
    To analyse the performance of a system

    \optionA{Only views of the component-and-connector viewtype are needed}
    \optionB{All viewtypes may be necessary}
    \optionC{Only views of the component-and-connector viewtype and allocation viewtype are needed}
    \optionD{Views of the module viewtype are not needed}
    \putOptions
% Resposta: B
 \end{ClosedQuestion}
}

\newcommand{\qPerformanceTwo}{
\begin{ClosedQuestion}
	Consider a scenario for performance where the arrival of events is stochastic with a distribution where there are peeks of events but the arrival of events over a long period is uniform. The best tactic to apply is
		
    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Prioritize events}
    \optionD{Bound execution time}
 \putOptions 
\end{ClosedQuestion}
}


% Modifiability

\newcommand{\qModifiabilityOne}{
\begin{ClosedQuestion}
	In a modifiability scenario the environment can be characterized as design time, compile time, build time, initiation time, and runtime.
	
    \optionA{When the environment is design time it means that the change should be done before the system enters into production}
    \optionB{When the environment is build time it means that it is necessary to codify a new module that is added by rebuilding the system}
    \optionC{When the environment is initiation time it means that it is necessary to restart the system for the change to take effect}
    \optionD{When the environment is runtime the cost of doing the change is higher than in the other environments}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qModifiabilityTwo}{
  \begin{ClosedQuestion}
    The main tactic associated with the layered architectural style is:

    \optionA{Split module}
    \optionB{Encapsulate}
    \optionC{Restrict dependencies}
    \optionD{Defer binding}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


% Module viewtype

\newcommand{\qModuleViewTypeOne}{
\begin{ClosedQuestion}
	The quality that is more relevant to views of the module viewtype is:
		
    \optionA{Modifiability.}
    \optionB{Usability.}
    \optionC{Security.}
    \optionD{Availability.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qModuleViewTypeTwo}{
\begin{ClosedQuestion}
	Consider the kind of relations between components and modules.
		
    \optionA{A module contains the code that executes in a single component and a component executes the code of a single module}
    \optionB{A module contains the code that can execute in several components and a component executes the code of a single module}
    \optionC{A module contains the code that executes in a single component and a component can execute the code of several modules}
    \optionD{A module contains the code that can execute in several components and a component can execute the code of several modules}
 \putOptions
\end{ClosedQuestion}
}


% Module style

\newcommand{\qModuleStyleOne}{
  \begin{ClosedQuestion}
    Consider the following description of \emph{Memcached}, which is
    adapted from its Wiki:
    \begin{quote}
      Memcached is an in-memory key-value store for small chunks of
      arbitrary data from results of database calls, API calls, or
      page rendering.  It is made up of:
      \begin{itemize}
      \item Client software, which is given a list of available memcached servers.
      \item A client-based hashing algorithm, which chooses a server
        based on the "key" input.
      \item Server software, which stores your values with their keys
        into an internal hash table.
      \item Server algorithms, which determine when to throw out old
        data (if out of memory), or reuse memory.
      \end{itemize}
    \end{quote}
    Suppose that you want to present an architectural view for
    \emph{Memcached} that represents the above information.  Which
    view is more adequate?

    \optionA{A view of the Data Model style}
    \optionB{A view of the Layers style}
    \optionC{A view of the Decomposition style}
    \optionD{A view of the Uses style}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qModuleStyleTwo}{
\begin{ClosedQuestion}
	 Suppose that you are implementing a module in a system that has a two layered architecture.
	 Knowing that your module belongs to the upper layer (assuming the usual notation
	 for the layer style), this means that you
	 
	 \optionA{Can use the operations defined in any of the system's modules}
	 \optionB{Can use the operations defined in the lower layer, but not the ones defined in
	 	the upper layer}
	 \optionC{Can use the operations defined in the upper layer, but not the ones defined in
	 	the lower layer}
	 \optionD{Should use some operation defined in the lower layer}
  \putOptions
\end{ClosedQuestion}
}


% Module style

\newcommand{\qModuleStyleThree}{
\begin{ClosedQuestion}
	The Generalization architectural style of the module viewtype can be use to support the evolution of a system 

    \optionA{By changing the commonalities that are in the children.}
    \optionB{Because the \emph{is-a} relation does not allow reuse of implementation.}
    \optionC{By adding, removing, or changing children.}
    \optionD{By changing a parent, which will automatically change all the children that inherit from it.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qModuleStyleFour}{
  \begin{ClosedQuestion}
    Using the Aspects architectural style promotes the modifiability
    of a system because
    
    \optionA{It imposes restrictions on which uses relationships may
      exist between the system's modules}
    \optionB{It makes it easier to create generalization relationships
      between the system's modules}
    \optionC{It separates in new modules responsibilities that were
      spread over various of the system's modules}
    \optionD{It allows the decomposition of each of the system's
      modules into finer grained modules}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


% Component-and-Connector viewtype

\newcommand{\qComponentAndConnectorViewtypeOne}{
  \begin{ClosedQuestion}
    According to the document that describes the architecture of web
    services:
    \begin{quote}
      Another critical piece of any distributed system is a load
      balancer.  Load balancers are a principal part of any
      architecture, as their role is to distribute load across a set
      of nodes responsible for servicing requests.  This allows
      multiple nodes to transparently service the same function in a
      system.  Their main purpose is to handle a lot of simultaneous
      connections and route those connections to one of the request
      nodes, allowing the system to scale to service more requests by
      just adding nodes.
    \end{quote}
    Based on this description, what is the best way to represent the
    architecture of a system that is using a \emph{load balancer}?

    \optionA{With a component-and-connector view, where the 
      \emph{load balancer} is a component of the system}
    \optionB{With a Deployment view, where the \emph{load balancer} is
      part of the communication infra-structure used to execute the
      system}
    \optionC{With a Uses view, representing the existing dependencies
      between the \emph{load balancer} and the services that it uses}
    \optionD{With a Layers view, where the \emph{load balancer}
      creates an abstraction layer between who makes the request and
      who provides the service}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorViewtypeTwo}{
\begin{ClosedQuestion}
	Consider the concept of interface delegation 
		
    \optionA{It corresponds to a particular case of a specialization in a generalization view.}
    \optionB{It represents a relation between a connector's role and a port of one of its internal components.}
    \optionC{It represents a relation between a component's port and a port of one of its internal components.}
    \optionD{It represents a relation between a component's port and a connector's role.}
 \putOptions
\end{ClosedQuestion}
}

% Component-and-Connector style

\newcommand{\qComponentAndConnectorStyleOne}{
\begin{ClosedQuestion}
	The repository architectural style provides performance because

    \optionA{It implements a maintain multiple copies of computation tactic.}
    \optionB{It supports the concurrent access of data accessors.}
    \optionC{It supports the access to persistent information.}
    \optionD{It implements a maintain multiple copies of data tactic.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorStyleTwo}{
  \begin{ClosedQuestion}
    In the Service Oriented Architecture style it is common to have a
    specialized component, named \emph{Enterprise Service Bus} (ESB).
    The goal of using of an ESB in a system is

    \optionA{To facilitate the interaction among heterogeneous
      components that use distinct communication protocols}
    \optionB{To promote the use of a common communication protocol for
      all the remaining components of the system}
    \optionC{To increase the performance of the interaction between
      the components of the system}
    \optionD{To create a strong coupling between the various services
      provided by the organization}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


% Component-and-Connector style

\newcommand{\qComponentAndConnectorStyleThree}{
\begin{ClosedQuestion}
  Typically, Instant Messaging clients have a window to list the contacts of the user, and
  show in that window the status of each contact (whether it is available, unavailable, busy,
  etc). Given that the status of a contact may be changed at any time, and that the contact's
  status is given by the Instant Messaging application of that contact, which architectural
  style represents best the interaction pattern between these components?

    \optionA{The Shared Data style}
    \optionB{The Pipes-and-filters style}
    \optionC{The Publish-subscribe style}
    \optionD{The Client-Server style}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorStyleFour}{
\begin{ClosedQuestion}
	In the description of the Gnutella system can be read:
	
	\begin{quote}
		The topology of the system changes at runtime as peer components connect and disconnect to the network.
	\end{quote}
	
    \optionA{When a peer connects to the network it establishes connections with all other peers in the network}
    \optionB{The behavior described in the sentence can be represented in a view where the dynamic reconfiguration architectural style is used}
    \optionC{When a peer receives a connection it sends all its files to the peer connecting it}
    \optionD{The behavior described in the sentence can be represented in a view where the tier architectural style is used}
 \putOptions
\end{ClosedQuestion}
}


% Allocation viewtype

\newcommand{\qAllocationOne}{
\begin{ClosedQuestion}
  In the software architecture of a system, the Deployment view is best suited for

    \optionA{Analysing the performance of the system}
    \optionB{Planning incremental releases of the system}
    \optionC{Estimating the effort needed to implement the system}
    \optionD{Analysing the system's portability and reusability}
    \putOptions

\end{ClosedQuestion}
}

\newcommand{\qAllocationTwo}{
\begin{ClosedQuestion}
	Consider the install architectural style of the allocation viewtype.
			
    \optionA{The development team is the main stakeholder interesting in these views.}
    \optionB{It assigns modules to files.}
    \optionC{It is completely independent of the deployment architectural style.}
    \optionD{It helps on the configuration of systems.}
 \putOptions 
\end{ClosedQuestion}
}


% Archictectural variations of web applications 

\newcommand{\qWebApplicationsOne}{
  \begin{ClosedQuestion}
    One of the evolutions in the development of web applications was
    the appearance of \emph{mashups}, which are described in Wikipedia
    as follows:

    \begin{quote}
      In web development, a mashup is a web page or application that
      uses and combines data, presentation or functionality from two
      or more sources to create new services.
    \end{quote}

    Knowing that the sources used by \emph{mashups} do not know about
    the existence of the \emph{mashups} and that they change
    frequently, forcing the adaptation of the \emph{mashups} to
    accommodate those changes, what is the best architecture to
    minimize the effects of those changes?
 
    \optionA{A \emph{web services} architecture}
    \optionB{A Client-Server architecture, where the \emph{mashup}
      is the client and the various sources are the servers}
    \optionC{A layered architecture, where the access to the various
      sources is the responsibility of the bottommost layer}
    \optionD{A Publish-Subscribe architecture, where the various
      sources publish events with the changes made and the
      \emph{mashup} subscribes those events}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qWebApplicationsTwo}{
  \begin{ClosedQuestion}
    Web applications went through several evolutions over the last
    years.  One of those evolutions was to make their user interfaces
    more sophisticated, by leveraging on new technologies available in
    the browsers, such as, for example, Javascript, to provide a more
    satisfying user experience.  What were the most visible
    consequences of such an evolution on the typical software
    architecture of a web application?

    \optionA{The presentation logic layer and how it relates with the
      underlying layer changed}
    \optionB{The style of the connector used to represent the interaction between
      the browser and the web server changed}
    \optionC{The browser is now a component of a different type}
    \optionD{That evolution did not have any consequences on the
      software architecture of a web application}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


% Architectures for scalable web applications

\newcommand{\qScalableArchitectureOne}{
  \begin{ClosedQuestion}
    Consider the following excerpt about the Scalable web architecture and distributed systems case study about two different possible implementations of a global cache
	
	\begin{quote}
		 There are two common forms of global caches (...), when a cached response is not found in the cache, the cache itself becomes responsible for retrieving the missing piece of data from the underlying store. (...) it is the responsibility of request nodes to retrieve any data that is not found in the cache. 	
	 \end{quote}
	
    \optionA{The solution where the application is responsible for retrieving the missing piece of data from the underlying store has better availability}
    \optionB{The solution where the cache is responsible for retrieving the missing piece of data from the underlying store has better availability}
    \optionC{The solution where the application is responsible for retrieving the missing piece of data from the underlying store has better modifiability}
    \optionD{The solution where the cache is responsible for retrieving the missing piece of data from the underlying store has better performance}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qScalableArchitectureTwo}{
  \begin{ClosedQuestion}
    Consider the use of a proxy to collapse requests. This corresponds to a tactic of 
	
    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Prioritize events}
    \optionD{Bound execution times}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}


% The Architecture of Catalog of DVDs

\newcommand{\qDVDCatalogOne}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To allow the share of catalogs with family and friends, including some access control. 
	\end{quote}
	
	This requirement requires 
	
    \optionA{A change to the uses view to represent that friends can use each other catalog.}
    \optionB{A change of the layered view to support different presentations, one for each friend.}
    \optionC{A change of the decomposition view to include the responsibilities associated with the access control.}
    \optionD{A new aspect view to include the responsibilities associated with the access control.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qDVDCatalogTwo}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To support multi-platform (Mac, Windows, Linux)
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The layered view to deal with the aspects of portability.}
    \optionB{The uses view to show the coupling between the different platforms.}
    \optionC{The uses view to show the uses relationships between the different platforms.}
    \optionD{The data model view to represent each one of the platforms.}
 \putOptions
\end{ClosedQuestion}
}


% The Architecture of Adventure Builder

\newcommand{\qAdventureBuilderOne}{
\begin{ClosedQuestion}
  	Consider the following architectural view of the Adventure Builder system, designed around the Order Processing Center
	
	\begin{center}
		\includegraphics[width=12cm]{../AdventureBuilderCandC}
	\end{center}
	
	The views \textbf{does not} allow the reason about the quality of

   	\optionA{Interoperability}
	\optionB{Modifiability}
    \optionC{Performance}
    \optionD{Security}
		
    \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderTwo}{
\begin{ClosedQuestion}
	Consider the following performance/scalability scenario for the Adventure Builder system 
	
	\begin{quote}
		Up to 500 users click to see the catalog of adventure packages following a random distribution over 1 minute; the system is under normal operating conditions; the maximal latency to serve the first page of content is under 5 seconds; average latency for same is less than 2 seconds. If required, the system should easily support an increase in the number of simultaneous requests while maintaining the same latency per request.
	\end{quote}
	
	and the following architectural view
	
	\begin{center}
		\includegraphics[width=10.5cm]{../AdventureBuilderHighLevelVIew}
	\end{center}
	
    \optionA{The view does not address the scenario}
    \optionB{The view addresses the scenario because it separates the \texttt{Consumer Website} module from the \texttt{OpcApp} module to allow the execution of the \texttt{Consumer Website} module in a component that can have multiple copies of computation}
    \optionC{The view addresses the scenario because it separates the modules that represent the interfaces a new business partner has to implement}
    \optionD{The view addresses the scenario because the \texttt{Consumer Website} module uses the \texttt{gwt} and \texttt{waf} modules}
 \putOptions
\end{ClosedQuestion}
}


% The Architecture of Graphite

\newcommand{\qGraphiteOne}{
  \begin{ClosedQuestion}
    In the Graphite system, in order to improve performance the component \emph{carbon} do not write directly on disk, it uses a buffer instead: 

    \optionA{but this reduces reliability because de webapp components do not access the most recent data}
    \optionB{but it reduces performance, anyway, because the buffer components easily overflow}
    \optionC{and it does not penalize reliability because it also provides an interface that the webapp components can use to access the most recent data}
    \optionD{and it improves security because the buffer is protected agains attacks} 

     \putOptions
   \end{ClosedQuestion}
}

\newcommand{\qGraphiteTwo}{
  \begin{ClosedQuestion}
	  The \emph{Composer UI} component of Graphite system, described as - \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL} - to be effective needs to show to the user the changes she performs in the graph such that she has immediate feedback about the result of the changes. To do so, the system needs to implement the tactics of

    \optionA{Task Model}
    \optionB{System Model}
    \optionC{Performance}
    \optionD{User Model} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}




% The Architecture of Chrome

\newcommand{\qChromeOne}{
  \begin{ClosedQuestion}
	  In the description of Chrome case study we can read:
	  \newline
	  
	  \emph{Chrome maintains a single instance of the resource dispatcher, which is shared across all render processes, and runs within the browser kernel process.}
	  \newline
	  
	  The \emph{Resource Dispatcher} contributes to the performance quality because it implements a tactic of
	      
    \optionA{Schedule Resources}
    \optionB{Increase Resources}
    \optionC{Introduce Concurrency}
    \optionD{Maintain Multiple Copies of Computation} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qChromeTwo}{
  \begin{ClosedQuestion}
	  In the description of the Chrome case study you can read:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	  
	  This description refers to the qualities of
	      	      
    \optionA{Usability e Modifiability}
    \optionB{Performance e Usability}
    \optionC{Availability e Usability}
    \optionD{Availability e Performance} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}


% The Architecture of SocialCalc

\newcommand{\qSocialCalcOne}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		Therefore, on browsers with support for CSS3, we use the box-shadow property to represent multiple peer cursors in the same cell.
	\end{quote} 
	
	This corresponds to the application of

    \optionA{Maintain system model tactic.}
    \optionB{Support user initiative tactic.}
    \optionC{Maintain multiple copies of data tactic.}
    \optionD{Conflict detection tactic.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qSocialCalcTwo}{
\begin{ClosedQuestion}
	Consider the architectural views for the SocialCalc system. In the case description can be read:
	
	\begin{quote}
		The save format is in standard MIME multipart/mixed format, consisting of four text/plain; charset=UTF-8 parts, each part containing newline-delimited text with colon-delimited data fields. The parts are...
	\end{quote}
	
	From the above excerpt can be inferred the need to have
	
    \optionA{A module view of the decomposition style.}
    \optionB{A module view of the data model style.}
    \optionC{A component-and-connector view of the service-oriented architecture style.}
    \optionD{A module view of the uses style.}
 \putOptions
\end{ClosedQuestion}
}


% The Architecture of the Morrison's OrderPad

\newcommand{\qOrderPadOne}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. In the description of the system can be read:
	
	\begin{quote}
		One of these was using a file-transfer to send data to the mainframe rather than MQ, which wouldn't perform well once many stores were active.
	\end{quote}
	
	This approach means that
	
    \optionA{Performance was traded for easy of development.}
    \optionB{An iterative development was followed, which allowed more time to develop a connector with good performance in the latter stages of the project.}
    \optionC{Performance was traded for the modifiability quality.}
    \optionD{An incremental development was followed, which allowed to have the system in production without being necessary to export all the information to the mainframe.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qOrderPadTwo}{
\begin{ClosedQuestion}
	Frank Buschmann defines Featuritis as
		
	\begin{quote}
		Featuritis is the tendency to trade functional coverage for quality - the more functions the earlier they're delivered, the better.
	\end{quote}
	
	In the OrderPad system the architect regretted not getting performance tests going earlier. The OrderPad system

    \optionA{Suffered from featuritis, because the architect decided to delay the difficult parts for latter in the development.}
    \optionB{Did not suffer from featuritis.}
    \optionC{Suffered from some level of featuritis, but it allowed to have a pilot from which the team learned.}
    \optionD{Suffered from featuritis, but it had no impact on the final development.}
 \putOptions 
\end{ClosedQuestion}
}


% Microservices and Aggregates

\newcommand{\qAggregatesOne}{
\begin{ClosedQuestion}
	Consider the following decomposition of a domain model into 3 aggregates. 
	
	\centering
	\includegraphics[width=12cm]{../1-aggregate}

    \optionA{This decomposition is the only possible of the original domain model.}
    \optionB{This decomposition implies that, in average, customers are going to have a large number of orders.}
    \optionC{This decomposition implies that products will frequently change their unique identification.}
    \optionD{All the above.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAggregatesTwo}{
\begin{ClosedQuestion}
	Consider the following decomposition of a domain model into 3 aggregates. If, instead of this decomposition, \texttt{Customer} and \texttt{Order} were in the same aggregate  
	
	\centering
	\includegraphics[width=12cm]{../1-aggregate}

    \optionA{It would reduce the scalability for updates of different orders for the same customer.}
    \optionB{Two users would not conflict if they attempt to edit different orders for the same customer.}
    \optionC{The increase of the number of orders would not have impact on the load the aggregate.}
    \optionD{All the above.}
 \putOptions
\end{ClosedQuestion}
}


% Microservices and Event Sourcing

\newcommand{\qEventSourcingOne}{
\begin{ClosedQuestion}
	Command Query Responsibility Segregation (CQRS) technique uses the following architectural styles
			
    \optionA{Client-server and Repository.}
    \optionB{Repository and Publish-subscribe.}
    \optionC{Publish-subscribe and Repository.}
    \optionD{Client-server, Repository and Publish-subscribe.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qEventSourcingTwo}{
\begin{ClosedQuestion}
	Consider the architectural solutions for microservices architectures that use the Command Query Responsibility Segregation (CQRS) technique in the context of Event Sourcing. This technique has the following disadvantage 
			
    \optionA{Does not allow optimizations according to the type of query.}
    \optionB{Does not support independent scalability according to the type of operation.}
    \optionC{Reads may not be consistent with the most recent write.}
    \optionD{Does not support joins.}
 \putOptions
\end{ClosedQuestion}
}



% Fourth Mini-test

% Allocation Styles

\newcommand{\qAllocationStylesCost}{
\begin{ClosedQuestion}
	Consider a stakeholder that is particularly concerned about the total cost of the project. When it comes to describing the system using allocation viewtypes she is interested in

    \optionA{A deployment view.}
    \optionB{A work assignment view.}
    \optionC{A deployment and a work assignment view.}
    \optionD{A install view.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qWorkAssignment}{
\begin{ClosedQuestion}
  The Work-assignment is an architectural style of the allocation viewtype, where

    \optionA{Components are allocated to persons and teams.}
    \optionB{Modules are allocated to persons and teams.}
    \optionC{Components and modules are allocated to persons and teams.}
    \optionD{None of the above.}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}


% Catalog of DVD

\newcommand{\qDVDCatalogMeta}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		The application should support other kinds of catalogs (CDs, games, books, ...). 
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The layered view to support a new specific layer for the customization of the catalog.}
    \optionB{The layered view to accommodate a new layer for each kind of catalog, which other layers may use.}
    \optionC{The data model view in order to define entities for each kind of catalog.}
    \optionD{The data model view in order to define generic entities that can be customized for different kinds of catalogs.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qDVDCatalogMobile}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the Catalog of DVD application. The architect knows about a new requirement 
	
	\begin{quote}
		To support iPhone, iPad, Android versions with sync, which allows offline use of the application in the mobile device and data synchronization to occur when a connection is available
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The decomposition view to include a module for the synchronization responsibilities.}
    \optionB{The uses view to represent how the mobile device uses the Catalog application.}
    \optionC{The layered view to include a layer for each type of device.}
    \optionD{The domain layer of the layered style to represent the types of devices.}
 \putOptions
\end{ClosedQuestion}
}



% Graphite

\newcommand{\qGraphiteClientServer}{
 \begin{ClosedQuestion}
    In Graphite system, in order to generate up-to-date graphs, the \emph{WebApp} component interacts with the \emph{Carbon} component. The interaction between these two components follows the architectural style

    \optionA{Client-server.}
    \optionB{Communicating Processes.}
    \optionC{Repository.}
    \optionD{Pipes-and-Filters.}

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGraphiteCommunicationProcesses}{
 \begin{ClosedQuestion}
    In Graphite system the \emph{receiver} and the \emph{writer threads} support asynchronous writing of metrics to optimize disk accesses. The interaction between these two components follow the architectural style

    \optionA{Client-server.}
    \optionB{Communicating Processes.}
    \optionC{Repository.}
    \optionD{Pipes-and-Filters.}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}



% Chrome

\newcommand{\qChromeCommunicatingProcesses}{
 \begin{ClosedQuestion}
    In Chrome system, to show that it provides availability when the javascript code executing in a tab crashes, and security when the javascript code executing in a tab tries to access the information in another tab, it is necessary to design

    \optionA{One view of the component-and-connector viewtype and another of the deployment style.}
    \optionB{A single view of the communicating processes style.}
    \optionC{Two views of the communicating processes style.}
    \optionD{A view of the aspects style.}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qChromeDynamicReconfiguration}{
 \begin{ClosedQuestion}
    In Chrome system, to show that it provides mobility qualities by managing the number of tab, it is necessary to use

    \optionA{The communicating processes style.}
    \optionB{The communicating processes style and the dynamic reconfiguration style.}
    \optionC{The communicating processes style and the pipes-and-filters style.}
    \optionD{The dynamic reconfiguration style.}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}



% Microservices

\newcommand{\qAggregateAndEventSourcing}{
 \begin{ClosedQuestion}
	 How can be guaranteed that the update of an aggregate and the publishing of an event about the update is an atomic action

    \optionA{The aggregates publishes the event in a message broker and subscribes to the published event.}
    \optionB{Using the database of the aggregate as a temporary message queue.}
    \optionC{Using event sourcing.}
    \optionD{All of the above.}

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qEventSourcing}{
 \begin{ClosedQuestion}
    Event Sourcing is a technique that use the following architectural style

    \optionA{The communicating processes.}
    \optionB{Pipes-and-filters.}
    \optionC{Publish-subscribe.}
    \optionD{Dynamic reconfiguration.}

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}




% Third Mini-test

% Module styles one

\newcommand{\qLayered}{
\begin{ClosedQuestion}
	Consider the Layered architectural style of the Module viewtype
		
    \optionA{The modules inside a layer cannot use other modules in the same layer}
    \optionB{A layer cannot call the layer above}
    \optionC{Each layer defines a virtual machine because it provides a set of cohesive functionalities to the upper layer}
    \optionD{It is possible to have a circular allowed-to-use relationship between several layers}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qAspects}{
  \begin{ClosedQuestion}
    Using the Aspects architectural style promotes the modifiability
    of a system because
    
    \optionA{It imposes restrictions on which uses relationships may
      exist between the system's modules}
    \optionB{It makes it easier to create generalization relationships
      between the system's modules}
    \optionC{It separates in new modules responsibilities that were
      spread over various of the system's modules}
    \optionD{It allows the decomposition of each of the system's
      modules into finer grained modules}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


% Module styles two

\newcommand{\qDataModelOne}{
  \begin{ClosedQuestion}
	  The detail that can be used in a view of the Data Model viewtype can be conceptual, logical or physical.
	  
      \optionA{If there are performance requirements concerning the access to data, then the level of detail should be physical}
      \optionB{It should always consider the physical detail level}
      \optionC{The logical detail level should only be used when the target of implementation is a relational database}
      \optionD{Only the conceptual level is required, the other two levels of detail are optional} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qDataModelTwo}{
\begin{ClosedQuestion}
	In Facebook it is not possible to have the information about more that one bilion users in a single disk. Therefore, a sharding technique is applied, where the persistent information is split between several database servers, and requests are routed to the right servers for queries and updates. Additionally, due to performance requirements, the information needs to be replicated in several servers. To describe this architecture
	
    \optionA{It is not necessary to have any view of the Data Model architectural style because Facebook information has a very simple structure.}
    \optionB{It is enough to design a view of the Data Model architectural style at the conceptual level because Facebook information has a very simple structure.}
    \optionC{It is enough to design a view of the Data Model architectural style at the logical level because the information will be stored in a relational database.}
    \optionD{It is necessary to design a view of the Data Model architectural style at the physical level to deal with performance and consistency issues of the access to data.}
 \putOptions
\end{ClosedQuestion}
}


% Component-and-connector viewtype

\newcommand{\qComponentAndConnectorOne}{
\begin{ClosedQuestion}
	In the component-and-connector viewtype connectors can be complex, which means that they provide a rich set of qualities to the interaction between the components that they connect. These complex connectors can be documented in another view using a set of components interacting through simpler connectors.
		
    \optionA{Whenever complex connectors are used in architectural views it is necessary to also document their decomposition.}
    \optionB{It is preferable to only design views that do not use complex connectors to increase understandability.}
    \optionC{If there is some technology available that implements the complex connectors, according to its expected qualities, it is not necessary to document their decomposition.}
    \optionD{Whenever possible it should be avoided to use complex connectors because developers have difficult to know how to implement them.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorTwo}{
\begin{ClosedQuestion}
	Consider the Component-and-Connector viewtype
		
    \optionA{A component is an instance and a view can have several instances of the same component type.}
    \optionB{A component type is made of a single architectural style.}
    \optionC{Only components can be associated with application-specific types.}
    \optionD{A component-and-connector view can only use a single architectural style.}
 \putOptions 
\end{ClosedQuestion}
}


% Component-and-connector styles one

\newcommand{\qPipesFilters}{
\begin{ClosedQuestion}
	Consider that you intend to develop a system where it is necessary to change the emails received by the server (for instance, to remove potential virus or URLs for phishing sites). The goal is that each email is processed by this system before it is sent to other servers or it is stored locally. Additionally, the system should be easily modified to support new kinds of transformations. Which style is more suitable to satisfy these requirements? 

    \optionA{Peer-to-Peer.}
    \optionB{Pipe-and-Filter.}
    \optionC{Client-Server.}
    \optionD{Publish-Subscribe.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qPeerToPeer}{
\begin{ClosedQuestion}
	Consider the peer-to-peer architectural style
		
    \optionA{All the peers are equal.}
    \optionB{Any peer can access any other peer.}
    \optionC{Peers are only used to share files.}
    \optionD{The interaction between peers is symmetric.}
 \putOptions 
\end{ClosedQuestion}
}


% Component-and-connector styles two

\newcommand{\qSOA}{
\begin{ClosedQuestion}
	Consider the Service-Oriented Architecture architectural style
		
    \optionA{The main quality this style addresses is interoperability.}
    \optionB{It cannot be applied when the system includes legacy systems.}
    \optionC{Its enterprise service bus cannot support asynchronous communication between the components.}
    \optionD{The typical communication pattern is point-to-point.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qTiers}{
\begin{ClosedQuestion}
	The Tiers architectural style
	
    \optionA{Applies layers to tiers.}
    \optionB{Restricts the communication between components because, for instance, a group of components should be located in the same hardware.}
    \optionC{Is an extension of the Client-Server architectural style.}
    \optionD{Defines tiers as components.}
 \putOptions
\end{ClosedQuestion}
}




% Second Mini-test

% Modifiability and Availability

\newcommand{\qModifiabilityResponseMeasure}{
\begin{ClosedQuestion}
	A response measure of a modifiability scenario is
		
    \optionA{When the modification should occur.}
    \optionB{The features that will be implemented.}
    \optionC{The new defects introduced.}
    \optionD{Defer binding.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qAvailabilityVotingFirst}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to detect faults of type
    \emph{response} in your system, which tactic is more adequate?

    \optionA{Ping/Echo.}
    \optionB{Retry.}
    \optionC{Voting.}
    \optionD{Passive Redundancy.}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


% Designing-an-Architecture

\newcommand{\qIterativeDesign}{
\begin{ClosedQuestion}
	Designing an architecture

    \optionA{Is driven by functional requirements.}
    \optionB{Is done in a single step, after all the tactics were identified.}
    \optionC{Is a top-down process where a initial decomposition is chosen and it is successively decomposed without changing the initial decisions.}
    \optionD{Is an iterative process where architectural designs are proposed as hypothesis and tested.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qLowArchitecturalImpact}{
\begin{ClosedQuestion}
	Consider an architecturally significant requirement (ASR) that has a low impact on the architecture but a high business value

    \optionA{This ASR can easily be supported by the architecture because it has little effect in the architecture.}
    \optionB{This ASR requires a specific architectural design because it profoundly affects the architecture.}
    \optionC{The cost of meeting the ASR after development starts is too high.}
    \optionD{Any ASR that has a high business value cannot have a low architecture impact because it needs to be supported by the architecture.}
 \putOptions
\end{ClosedQuestion}
}



% Module Viewtype

\newcommand{\qDecomposition}{
\begin{ClosedQuestion}
	The Decomposition architectural style of the Module viewtype 
	
    \optionA{Is applied only once at the beginning of the architectural design process.}
    \optionB{Is applied at the begin of the architectural design process but may be necessary to redo it later.}
    \optionC{Is mostly driven by the security attribute quality.}
    \optionD{Follows a bottom-up decomposition process of the system.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qUsesCalls}{
\begin{ClosedQuestion}
	A function call is not necessarily a uses relation of the Uses architectural style of the Module viewtype because
	
    \optionA{The correctness of the caller module may not depend on the correct implementation of the invoked function in the called module.}
    \optionB{The invoked function may not have any input parameter.}
    \optionC{The invoked function may not have any output parameter.}
    \optionD{The invoked function may not have both any input parameter nor any output parameter.}
 \putOptions
\end{ClosedQuestion}
}



% Chrome

\newcommand{\qChromeTabSecurity}{
\begin{ClosedQuestion}
	In the Chrome system the use of a process per tab results form the application of a tactic of
	
    \optionA{Limit access.}
    \optionB{Increase resources.}
    \optionC{Increase resource efficiency.}
    \optionD{Maintain multiple copies of data.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qChromePredictor}{
\begin{ClosedQuestion}
	In the description of the Chrome system can be read
	
	\begin{quote}
		The goal of the predictor is to evaluate the likelihood of its success, and then to trigger the activity if resources are available. 
	\end{quote}
	
	The above sentence refer to
	
    \optionA{Maintain multiple copies of data tactic.}
    \optionB{Introduce concurrence tactic.}
    \optionC{Increase resource efficiency tactic.}
    \optionD{Schedule resources tactic.}
 \putOptions
\end{ClosedQuestion}
}

% SocialCalc

\newcommand{\qSocialCalcTacticsOne}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		As the user scrolls the spreadsheet through our custom-drawn scroll bars, we dynamically update the innerHTML of the pre-drawn \textsc{<td>} elements. This means we don't need to create or destroy any \textsc{<tr>} or \textsc{<td>} elements in many common cases, which greatly speeds up response time.
	\end{quote} 
	
	This corresponds to the application of

    \optionA{Manage sampling rate tactic.}
    \optionB{Increase resource efficiency tactic.}
    \optionC{Introduce concurrency tactic.}
    \optionD{Schedule resources tactic.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qSocialCalcTacticsTwo}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		A simple improvement is for each client to broadcast its cursor position to other users, so everyone can see which cells are being worked on.
	\end{quote}
	
	This sentence describes a tactic for usability which is

    \optionA{Maintain task model}
    \optionB{Maintain user model}
    \optionC{Maintain system model}
    \optionD{Aggregate}
 \putOptions
\end{ClosedQuestion}
}


% First Mini-test

% Microservices

\newcommand{\qMicroservicesMonitorability}{
\begin{ClosedQuestion}
	In the description of the Microservices Architecture by James Lewis and Martin Fowler can be read:
	
	\begin{quote}
		Microservice teams would expect to see (...) for each individual service such as dashboards showing up/down status and a variety of operational and business relevant metrics. Details on circuit breaker status, current throughput and latency are other examples we often encounter in the wild.
	\end{quote}
	
	Which quality is being referred?

    \optionA{Performance}
    \optionB{Availability}
    \optionC{Usability}
    \optionD{Monitorability}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesModuleAndComponent}{
\begin{ClosedQuestion}
	In the description of the Microservices Architecture by James Lewis and Martin Fowler can be read:
	
	\begin{quote}
		As well as the fact that services are independently deployable and scalable, each service also provides a firm module boundary, even allowing for different services to be written in different programming languages. They can also be managed by different teams.
	\end{quote}
	
	For this description it is relevant to consider the software architecture concept(s) of

    \optionA{Component}
    \optionB{Module}
    \optionC{Component and Module}
    \optionD{None of the above}
 \putOptions 
\end{ClosedQuestion}
}



% How Netflix Works

\newcommand{\qNetflixTacticsOne}{
\begin{ClosedQuestion}
	In the description of the \emph{How Netflix works} can be read:
	
	\begin{quote}
		The Netflix app or website determines what particular device you are using to watch, and fetches the exact file for that show meant to specially play on your particular device, with a particular video quality based on how fast your internet is at that moment.
	\end{quote}
	
	Which corresponds to the application of the following tactic
	
    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Introduce concurrency}
    \optionD{Prioritize events}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qNetflixTacticsTwo}{
\begin{ClosedQuestion}
	In the description of the \emph{How Netflix works} can be read:
	
	\begin{quote}
		What CDNs basically do is, they take the original website and the media content it contains, and copy it across hundreds of servers spread all over the world. So when, say, you log in from Budapest, instead of connecting to the main Netflix server in the United States it will load a ditto copy of it from a CDN server that is the closest to Budapest.
	\end{quote}
	
	Which corresponds to the application of the following tactic
	
    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Maintain multiple copies of data}
    \optionD{Maintain multiple copies of computation}
 \putOptions 
\end{ClosedQuestion}
}


% Scalable Web Architecture and Distributed Systems

\newcommand{\qLoadBalancer}{
\begin{ClosedQuestion}
	To which performance tactic can a load balancer be associated?

    \optionA{Maintain multiple copies of data}
    \optionB{Maintain multiple copies of computation}
    \optionC{Bound execution times}
    \optionD{Reduce overhead}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qQueues}{
\begin{ClosedQuestion}
	To which performance tactic can the use of queues be associated?

    \optionA{Limit event response}
    \optionB{Schedule resources}
    \optionC{Bound execution times}
    \optionD{Increase resource efficiency}
 \putOptions
\end{ClosedQuestion}
}


%Graphite

\newcommand{\qGPComposerUIQuality}{
  \begin{ClosedQuestion}
	  Which quality, or qualities, of the Graphite system are described by the sentence: \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL.}

    \optionA{Usability and Performance}
    \optionB{Usability}
    \optionC{Performance}
    \optionD{Testability} 

     \putOptions
   \end{ClosedQuestion}
}

\newcommand{\qGraphiteScenarioTacticsOne}{
  \begin{ClosedQuestion}
    In the Graphite system the component \emph{carbon} provides to \emph{webapp} components an access interface to the \emph{buffers} in order to improve the quality of

    \optionA{Performance.}
    \optionB{Interoperability.}
    \optionC{Availability.}
    \optionD{Security.}

     \putOptions
   \end{ClosedQuestion}
}



% High Performance Networking in Chrome

\newcommand{\qChromeQualities}{
\begin{ClosedQuestion}
	Which quality(ies) of Chrome can be inferred from the sentence below?
	
	\begin{quote}
		By contrast, Chrome works on a multi-process model, which provides process and memory isolation, and a tight security sandbox for each tab. In an increasingly multi-core world, the ability to isolate the processes as well as shield each open tab from other misbehaving pages alone proves that Chrome has a significant performance edge over the competition. In fact, it is important to note that most other browsers have followed suit, or are in the process of migrating to similar architecture.
	\end{quote}
	
    \optionA{Performance}
    \optionB{Security}
    \optionC{Performance and security}
    \optionD{Security and modifiability}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qChromeTactics}{
\begin{ClosedQuestion}
	Which performance tactic is referred in the following description of Chrome?

	\begin{quote}
		The ability of the browser to optimize the order, priority, and latency of each network resource is one of the most critical contributors to the overall user experience. You may not be aware of it, but Chrome's network stack is, quite literally, getting smarter every day, trying to hide or decrease the latency cost of each resource: it learns likely DNS lookups, it remembers the topology of the web, it pre-connects to likely destination targets, and more. From the outside, it presents itself as a simple resource fetching mechanism, but from the inside it is an elaborate and a fascinating case study for how to optimize web performance and deliver the best experience to the user.
	\end{quote}
	
    \optionA{Limit event response}
    \optionB{Maintain multiple copies of computation}
    \optionC{Maintain multiple copies of data}
    \optionD{Schedule resources}
 \putOptions 
\end{ClosedQuestion}
}

%% =========================================================================
%% exams and tests 2017/2018
%% =========================================================================

% First and Second Exams


% Availability

\newcommand{\qAvailabilityOne}{
\begin{ClosedQuestion}
	The stimulus of an availability scenario is
		
    \optionA{A failure.}
    \optionB{An error.}
    \optionC{A fault.}
    \optionD{An input.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qAvailabilityTwo}{
\begin{ClosedQuestion}
	An availability tactic to prevent faults is 
		
    \optionA{Increase competence set.}
    \optionB{Shadow.}
    \optionC{Voting.}
    \optionD{Ignore faulty behavior.}
 \putOptions 
\end{ClosedQuestion}
}


% Performance

\newcommand{\qPerformanceOne}{
\begin{ClosedQuestion}
	A response measure of a performance scenario is 
		
    \optionA{Stochastic event.}
    \optionB{Overload.}
    \optionC{Change level of service.}
    \optionD{Throughput.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qPerformanceTwo}{
\begin{ClosedQuestion}
	A performance tactic to control resource demand is 
		
    \optionA{Increase resources.}
    \optionB{Reduce overhead.}
    \optionC{Bound queue sizes.}
    \optionD{Introduce concurrency.}
 \putOptions 
\end{ClosedQuestion}
}

% Modifiability

\newcommand{\qModifiabilityExamOne}{
\begin{ClosedQuestion}
	The layered architectural style applies the modifiability architectural tactic of
		
    \optionA{Split module.}
    \optionB{Use an intermediary.}
    \optionC{Restrict dependencies.}
    \optionD{Refactor.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qModifiabilityExamTwo}{
\begin{ClosedQuestion}
	A response measure of a modifiability scenario is
		
    \optionA{When the modification should occur.}
    \optionB{The features that will be implemented.}
    \optionC{The new defects introduced.}
    \optionD{Defer binding.}
 \putOptions 
\end{ClosedQuestion}
}


% Module viewtype

\newcommand{\qModuleViewtypeExamOne}{
\begin{ClosedQuestion}
	One of the advantages of having views of the module viewtype is that they allow to do an impact analysis to predict the effect of modifying the system. The architectural style of the module viewtype which provides richer information for this impact analysis is
		
    \optionA{Decomposition style.}
    \optionB{Uses style.}
    \optionC{Generalization style.}
    \optionD{Layered style.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qModuleViewtypeExamTwo}{
\begin{ClosedQuestion}
	One of the advantages of having views of the module viewtype is that they allow to do a traceability analysis of requirements, how the functional requirements of the system are supported by module responsibilities. The modifiability tactic that is involved in this mapping is
		
    \optionA{Split module.}
    \optionB{Abstract common services.}
    \optionC{Restrict dependencies.}
    \optionD{Encapsulation.}
 \putOptions 
\end{ClosedQuestion}
}


% Module styles

\newcommand{\qDecompositionGeneralization}{
\begin{ClosedQuestion}
  Consider that a chess game should
  provide an automatic and intelligent chess player, and that to
  implement that player we will use some of the many chess engines
  already available in the market.  Moreover, the system should allow
  the user to choose which engine to use for each new game.  Given
  these requirements, which of the architectural styles from the
  module viewtype are best suited to satisfy them?
 
  \optionA{The Decomposition style.}
  \optionB{The Decomposition and Uses styles.}
  \optionC{The Layered style.}
  \optionD{The Generalization and Decomposition styles.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qDVDCatalogMobile}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the Catalog of DVD application. The architect knows about a new requirement 
	
	\begin{quote}
		To support iPhone/iPad/Android version with sync, which allows offline use of the application in the mobile device and data synchronization to occur when a connection is available
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The decomposition view to include a module for the synchronization responsibilities}
    \optionB{The uses view to represent how the mobile device uses the Catalog application}
    \optionC{The layered view to include a layer for each type of device}
    \optionD{The domain layer of the layered style to represent the types of devices}
 \putOptions
\end{ClosedQuestion}
}


% Component-and-Connector viewtype

\newcommand{\qComponentAndConnectorViewtypeOne}{
\begin{ClosedQuestion}
	In the component-and-connector viewtype connectors can be complex, which means that they provide a rich set of qualities to the interaction between the components that they connect. These complex connectors can be documented in another view using a set of components interacting through simpler connectors.
		
    \optionA{Whenever complex connectors are used in architectural views it is necessary to also document their decomposition.}
    \optionB{It is preferable to only design views that do not use complex connectors to increase understandability.}
    \optionC{If there is some technology available that implements the complex connectors it is not necessary to document their decomposition.}
    \optionD{Whenever possible it should be avoided to use complex connectors because developers have difficult to know how to implement them.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorViewtypeTwo}{
\begin{ClosedQuestion}
	Considered the following two views of a system that receive a stream of character and produce the same stream where the characters are alternately uppercase and lowercase.
	
	\centering
	\includegraphics[width=12cm]{1-module-and-cc}
		
    \optionA{The \emph{config} module is not used in the implementation of any component.}
    \optionB{The \emph{main} module is used in the implementation of all components.}
    \optionC{The connectors only use the \emph{stdio} module for their implementation.}
    \optionD{The \emph{Split} component uses the \emph{to\_lower} module for its implementation}
 \putOptions 
\end{ClosedQuestion}
}


% Component-and-Connector style

\newcommand{\qPublishsubscribeOne}{
  \begin{ClosedQuestion}
	  Typically, Instant Messaging clients have a window to list the contacts of the user, and
	  show in that window the status of each contact (whether it is available, unavailable, busy,
	  etc). Given that the status of a contact may be changed at any time, and that the contact's
	  status is given by the Instant Messaging application of that contact, which architectural
	  style represents best the interaction pattern between these components?

	   \optionA{The Shared Data style.}
	   \optionB{The Pipes-and-filters style.}
	   \optionC{The Publish-subscribe style.}
	  \optionD{The Client-Server style.}
   \putOptions

  \end{ClosedQuestion}
}

\newcommand{\qPipesFilters}{
\begin{ClosedQuestion}
	Consider that you intend to develop a system where it is necessary to change the emails received by the server (for instance, to remove potential virus or URLs for phishing sites). The goal is that each email is processed by this system before it is sent to other servers or it is stored locally. Additionally, the system should be easily modified to support new kinds of transformations. Which style is more suitable to satisfy these requirements? 

    \optionA{Peer-to-Peer.}
    \optionB{Pipe-and-Filter.}
    \optionC{Client-Server.}
    \optionD{Publish-Subscribe.}
 \putOptions
\end{ClosedQuestion}
}

% Architectures for scalable web applications

\newcommand{\qProxyServer}{
\begin{ClosedQuestion}
	Consider the following figure that presents a Proxy Server that collapses requests from different users.
	
	\begin{center}
		\includegraphics[width=12cm]{1-proxy-server}
	\end{center}
	
	
    \optionA{This solution optimizes the performance in terms of the latency of each request.}
    \optionB{This solution allows an "infinite"\ increase of the number clients by allowing the inclusion of more Request Nodes.}
    \optionC{This solution continues to provide service even if a crash occurs in the Data server.}
    \optionD{This solution optimizes the performance in terms of the throughput of processed requests.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qScalableArchitectureOne}{
  \begin{ClosedQuestion}
    Consider the following figure that presents a Image Hosting System.
	
	\begin{center}
		\includegraphics[width=12cm]{1-image-hosting}
	\end{center}
	
	By adding another Image File Storage component, which contains a redundant copy of the data and provides read access to the clients, but without guaranteeing a ACID transactional behavior between reads and writes, it improves the quality(ies) of
	
    \optionA{Performance.}
    \optionB{Availability for incorrect responses from the Image File Storage component.}
    \optionC{Performance and Availability for crashes of the Image File Storage component.}
    \optionD{Performance and Availability for incorrect responses from the Image File Storage component.}
    \putOptions

 \end{ClosedQuestion}
}


% The Architecture of Graphite

\newcommand{\qGraphiteOne}{
\begin{ClosedQuestion}
	Consider the following fragment in the description of the Graphite system.
	
	\begin{quote}
		The Graphite webapp allows users to request custom graphs with a simple URL-based API. Graphing parameters are specified in the query-string of an HTTP GET request, and a PNG image is returned in response. 
	\end{quote}
	
	To describe this scenario it should be designed a view that applies the following architectural style
		
    \optionA{Decomposition.}
    \optionB{Aspects.}
    \optionC{Layered.}
    \optionD{Data model.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qGraphiteTwo}{
\begin{ClosedQuestion}
	  Which quality, or qualities, of the Graphite system are described by the sentence: \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL.}

    \optionA{Usability and Performance.}
    \optionB{Usability.}
    \optionC{Performance.}
    \optionD{Modifiability.}
 \putOptions 
\end{ClosedQuestion}
}


% The Architecture of Catalog of DVDs

\newcommand{\qDVDOne}{
\begin{ClosedQuestion}
	Consider the following usability scenario of the Catalog of DVDs case study
	
	\begin{quote}
		The user intends to have up-to-date info about the movies and the system informs the user that the existing sources have new information about one of his DVDs, which helps to maintain an up-to-date catalog. 
	\end{quote}
	
	The tactic used to fulfill this scenario is
		
    \optionA{Aggregate.}
    \optionB{Maintain user model.}
    \optionC{Maintain task model.}
    \optionD{Maintain system model.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qDVDTwo}{
\begin{ClosedQuestion}
	Consider the following generalization view of the Catalog of DVD case study to fulfill a modifiability scenario
	
	\begin{center}
		\includegraphics[width=6cm]{1-dvd-generalization}
	\end{center}
	
	From this view the stakeholders can infer
			
    \optionA{The cost of the modification.}
    \optionB{That the integration of a new source will not have any impact on the other modules of the Catalog of DVDs.}
    \optionC{That the impact of integrating a new source is controlled by the interface of \emph{Import DVD Info} Module.}
    \optionD{That the modification can occur at runtime.}
 \putOptions 
\end{ClosedQuestion}
}

% The Architecture of Adventure Builder

\newcommand{\qAdventureBuilderOne}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder case study that applies the tiers architectural style 
	
	\centering
	\includegraphics[width=10cm]{1-adventure-tiers}
		
    \optionA{This view shows that if is possible to scale differently the \texttt{web tier} from the \texttt{EJB tier}.}
    \optionB{This view shows that the \texttt{Adventure Builder Catalog DB} and the \texttt{OPC} components should be deployed in the same hardware.}
    \optionC{This view \textbf{does not} show that the \texttt{Adventure Builder Catalog DB} and the \texttt{OPC} components can execute behind a firewall.}
    \optionD{This view \textbf{does not} show that the access to the \texttt{web tier} has some security qualities.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderTwo}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder case study 
	
	\centering
	\includegraphics[width=12cm]{1-adventure-com-proc}
		
    \optionA{This view shows that the processing of orders is done synchronously.}
    \optionB{This view shows that the processing of tracking requests is done synchronously.}
    \optionC{This view shows that bank debits are done asynchronously.}
    \optionD{This view shows that the responses from the providers are processed synchronously.}
 \putOptions
\end{ClosedQuestion}
}

% The Architecture of Pulse

\newcommand{\qPulseOne}{
\begin{ClosedQuestion}
	Consider the following view of the Pulse case study 
	
	\begin{center}
		\includegraphics[width=12cm]{1-pulse-multiple-copies-computation}
	\end{center}
	
	This view provides a solution that uses the following tactic
			
    \optionA{Pipe-and-filter.}
    \optionB{Maintain multiple copies of data.}
    \optionC{Maintain multiple copies of computation.}
    \optionD{Introduce concurrency.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qPulseTwo}{
\begin{ClosedQuestion}
	Consider the following view of the Pulse case study 
	
	\begin{center}
		\includegraphics[width=12cm]{1-pulse-multiple-copies-computation}
	\end{center}
	
	This view applies the following architectural styles
			
    \optionA{Pipe-and-filter and tiers.}
    \optionB{Shared-data and publish-subscribe.}
    \optionC{Pipe-and-filter and publish-subscribe.}
    \optionD{Pipe-and-filter and shared-data.}
 \putOptions
\end{ClosedQuestion}
}

% The Architecture of the Morrison's OrderPad

\newcommand{\qOrderPadOne}{
\begin{ClosedQuestion}
	In the description of architecture of the OrderPad case study it can be read that the updates the user does on the OrderPad when it is offline are not lost. This availability quality is achieved through a	

  \optionA{Ignore faulty behaviour tactic}
  \optionB{Ping-and-echo tactic}
  \optionC{Active redundancy tactic}
  \optionD{Retry tactic}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qOrderPadTwo}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. The connector between the client component, executing in the Pad, and the server component, executing in the OrderPadDatabase
	
    \optionA{Guarantees that the redundant data in the client and the server is always synchronized.}
    \optionB{Implements an event bus that allows the server to inform the client about new order recommendations.}
    \optionC{Do not loose the changes done on the client component if the server is not available.}
    \optionD{It completely hides the server faults from the Pad user.}
 \putOptions
\end{ClosedQuestion}
}

% Architectural Viewtypes and Styles

\newcommand{\qLayered}{
\begin{ClosedQuestion}
	Consider the Uses architectural style of the Module viewtype
		
    \optionA{Cycles in the uses relation between modules are a good sign, because it indicates that several modules should be tested together.}
    \optionB{The project manager uses this view to get advice on the incremental development of the system.}
    \optionC{The uses relation should be applied to the coarse-grained modules, because it allows to identify circular dependences.}
    \optionD{There isn't any relation with the layered architectural style because the allowed-to-use relation is more generic.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qDataModel}{
\begin{ClosedQuestion}
	In Facebook it is not possible to have the information about more that one bilion users in a single disk. Therefore, a sharding technique is applied, where the persistent information is split between several database servers, and requests are routed to the right servers for queries and updates. Additionally, due to performance requirements, the information needs to be replicated in several servers. To describe this architecture
	
    \optionA{It is not necessary to have any view of the Data Model architectural style because Facebook information has a very simple structure.}
    \optionB{It is enough to design a view of the Data Model architectural style at the conceptual level because Facebook information has a very simple structure.}
    \optionC{It is enough to design a view of the Data Model architectural style at the logical level because the information will be stored in a relational database.}
    \optionD{It is necessary to design a view of the Data Model architectural style at the physical level to deal with performance and consistency issues of the access to data.}
 \putOptions
\end{ClosedQuestion}
}

% Component-and-connector

\newcommand{\qDynamicReconfiguration}{
\begin{ClosedQuestion}
	In the description of the Gnutella system can be read:
	
	\begin{quote}
		The topology of the system changes at runtime as peer components connect and disconnect to the network.
	\end{quote}
	
    \optionA{When a peer connects to the network it establishes connections with all other peers in the network.}
    \optionB{The behavior described in the sentence can be represented in a view where the dynamic reconfiguration architectural style is used.}
    \optionC{When a peer receives a connection it sends all its files to the peer connecting it.}
    \optionD{The behavior described in the sentence can be represented in a view where the tier architectural style is used.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qSOA}{
  \begin{ClosedQuestion}
    Suppose that you are developing the software architecture of a new
    system for an organization composed of several organizational
    units, each one with its own information systems, which have been
    developed independently of each other over the course of several
    years and depending on the particular needs of each unit.  Your
    system has the goal of integrating the various existing systems,
    providing in this way not only a unified view of how the
    organization works, but also allowing the creation of new
    processes within the organization that involve more than one unit.
    Which architectural style is better suited to design such a
    system?

    \optionA{The Decomposition style.}
    \optionB{The Client-Server style.}
    \optionC{The Service Oriented Architecture style.}
    \optionD{The Communicating Processes style.}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

% Allocation

\newcommand{\qDeployment}{
\begin{ClosedQuestion}
  In the software architecture of a system, the Deployment architectural style of the allocation viewtype is
  best suited for

    \optionA{Analysing the performance of the system.}
    \optionB{Planning incremental releases of the system.}
    \optionC{Estimating the effort needed to implement the system.}
    \optionD{Analysing the system's portability and reusability.}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qWorkAssigment}{
\begin{ClosedQuestion}
	Consider the Work Assignment architectural style of the allocation viewtype.
			
    \optionA{It assigns components and connectors to people and teams.}
    \optionB{It is useful for the project managers.}
    \optionC{It does not consider the software that is outsourced.}
    \optionD{It allows to estimate the cost of hardware.}
 \putOptions 
\end{ClosedQuestion}
}

% Archictectural variations of web applications 

\newcommand{\qWebAppsOne}{
\begin{ClosedQuestion}
	Consider a web application that was implemented using three layers: presentation, domain logic, and data access. How are these layers mapped into the components if it is a rich interface application.
			
    \optionA{All layers are mapped to the application server component.}
    \optionB{The presentation and domain logic layers are mapped to the application server component and the data access layer to the repository component.}
    \optionC{The presentation layer is mapped to the browser component and the other two layers are mapped to the application server component.}
    \optionD{All layers are mapped to the browser component where the data access layer will contains, besides a module to access a local repository, modules to access external services.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qWebAppsTwo}{
\begin{ClosedQuestion}
	Consider a web application that supports several types of user interface, e.g., web, mobile, etc. If it has to process a high volume of requests, which depend on the type of user interface, and a multi-tier architecture is followed. How many tiers should be used?
			
    \optionA{One.}
    \optionB{Two.}
    \optionC{Three.}
    \optionD{Four.}
 \putOptions 
\end{ClosedQuestion}
}

% The Architecture of Fnix

\newcommand{\qFenixOne}{
\begin{ClosedQuestion}
	In the context of the FenixEdu case study, the business case was to

    \optionA{Incorporate in the organization's core business the goals of a software house.}
    \optionB{Do in-house development.}
    \optionC{Integrate the development of the software system with the organization's business goals.}
    \optionD{Reimplement all the information systems of the organization}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qFenixTwo}{
\begin{ClosedQuestion}
	When applying Attribute-Driven Design (ADD) to the FenixEdu system the creation of a view where there are redundant web servers, load balancers and database servers 

    \optionA{Results from a utility tree for performance.}
    \optionB{Results from a single availability scenario.}
    \optionC{Results from the application of a single ADD iteration.}
    \optionD{Results from the application of several ADD iterations.}
 \putOptions
\end{ClosedQuestion}
}

% Microservices and Aggregates

\newcommand{\qAggregateOne}{
\begin{ClosedQuestion}
	In a microservices architecture, aggregates are used as a unit of processing

    \optionA{An aggregate can contain a large number of instances.}
    \optionB{An aggregate is usually loaded in its entirety from the database.}
    \optionC{An aggregate has runtime references to other aggregates.}
    \optionD{An aggregate is cluster of domain classes.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAggregateTwo}{
\begin{ClosedQuestion}
	Consider the following decomposition of a domain model into 3 aggregates. If, instead of this decomposition, \texttt{Customer} and \texttt{Order} were in the same aggregate  
	
	\centering
	\includegraphics[width=12cm]{1-aggregate}

    \optionA{It would reduce the scalability for updates of different orders for the same customer.}
    \optionB{Two users would conflict if they attempt to edit different orders for the same customer.}
    \optionC{As the number of orders grows it will be increasingly expensive to load the aggregate.}
    \optionD{All the above.}
 \putOptions
\end{ClosedQuestion}
}

% Microservices and Event Sourcing

\newcommand{\qMicroservicesExamOne}{
\begin{ClosedQuestion}
	Consider the Microservice architectural style. Which of the following sentences \textbf{does not} describe an advantage of microservices?
			
    \optionA{Each service can be developed and deployed independently}
    \optionB{Easier to scale development}
    \optionC{Eliminates any long-term commitment to a technology stack}
    \optionD{Testing is easier}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesExamTwo}{
\begin{ClosedQuestion}
	Consider the following definition of Microservice architectural style by Martin Fowler
	
	\begin{quote}
		The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.
	\end{quote}
	
	To represent an architecture based on Microservices 
			
    \optionA{We do not need a view of the module viewtype because it is about the runtime properties of the system.}
    \optionB{We do not need a view of the allocation viewtype because deployment is automated.}
    \optionC{The component-and-connector view should emphasize the performance qualities of systems following the microservices architecture.}
    \optionD{It is necessary to use views of the three viewtypes.}
 \putOptions 
\end{ClosedQuestion}
}


% Fourth Mini-test


% Component-and-connector crosscutting concerns and allocation styles

\newcommand{\qCommunicatingProcesses}{
\begin{ClosedQuestion}
	In the web page of the NGINX HTTP server can be read
	
	\begin{quote}
		NGINX is a free, open-source, high-performance HTTP server and reverse proxy, as well as an IMAP/POP3 proxy server. (...)
		Unlike traditional servers, NGINX doesn't rely on threads to handle requests. Instead it uses a much more scalable event-driven (asynchronous) architecture. This architecture uses small, but more importantly, predictable amounts of memory under load.
	\end{quote}
	
	According to the above description the most adequate architectural style to represent the performance qualities of NGINX is
	
    \optionA{Dynamic Reconfiguration.}
    \optionB{Tiers.}
    \optionC{Communicating Processes.}
    \optionD{Install.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qTiers}{
\begin{ClosedQuestion}
	The Tiers architectural style
	
    \optionA{Applies layers to tiers.}
    \optionB{Restricts the communication between components because, for instance, a group of components should be located in the same hardware.}
    \optionC{Is an extension of the Client-Server architectural style.}
    \optionD{Defines tiers as components.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAllocationStylesCost}{
\begin{ClosedQuestion}
	Consider a stakeholder that is particularly concerned about the total cost of the project. When it comes to describing the system using allocation viewtypes is interested in

    \optionA{A deployment view.}
    \optionB{A work assignment view.}
    \optionC{A deployment and a work assignment view.}
    \optionD{A install view.}
 \putOptions
\end{ClosedQuestion}
}


% Catalog of DVD

\newcommand{\qDVDTopDecomposition}{
\begin{ClosedQuestion}
	Consider the following decomposition view of the Catalog of DVD case study.
	
	\centering
	\includegraphics[width=10cm]{dvd-top-decomposition}

    \optionA{The decomposition was driven by a defer binding tactic.}
    \optionB{The decomposition was driven by a quality that is supported by a restrict dependencies tactic.}
    \optionC{The decomposition was driven by a split module tactic.}
    \optionD{The decomposition was driven by a quality that is supported by an encapsulate tactic.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qDVDAutocomplete}{
\begin{ClosedQuestion}
	Consider the following decomposition views of the Catalog of DVD case study were the \emph{Autocomplete} module is implemented in javascript and executes in a browser.
	
	\centering
	\includegraphics[width=12cm]{dvd-autocomplete}

    \optionA{The view illustrates the achievement of a security scenario.}
    \optionB{The view illustrates the achievement of a performance scenario.}
    \optionC{The view results from the implementation of a support user initiative tactic.}
    \optionD{The view results from the implementation of a support system initiative tactic.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qDVDGeneralization}{
\begin{ClosedQuestion}
	Consider the following generalization view of the Catalog of DVD case study.
	
	\centering
	\includegraphics[width=6cm]{dvd-generalization}

    \optionA{This generalization was driven by a split module tactic.}
    \optionB{This view fulfills an availability scenario, which defines the expected behavior whenever an external source is not available.}
    \optionC{This view fulfills a modifiability scenario, which states about the cost of adding a new source of information to the system.}
    \optionD{This view fulfills a modifiability scenario, which states that it should be easy to support the system in new software platforms, e.g. \emph{Windows} or \emph{OS X} .}
 \putOptions
\end{ClosedQuestion}
}


% Graphite

\newcommand{\qGraphitePerformanceScenario}{
\begin{ClosedQuestion}
	In the context of the \emph{Graphite} case study, consider the following view that represents the internal behavior of the \emph{Carbon} component, where the components \texttt{r1,... , rn, w} are threads and \texttt{q1, ..., qn} are buffers. This view shows the Graphite's architecture support of
	
	\centering
	\includegraphics[width=12cm]{graphite-carbon}

    \optionA{A performance scenario associated with the throughput of writing data points to disk.}
    \optionB{A performance scenario associated with the latency of writing data points to disk.}
    \optionC{An availability scenario associated with a fault in the \emph{Carbon} component.}
    \optionD{A usability scenario.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qGraphiteAvailabilityScenario}{
\begin{ClosedQuestion}
	In the context of the \emph{Graphite} case study, consider the following view that represents the internal behavior of the \emph{Carbon} component, where the components \texttt{r1,... , rn, w} are threads and \texttt{q1, ..., qn} are buffers. The port \emph{read}, which provides an interface to read the data points stored in the queue, can be used, in an enrichment of the view, to illustrate
	
	\centering
	\includegraphics[width=12cm]{graphite-carbon}

    \optionA{A modifiability scenario the \emph{Graphite} system.}
    \optionB{A usability scenario of the \emph{Graphite} system.}
    \optionC{A performance scenario of the \emph{Graphite} system.}
    \optionD{An availability scenario of the \emph{Graphite} system.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qGraphiteWebapp}{
\begin{ClosedQuestion}
	In the context of the \emph{Graphite} case study, consider the following application-specific types that are used in a view to represent the internal behavior of the \emph{Webapp} component. 
	
	\centering
	\includegraphics[width=12cm]{graphite-webapp}
	
	This view can show that the architecture fulfills  

    \optionA{A modifiability scenario the \emph{Graphite} system.}
    \optionB{A usability scenario of the \emph{Graphite} system.}
    \optionC{A single performance scenario of the \emph{Graphite} system.}
    \optionD{At least two performance scenarios of the \emph{Graphite} system.}
 \putOptions
\end{ClosedQuestion}
}



% The Architecture of the Morrison's OrderPad and Silk

\newcommand{\qOrderPadPortability}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. The decision whether use a Native application or HTML5 for the implementation of the client in the Pad was taken because
	
    \optionA{HTML5 provides better portability qualities.}
    \optionB{Native applications provide better modifiability qualities.}
    \optionC{HTML5 provides better usability qualities.}
    \optionD{Native applications provide better support for working offline.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qSilk}{
\begin{ClosedQuestion}
	In the Amazon Silk browser  
	
    \optionA{A request for a web page corresponds to a peer-to-peer interaction between all the web components containing the resources.}
    \optionB{Web pages are explicitly cached on the browser to optimize accesses.}
    \optionC{A request for a web page corresponds to requesting a service from the amazon cloud.}
    \optionD{It is possible to customize the number of threads that run in the mobile device.}
 \putOptions
\end{ClosedQuestion}
}


\newcommand{\qOrderPadIterative}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. In the description of the system can be read:
	
	\begin{quote}
		The pilot version included some architectural short-cuts that would not work with the full complement of stores. One of these was using a file-transfer to send data to the mainframe rather than MQ, which wouldn't perform well once many stores were active.
	\end{quote}
	
	This approach means that
	
    \optionA{Performance was traded for easy of development to reduce the overall development costs.}
    \optionB{An iterative development was followed, which allowed more time to develop a connector with good performance in the latter stages of the project.}
    \optionC{Performance was traded for the availability quality.}
    \optionD{An incremental development was followed, which allowed to have the system in production without being necessary to export all the information to the mainframe.}
 \putOptions
\end{ClosedQuestion}
}



% Microservices

\newcommand{\qMicroservicesOne}{
\begin{ClosedQuestion}
	Consider the architectural solutions for microservices architectures that use the event sourcing technique. This technique has the following advantage 
			
    \optionA{Simplifies the evolution of the event schema.}
    \optionB{Simplifies the query operations in  the event store.}
    \optionC{Allows the querying of a past state.}
    \optionD{Provides a programming model developers are familiar with.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesTwo}{
\begin{ClosedQuestion}
	Suppose that an architect needs to decide whether to follow a modular monolith architecture or a microservices architecture for a new large system. The system to be developed has a complex logic and high volume of requests. 
			
    \optionA{She should decide to use a microservices architecture to improve the scalability of the system.}
    \optionB{She should decide to use a modular monolith architecture to reduce the cost of development, because developers will not need to define intermediate states for the transactional execution of the business logic.}
    \optionC{She should try to split the system in parts in order to isolate the complex business logic and use the two architectural approaches accordingly.}
    \optionD{She should give up because it is not possible to have the two approaches in a singe architecture.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesThree}{
\begin{ClosedQuestion}
	Consider the architectural solutions for microservices architectures that use the Command Query Responsibility Segregation (CQRS) technique in the context of Event Sourcing. This technique has the following disadvantage 
			
    \optionA{Does not allow optimizations according to the type of query.}
    \optionB{Does not support independent scalability according to the type of operation.}
    \optionC{Reads may not be consistent with the most recent write.}
    \optionD{Querying the event sourcing becomes more complex.}
 \putOptions
\end{ClosedQuestion}
}




% Third Mini-test

% Module styles

\newcommand{\qModuleStylesOne}{
  \begin{ClosedQuestion}
	  Suppose that in the development of an enterprise application (which needs to access a
	  database) it was decided to use the FenixFramework library to simplify the development
	  of the data access code. Which architectural style is the most adequate to represent this
	  decision?
	  
	  \optionA{The Aspects style.}
	  \optionB{The Generalisation style.}
	  \optionC{The Decomposition style.}
	  \optionD{The Shared-data style.}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qUsesOne}{
\begin{ClosedQuestion}
  Which
  architectural style is 
  adequate for planning incremental
  releases?

  \optionA{The Decomposition style.}
  \optionB{The Generalisation style.}
  \optionC{The Uses style.}
  \optionD{The Aspects style.}
  \putOptions
\end{ClosedQuestion}
}

\newcommand{\qLayeredAspectsDataModelOne}{
\begin{ClosedQuestion}
  In a layered architecture composed by four layers, where the topmost
  layer is the layer number 1 and the bottommost layer is the layer
  number 4, which of the layers is more modifiable?

    \optionA{Layer 1.}
    \optionB{Layer 4.}
    \optionC{In a layered architecture all layers are equally modifiable.}
    \optionD{Modifiability is not made easier by a layered architecture.}
  \putOptions
\end{ClosedQuestion}
}


% Adventure Builder Module Viewtype

\newcommand{\qAdventureBuilderModuleOne}{
\begin{ClosedQuestion}
	Consider the following modifiability scenario for the Adventure Builder system 
	
	\begin{quote}
		A new business partner (airline, lodging, or activity provider) that uses its own web services interface is added to the system in no more than 10 person-days of effort for the implementation. The business goal is easy integration with new business partners.
	\end{quote}
	
	and the following architectural view
	
	\begin{center}
		\includegraphics[width=9.5cm]{AdventureBuilderModule}
	\end{center}
	
    \optionA{The view does not address the scenario}
    \optionB{The view addresses the scenario because it separates the \texttt{Consumer Website} module from the \texttt{OpcApp} module.}
    \optionC{The view addresses the scenario because it separates the modules that represent the interfaces a new business partner has to implement.}
    \optionD{The view addresses the scenario because the \texttt{Consumer Website} module does not use the interfaces a new business partner has to implement.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderModuleTwo}{
\begin{ClosedQuestion}
	Consider the following availability scenario for the Adventure Builder system 
	
	\begin{quote}
		The Consumer Web site is available to the user 24x7. If an instance of OPC application fails, the fault is detected and the system administrator is notified in 30 seconds; the system continues taking order requests; another OPC instance is created; and data remains in consistent state.
	\end{quote}
	
	and the following architectural view
	
	\begin{center}
		\includegraphics[width=9.5cm]{AdventureBuilderModule}
	\end{center}
	
    \optionA{The view does not address the scenario}
    \optionB{The view addresses the scenario because the uses relation between the \texttt{Consumer Website} module and the \texttt{OpcApp} module has the require properties.}
    \optionC{The view addresses the scenario because it separates the modules that represent the interfaces a new business partner has to implement.}
    \optionD{The view addresses the scenario because the \texttt{Consumer Website} module uses the \texttt{gwt} and \texttt{waf} modules.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderModuleThree}{
\begin{ClosedQuestion}
	Consider the following performance/scalability scenario for the Adventure Builder system 
	
	\begin{quote}
		Up to 500 users click to see the catalog of adventure packages following a random distribution over 1 minute; the system is under normal operating conditions; the maximal latency to serve the first page of content is under 5 seconds; average latency for same is less than 2 seconds. If required, the system should easily support an increase in the number of simultaneous requests while maintaining the same latency per request.
	\end{quote}
	
	and the following architectural view
	
	\begin{center}
		\includegraphics[width=9.5cm]{AdventureBuilderModule}
	\end{center}
	
    \optionA{The view does not address the scenario.}
    \optionB{The view addresses the scenario because it separates the \texttt{Consumer Website} module from the \texttt{OpcApp} module to allow the execution of the \texttt{Consumer Website} module in a component that can have multiple copies of computation.}
    \optionC{The view addresses the scenario because it separates the modules that represent the interfaces a new business partner has to implement.}
    \optionD{The view addresses the scenario because the \texttt{Consumer Website} module uses the \texttt{gwt} and \texttt{waf} modules.}
 \putOptions
\end{ClosedQuestion}
}



% Component-and-connector viewtype

\newcommand{\qInterfaceDelegation}{
\begin{ClosedQuestion}
	Consider the concept of interface delegation 
		
    \optionA{It corresponds to a particular case of a specialization in a generalization view.}
    \optionB{It represents a relation between a connector's role and a port of one of its internal components.}
    \optionC{It represents a relation between a component's port and a port of one of its internal components.}
    \optionD{It represents a relation between a component's port and a connector's role.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qConnectorAttach}{
\begin{ClosedQuestion}
	A connector may be attached to components of different types because
		
    \optionA{The type of a connector does not depend on the type of its roles.}
    \optionB{Components of different types may have ports of the same type.}
    \optionC{The attachment is a runtime relation which dynamically manages type compliance.}
    \optionD{The attachment between components and connectors only depends on their ports and roles types.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qComponentViewType}{
\begin{ClosedQuestion}
	The quality(ies) that is(are) more relevant to views of the component-and-connector viewtype is(are):
		
    \optionA{Modifiability.}
    \optionB{Availability and Performance.}
    \optionC{Testability and Modifiability.}
    \optionD{Maintainability and Availability.}
 \putOptions
\end{ClosedQuestion}
}


% Component-and-connector styles

\newcommand{\qPipeFilterComposition}{
\begin{ClosedQuestion}
	The Pipe-and-Filter style allows composition of filters 

    \optionA{But when the filters are executed sequentially the composition power is reduced.}
    \optionB{Which improves modifiability, because filters are decoupled through pipes.}
    \optionC{But the size of buffers may reduce the composition power.}
    \optionD{And filters do not have to agree on the data formats.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qPublishSubscribe}{
\begin{ClosedQuestion}
	In the Publish-Subscribe architectural style 
	
    \optionA{A component can subscribe to events.}
    \optionB{All the published events are received by their subscribing components.}
    \optionC{The events should be received by the same order they are sent.}
    \optionD{The set of events types are predefined at initialization time.}
 \putOptions
\end{ClosedQuestion}
}


\newcommand{\qPeerToPeerSpace}{
\begin{ClosedQuestion}
	The Peer-to-Peer architectural style provides high scalability and availability. In the context of a file sharing system  
	
    \optionA{The file transfer has to follow the same path of nodes used to identify where the file was located.}
    \optionB{The peer initiating the request for a file needs to know where the file is located.}
    \optionC{If a peer providing a file crashes the file will not be downloaded.}
    \optionD{The price for high scalability and availability is the need to have several replicas of the files to be shared.}
 \putOptions
\end{ClosedQuestion}
}


% Adventure Builder Component-and-Connector Viewtype

\newcommand{\qAdventureBuilderComponentAndConnectorOne}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=9.5cm]{AdventureBuilderComponentAndConnector}
	\end{center}
	
	In this view the following architectural styles are used
	
		
    \optionA{Service-oriented architecture, and Client-server.}
    \optionB{Service-oriented architecture, and Shared-data.}
    \optionC{Service-oriented architecture, Shared-data, and Client-server.}
    \optionD{Service-oriented architecture, Shared-data, Client-server and Peer-to-peer.}
 \putOptions 
\end{ClosedQuestion}
}


\newcommand{\qAdventureBuilderComponentAndConnectorSecond}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=9.5cm]{AdventureBuilderComponentAndConnector}
	\end{center}
	
	In this view it is possible to reason that
	
    \optionA{If the OPC crashes the Consumer Website can continue to provide service in degraded mode.}
    \optionB{If the OPC crashes the Consumer Website can continue to provide service in normal mode.}
    \optionC{If the Adventure Catalog BD crashes the Consumer Website can continue to present the Adventure Builder offers.}
    \optionD{If a Bank component is not available the OPC cannot continue to provide service.}
 \putOptions 
\end{ClosedQuestion}
}



\newcommand{\qAdventureBuilderComponentAndConnectorThird}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=9.5cm]{AdventureBuilderComponentAndConnector}
	\end{center}
	
	This view \textbf{does not} apply the architectural style
	
		
    \optionA{Client-server.}
    \optionB{Publish-subscribe.}
    \optionC{Shared-data.}
    \optionD{Peer-to-peer.}
 \putOptions 
\end{ClosedQuestion}
}



% Second Mini-test


% Availability

\newcommand{\qAvailabilityVotingFirst}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to detect faults of type
    \emph{response} in your system, which tactic is more adequate?

    \optionA{Ping/Echo.}
    \optionB{Retry.}
    \optionC{Voting.}
    \optionD{Passive Redundancy.}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qAvailabilityVotingSecond}{
  \begin{ClosedQuestion}
	  The availability quality can be supported by a voting tactic in order to identify faults of

      \optionA{Programming, if the components execute modules developed by different teams.}
      \optionB{Hardware, if there is hardware redundancy.}
      \optionC{Operating Systems, if redundant components execute on top of different operating systems..}
      \optionD{All the previous options.} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qVoting}{
\begin{ClosedQuestion}
	A voting tactic can be used to

    \optionA{Prevent a fault in hardware.}
    \optionB{Prevent a fault in software.}
    \optionC{Prevent a fault in a process.}
    \optionD{Detect a fault.}
 \putOptions
\end{ClosedQuestion}
}



% Modifiability

%4
\newcommand{\qModifiabilityOne}{
\begin{ClosedQuestion}
	The modifiability tactic Use an Intermediary between two modules
		
    \optionA{Has as main goal the reduction of the modules' size.}
    \optionB{Results in the creation of a third module that makes the original modules independent.}
    \optionC{Increases the cohesion between the two modules.}
    \optionD{May conflict with the Reduce Overhead performance tactic.}
 \putOptions 
\end{ClosedQuestion}
}

%5
\newcommand{\qModifiabilityTwo}{
\begin{ClosedQuestion}
	Consider the following scenario: \emph{A system administrator adds more copies of computation of the system, each one using a different database, and is able to do it in less than 10 minutes.}
		
    \optionA{This is a performance scenario and the measure of the response is 10 minutes latency.}
    \optionB{This is a modifiability scenario which has a defer binding tactic.}
    \optionC{This is not a modifiability scenario because the source of the stimulus cannot be a system administrator.}
    \optionD{This is a modifiability scenario and its environment design time.}
 \putOptions 
\end{ClosedQuestion}
}

%6
\newcommand{\qModifiabilityThree}{
\begin{ClosedQuestion}
	Consider the modifiability quality and the cost of change.
		
    \optionA{A low cost of change may imply a high cost of development.}
    \optionB{A low cost of change implies a low cost of development, because changing the code is part of development.}
    \optionC{There is no relation between the cost of change and the cost of development.}
    \optionD{The cost of change is higher if it occurs at runtime.}
 \putOptions 
\end{ClosedQuestion}
}




% Designing-an-Architecture

\newcommand{\qFenixADD}{
\begin{ClosedQuestion}
	When applying Attribute-Driven Design (ADD) to the FenixEdu system the creation of a view where there are redundant web servers, load balancers and database servers 

    \optionA{Results from a utility tree for performance.}
    \optionB{Results from a single availability scenario.}
    \optionC{Results from the application of a single ADD iteration.}
    \optionD{Results from the application of several ADD iterations.}
 \putOptions
\end{ClosedQuestion}
}


\newcommand{\qLowArchitecturalImpact}{
\begin{ClosedQuestion}
	Consider an architecturally significant requirement (ASR) that has a low impact on the architecture but a high business value

    \optionA{This ASR can easily be supported by the architecture because it has little effect in the architecture.}
    \optionB{This ASR requires a specific architectural design because it profoundly affects the architecture.}
    \optionC{The cost of meeting the ASR after development starts is too high.}
    \optionD{Any ASR that has a high business value cannot have a low architecture impact because it needs to be supported by the architecture.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qIterativeDesign}{
\begin{ClosedQuestion}
	Designing an architecture

    \optionA{Is driven by functional requirements.}
    \optionB{Is done in a single step, after all the tactics were identified.}
    \optionC{Is a top-down process where a initial decomposition is chosen and it is successively decomposed without changing the initial decisions.}
    \optionD{Is an iterative process where architectural designs are proposed as hypothesis and tested.}
 \putOptions
\end{ClosedQuestion}
}




% Module Viewtype

\newcommand{\qModuleViewtypeOne}{
\begin{ClosedQuestion}
	Consider the Decomposition architectural style of the Module viewtype
		
    \optionA{Its main goal is to establish the reusability qualities of the architecture.}
    \optionB{Project managers are not interested in views that use this style because it lacks the necessary level of detail.}
    \optionC{Views of this type are mostly useful to guide the testing of the system.}
    \optionD{There should be at least one view of the system using this architectural style.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qDecomposition}{
\begin{ClosedQuestion}
	The Decomposition architectural style of the Module viewtype 
	
    \optionA{Is applied only once at the beginning of the architectural design process.}
    \optionB{Is applied at the begin of the architectural design process but may be necessary to redo it later.}
    \optionC{Is mostly driven by the security attribute quality.}
    \optionD{Follows a bottom-up decomposition process of the system.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qArchitecturalViews}{
\begin{ClosedQuestion}
  A software system is usually described using different architectural views

  \optionA{Each view contains a single architectural style.}
  \optionB{Views need to contain more than one architectural style.}
  \optionC{A view may not contain any architectural style.}
  \optionD{None of the above.}
  \putOptions
  \end{ClosedQuestion}
}



% Graphite 

\newcommand{\qGraphiteComposerUIPerformance}{
  \begin{ClosedQuestion}
	  The \emph{Composer UI} component of Graphite system, described as - \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL} - to be effective needs to show to the user the changes she performs in the graph such that she has immediate feedback whenever she clicks on a option. To do so, the architecture needs to include

    \optionA{Task Model tactics.}
    \optionB{System Model tactics.}
    \optionC{performance tactics.}
    \optionD{User Model tactics.} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}


\newcommand{\qGraphiteScenarioTacticsOne}{
  \begin{ClosedQuestion}
    In the Graphite system the component \emph{carbon} provides to \emph{webapp} components an access interface to the \emph{buffers} in order to improve the quality of

    \optionA{Performance.}
    \optionB{Interoperability.}
    \optionC{Availability.}
    \optionD{Security.}

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGraphiteReliability}{
\begin{ClosedQuestion}
	In the Graphite system description can be read:
	
	\begin{quote}
		We've got 600,000 metrics that update every minute and we're assuming our storage can only keep up with 60,000 write operations per minute. This means we will have approximately 10 minutes worth of data sitting in carbon's queues at any given time. To a user this means that the graphs they request from the Graphite webapp will be missing the most recent 10 minutes of data.
	\end{quote}

    \optionA{The quality addressed is availability and transactions tactic is required to solve the problem.}
    \optionB{The quality addressed is performance and a limit event response is required to solve the problem.}
    \optionC{The quality addressed is availability and a voting design tactic is required to solve the problem.}
    \optionD{The quality addressed is performance and a maintain multiple copies of data design tactic is required to solve the problem.}
 \putOptions
\end{ClosedQuestion}
}




% First Mini-test

% The architecture elevator

\newcommand{\qElevatorCommon}{
\begin{ClosedQuestion}
	In the Architect Elevator article by Gregor Hohpe can be read:
	
	\begin{quote}
		Finding the appropriate context requires the architect to visit many floors of the organization.
	\end{quote}
	
	This sentence reflects the fact that an architecture is

    \optionA{The result of decisions that are made at the "upper floors" of the organization}
    \optionB{The sole decision of an architect}
    \optionC{A common understanding to be achieve among all the system stakeholders}
    \optionD{A set of software elements and their relations}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qElevatorInteroperability}{
\begin{ClosedQuestion}
	In the Architect Elevator article by Gregor Hohpe can be read:
	
	\begin{quote}
		Once a developer approached our architecture team with an application that had "significant scalability demands". A quick look at the architecture diagram revealed numerous components communicating via XML messages. When I pointed out that this may be the very reason for the performance concerns, I was quickly informed that this was an architecture decision and couldn't be changed. Assuming the architects are smart and well-intentioned, they may have thought about interoperability when they made this decision but may be unaware of the negative impact on run-time performance and development velocity.
	\end{quote}
	
	From this sentence we can conclude that
		
    \optionA{Interoperability is a quality that as lower priority than performance}
    \optionB{Scalability should be the quality to be achieved first by any architecture}
    \optionC{That the use of XML technology for interoperability is not a correct decision}
    \optionD{None of the above}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qElevatorDevops}{
\begin{ClosedQuestion}
	In the Architect Elevator article by Gregor Hohpe can be read:
	
	\begin{quote}
		A lot of large companies have discovered the benefits of cloud computing but see it mainly as an infrastructure topic. I feel that's misguided: being able to get compute resources more quickly and cheaply is useful, but the real business benefit lies in a fully automated tool chain that minimizes the time in which a normal code change can go into production. Not quite coincidentally, this is my favorite definition of DevOps.
	\end{quote}
	
	In the author's opinion
		
    \optionA{Time to market is the most important impact of cloud computing in an architecture}
    \optionB{Reduction of cost is the most important impact of cloud computing in an architecture}
    \optionC{Cloud computing has impact on the business but it is not an architectural aspect}
    \optionD{Using cloud computing we cannot delay some architectural decisions}
 \putOptions
\end{ClosedQuestion}
}


% Microservices

\newcommand{\qMicroservicesProject}{
\begin{ClosedQuestion}
	In the description of the Microservices Architecture by James Lewis and Martin Fowler can be read:
	
	\begin{quote}
		The microservice approach to division ..., splitting up into services organized around business capability. Such services take a broad-stack implementation of software for that business area, including user-interface, persistent storage, and any external collaborations. Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management.
	\end{quote}
	
	Considering the architecture influence cycle, which influence factor it is being considered?

    \optionA{Commercial}
    \optionB{Technical}
    \optionC{Project}
    \optionD{Professional}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesModularity}{
\begin{ClosedQuestion}
	In the description of the Microservices Architecture by James Lewis and Martin Fowler can be read:
	
	\begin{quote}
		As well as the fact that services are independently deployable and scalable, each service also provides a firm module boundary, even allowing for different services to be written in different programming languages. They can also be managed by different teams.
	\end{quote}
	
	Which is not necessarily an advantage of being independently deployable and scalable?

    \optionA{Performance}
    \optionB{Availability}
    \optionC{Modifiability}
    \optionD{Time to market}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesConsistency}{
\begin{ClosedQuestion}
	In the description of the Microservices Architecture by James Lewis and Martin Fowler can be read:
	
	\begin{quote}
		Decentralizing responsibility for data across microservices has implications for managing updates. The common approach to dealing with updates has been to use transactions to guarantee consistency when updating multiple resources. This approach is often used within monoliths.
	\end{quote}
	
	What is the impact of decentralizing responsibility for data across microservices?

    \optionA{The need to use a two-phase commit protocol}
    \optionB{The need to have a tight integration of the development teams}
    \optionC{The need to have eventual consistency and compensating operations}
    \optionD{The need to deploy all the microservices simultaneously}
 \putOptions 
\end{ClosedQuestion}
}


% Architectures for scalable web applications

\newcommand{\qScalablePartitioning}{
\begin{ClosedQuestion}
	Consider the following figure that presents an architectural view of an \emph{Image Hosting Application} which resulted from the enrichment of another architectural view by adding another \emph{Image File Storage} pair, in the figure they are distinguished by 1 and 2. 
	
	\begin{center}
		\includegraphics[width=10cm]{ScalablePartitioning}
	\end{center}
	
	Which quality results from this enrichment, that was not provided by the previous version of the architecture?
	
    \optionA{Availability of the Image Write Service, whenever one of the Image Write Service components crashes}
    \optionB{Scalability of the Image File Storage in terms of the storage capacity}
    \optionC{Availability of the Image File Storage, whenever the Image File Storage component crashes}
    \optionD{Performance of the Image Write Service}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qReadsAndWrites}{
\begin{ClosedQuestion}
	Consider the following figure that presents an architectural view of an \emph{Image Hosting Application}. 
	
	\begin{center}
		\includegraphics[width=10cm]{ScalablePartitioning}
	\end{center}
		
    \optionA{The number of Image Write Service components should be the same of the number Image Retrieval Service components}
    \optionB{The hardware where of Image Write Service components execute should have the same capabilities of the hardware where Image Retrieval Service components run}
    \optionC{Both components, the Image Write Service and the Image Retrieval Service, should be designed using an synchronous model of interactions, where a thread is associated with each request}
    \optionD{The separation of write and retrieval services allows them do scale independently}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qDataStorageAvailability}{
\begin{ClosedQuestion}
	Consider the following figure that presents an architectural view of an \emph{Image Hosting Application}. 
	
	\begin{center}
		\includegraphics[width=10cm]{ScalablePartitioning}
	\end{center}
	
	The replication between the Image File Storage \emph{n} and Image File Storage \emph{nb}
		
    \optionA{Provides the quality of availability}
    \optionB{Provides the quality of performance}
    \optionC{Provides the quality of modifiability}
    \optionD{Does not provide any additional quality}
 \putOptions 
\end{ClosedQuestion}
}



\newcommand{\qQueuesQualities}{
\begin{ClosedQuestion}
	Consider the following figure that presents a Queue where client applications write their requests to be processed by a server.
	
	\begin{center}
		\includegraphics[width=10cm]{Queues}
	\end{center}
	
	This solution \textbf{does not} provide the following quality:
	
    \optionA{Availability whenever the server running the tasks crashes, the tasks are restarted and eventually finished}
    \optionB{Performance of the tasks execution, scheduling of tasks can be optimized for the particular context of the system}
    \optionC{Performance of the services being executed by the clients, they can execute other actions while waiting for the response}
    \optionD{Simple programming model, the clients only need to concern about the business logic of the application, the remote services are transparent}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qQueuesSyncAndAsync}{
\begin{ClosedQuestion}
	Consider the following figure that presents a Queue where client applications write their requests to be processed by a server (asynchronous) and compare with another architectural design (synchronous) where a thread is associated with each request.
	
	\begin{center}
		\includegraphics[width=10cm]{Queues}
	\end{center}
		
    \optionA{The synchronous solution requires less memory than asynchronous solution}
    \optionB{The asynchronous solution can support a larger number of simultaneous requests}
    \optionC{In the synchronous solution a task can be associated, during its execution, with different execution entities, e.g. thread}
    \optionD{In the asynchronous solution a task is always associated, during its execution, with the same execution entity, e.g. thread}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qQueuesCrash}{
\begin{ClosedQuestion}
	Consider the following figure that presents a Queue where client applications write their requests to be processed by a server (asynchronous) and compare with another architectural design (synchronous) where a thread is associated with each request.
	
	\begin{center}
		\includegraphics[width=10cm]{Queues}
	\end{center}
	
	Consider a situation where the server that processes the tasks crashes
		
    \optionA{In the synchronous solution only some of the tasks that are being executed are lost and they have to be resubmitted by the client}
    \optionB{In the asynchronous solution the tasks that are being executed are lost and they have to be resubmitted by the client}
    \optionC{In the asynchronous solution it is possible to provide an implement where the tasks being executed are finished without requiring the client to resubmitted them}
    \optionD{In the synchronous solution the tasks being executed are finished without requiring the client to resubmitted them}
 \putOptions 
\end{ClosedQuestion}
}




% Performance

\newcommand{\qPerformanceSenario}{
\begin{ClosedQuestion}
	Consider the following scenario for performance
	
	\begin{quote}
		During the enrollment period the FenixEDU system should be able to completely enroll 5.000 students in less than 30 minutes.
	\end{quote}
	
    \optionA{The source of stimulus is the FenixEDU system}
    \optionB{The stimulus is periodic}
    \optionC{The environment is overloaded}
    \optionD{The measure of the response is throughput}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qPerformanceTacticsOne}{
\begin{ClosedQuestion}
	Which of the following tactics is not related with the management of resources
	
    \optionA{Introduce concurrency}
    \optionB{Limit event response}
    \optionC{Maintain multiple copies of data}
    \optionD{Schedule resources}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qPerformanceTacticsTwo}{
\begin{ClosedQuestion}
	Which of the following tactics is not related with the control of resource demand
	
    \optionA{Manage sampling rate}
    \optionB{Bound execution times}
    \optionC{Maintain multiple copies of computation}
    \optionD{Increase resource efficiency}
 \putOptions 
\end{ClosedQuestion}
}



%% =========================================================================
%% exams and tests 2016/2017
%% =========================================================================


%% Exams

% Software Architecture

\newcommand{\qSoftwareArchitectureOne}{
\begin{ClosedQuestion}
  Consider that a software development team uses an agile methodology
  such as XP (Extreme Programming), where no documentation is
  produced.  Then, the systems developed by that team

    \optionA{Typically have a software architecture that results
    from the common knowledge about the system that is shared among
    the team members}
    \optionB{Do not have a software architecture, because in agile
    methodologies there is no architectural design phase}
    \optionC{Do not have a software architecture, because the practice of
    refactoring allows changing every part of the system easily}
    \optionD{May have a software architecture, but that architecture is
    not known because it was neither designed nor documented}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qSoftwareArchitectureTwo}{
\begin{ClosedQuestion}
  The software architecture of a system

  \optionA{Is a high-level view of the system with the purpose of
  understanding what are the system's goals and features}
  \optionB{Is composed of things such as code units, runtime elements,
  hardware, and people, together with the relationships among them}
  \optionC{Is a set of guidelines that the developing team should
  follow in the development of the system}
  \optionD{Is a set of diagrams that show the runtime elements of the
  system and their relationships}
 \putOptions 
\end{ClosedQuestion}
}


% General scenarios 

\newcommand{\qRequirementsImpact}{
\begin{ClosedQuestion}
	The requirements impact on how an architecture is designed

    \optionA{However, functional requirements do not have any impact on the architecture because the systemic qualities of an architecture are non-functional}
    \optionB{The functional requirements have a large impact on the definition of views of the component-and-connector viewtype because each component executes a functionality}
    \optionC{The functional requirements have a large impact on the definition of views of the module viewtype because they are used to define the high cohesion and low coupling of modules}
    \optionD{The functional requirements can be considered as constraints on the software architecture design}
 \putOptions 
\end{ClosedQuestion}
}


\newcommand{\qConcreteScenarios}{
\begin{ClosedQuestion}
  As part of the process of creating an architecture, we talked about
  a framework for capturing some of the requirements for a system.  In
  this context, \textbf{concrete scenarios} are used for

  \optionA{Describing what are the qualities that the system should possess}
  \optionB{Describing a set of steps that a user of the system must
  perform to accomplish some task}
  \optionC{Describing a use case for the system that makes clear what
  should be the system's responses to each of the user's inputs}
  \optionD{Describing the system's features by way of different
  usage scenarios for it, in which users play the role of actors}
 \putOptions 
\end{ClosedQuestion}
}

% Availability scenario

\newcommand{\qAvailabilityScenarioOne}{
  \begin{ClosedQuestion}
	  Consider the following scenario
	  
	  \begin{quote}
		  If one of the application servers fails to respond when the system is in its normal operation state, the load balancer should redirect requests to another application server.
	  \end{quote}
	  
      \optionA{The stimulus is incorrect response}
      \optionB{The artefact is the load balancer}
      \optionC{The response is not correctly stated}
      \optionD{The quality it addresses is interoperability} 
	  
     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qAvailabilityScenarioTwo}{
  \begin{ClosedQuestion}
	  Consider the following availability scenario
	  
	  \begin{quote}
		 If one of the application servers fails to respond to a request when the system is in its normal operation state, the system should notify the operator and continue to operate normally.
	  \end{quote}
	  
      \optionA{The scenario is not correct}
      \optionB{The scenario is correct but it does not describe whether the request the servers fails to respond to succeeds or fails}
      \optionC{The scenario is correct but it is not clear what is the artefact}
      \optionD{The scenario is not completely correct because it contains two responses} 
	  
     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

% Availability tactic

\newcommand{\qAvailabilityVotingEN}{
  \begin{ClosedQuestion}
	  The availability quality can be supported by a voting tactic in order to identify faults of

      \optionA{Programming, if the components execute modules developed by different teams}
      \optionB{Hardware, if there is hardware redundancy}
      \optionC{Operating Systems, if redundant components execute on top of different operating systems}
      \optionD{All the previous options} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qAvailabilityOne}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to deal with faults of type
    \emph{omission} in your system, which tactic is more adequate?

    \optionA{Retry}
    \optionB{Active redundancy}
    \optionC{Ignore faulty behaviour}
    \optionD{Ping/Echo}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


% Performance scenario

\newcommand{\qMWResourceLoaderTacticEEEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of the \emph{MediaWiki} system description:
	  \newline
	  
	  \emph{To optimize the delivery of JavaScript and CSS assets, the ResourceLoader module was developed to optimize delivery of JS and CSS. Started in 2009, it was completed in 2011 and has been a core feature of MediaWiki since version 1.17. ResourceLoader works by loading JS and CSS assets on demand, thus reducing loading and parsing time when features are unused, for example by older browsers. It also minifies the code, groups resources to save requests, and can embed images as data URIs}
	  \newline
	  
	  The \emph{ResourceLoader} supports a quality
    
    \optionA{Performance}
    \optionB{Usability}
    \optionC{Availability}
    \optionD{Modifiability} 

     \putOptions
   \end{ClosedQuestion}
}

\newcommand{\qInfinispanThree}{
\begin{ClosedQuestion}
	Consider the following description of the \emph{Infinispan} system:
	
	\begin{quote}
		Before putting data on the network, application objects need to be serialized into bytes so that they can be pushed across a network, into the grid, and then again between peers. The bytes then need to be de-serialized back into application objects, when read by the application. In most common configurations, about 20\% of the time spent in processing a request is spent in serialization and de-serialization.
	\end{quote}
	
	The above description can motivate a scenario for
		
    \optionA{Performance}
    \optionB{Availability}
    \optionC{Modifiability}
    \optionD{Reliability}
 \putOptions 
\end{ClosedQuestion}
}


% Performance tactic

\newcommand{\qPerfomanceTacticOne}{
  \begin{ClosedQuestion}
   In which performance tactic it may occur that not all the inputs are processed

    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Reduce overhead}
    \optionD{Bound execution times}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


\newcommand{\qPerfomanceTacticTwo}{
  \begin{ClosedQuestion}
   In which performance tactic it can occur that the inputs are not completely processed, even though they always start being processed

    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Reduce overhead}
    \optionD{Bound execution times}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


% Modifiablity scenario

\newcommand{\qScalabilityINGLES}{
  \begin{ClosedQuestion}
    Several of the cases studied in this course had scalability
    requirements.  That means that those systems should be designed in
    such a way that they

    \optionA{Have high throughput}
    \optionB{Have low latency}
    \optionC{Allow many simultaneous users}
    \optionD{May be easily changed to increase their performance}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qModifiabilityScenario}{
  \begin{ClosedQuestion}
    Consider the following modifiability scenario
	
	\begin{quote}
		The effort necessary to successfully port the system to execute in a new browser should not be higher than 5 person/month.
	\end{quote}

    \optionA{The stimulus is to port the system to a new browser}
    \optionB{The environment is build time}
    \optionC{The response is 5 person/month}
    \optionD{To implement the above scenario it is necessary to apply a runtime defer binding tactic}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


% Modifiablity tactic

\newcommand{\qLayersTactics}{
  \begin{ClosedQuestion}
    The main tactic associated with the layered architectural style is:

    \optionA{Split module}
    \optionB{Encapsulate}
    \optionC{Restrict dependencies}
    \optionD{Defer binding}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qAspectsTactics}{
  \begin{ClosedQuestion}
    The main tactic associated with the aspects architectural style is:

    \optionA{Split module}
    \optionB{Increase semantic coherence}
    \optionC{Restrict dependencies}
    \optionD{Defer binding}

    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}

% Hadhoop - Scenario

\newcommand{\qHadoopDisponibilidadeDadosINGLES}{
  \begin{ClosedQuestion}
    One of the key requirements for the HDFS system is that the data
    stored in the system remains available, even in the presence of
    various types of failures (non simultaneous) in the hardware in
    which the system executes.  To show that the system satisfies this
    requirement

    \optionA{We must use various different views, both of the
      component-and-connector and the allocation viewtypes}
    \optionB{We just have to show, through component-and-connector
      views, that the system maintains replicas of the data in
      different components}
    \optionC{We just have to show, through Deployment views,
      that the \emph{DataNode} component executes in more than one
      machine of the cluster}
    \optionD{We just have to show, through Decomposition views, that
      there are modules responsible for the replication of file blocks}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qHadoopStakeholdersEurosINGLES}{
  \begin{ClosedQuestion}
    In the HDFS system, in the stakeholders perspective, the use of low cost servers to build the clusters is:

    \optionA{Essential to ensure the system scalability}
    \optionB{Essential to reduce costs whenever there is a fault in a hardware element}
    \optionC{Essential to ensure the system portability}
    \optionD{Essential to facilitate the integration with legacy systems}

    \putOptions
% Resposta: B
\end{ClosedQuestion}
}


% Hadhoop - Tactic

\newcommand{\qHadoopTacticasRecuperacaoFaltasINGLES}{
  \begin{ClosedQuestion}
    In the HDFS system the fault recovery tactics are:

    \optionA{Active replication and passive replication}
    \optionB{Active replication, passive replication, and spare}
    \optionC{Passive replication and spare}
    \optionD{Quorum, active replication, and passive replication}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qHadoopHeartbeatINGLES}{
  \begin{ClosedQuestion}
    In HDFS, during normal operation DataNodes use the heartbeat tactic

    \optionA{Because this tactic simplifies the addition and removal of DataNodes}
    \optionB{But they could have used the ping tactic instead without adding any overhead to the NameNode}
    \optionC{But the exceptions tactic could have been used as well}
    \optionD{To inform other DataNodes about their availability}
    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

% Architectural Views

\newcommand{\qSecondEEEN}{
\begin{ClosedQuestion}
  The documentation of the software architecture for a system is often
  composed of several views, because

  \optionA{Different stakeholders are interested in different views of the system}
  \optionB{A single view would be too simplistic}
  \optionC{The views describe different aspects of the system}
  \optionD{All of the above}
  \putOptions
  \end{ClosedQuestion}
}

\newcommand{\qArchitecturalViews}{
\begin{ClosedQuestion}
  A software system is usually described using different architectural views

  \optionA{Each view contains a single architectural style}
  \optionB{Views need to contain more than one architectural style}
  \optionC{A view may not contain any architectural style}
  \optionD{None of the above}
  \putOptions
  \end{ClosedQuestion}
}

% Module viewtype

\newcommand{\qModuleViewType}{
\begin{ClosedQuestion}
	The quality that is more relevant to views of the module viewtype is:
		
    \optionA{Modifiability}
    \optionB{Usability}
    \optionC{Security}
    \optionD{Availability}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qFunctionalModule}{
\begin{ClosedQuestion}
	When designing an architecture requirements can be split into functional, quality attributes, and constraints. Functional requirements have impact on:
		
    \optionA{A module view}
    \optionB{A component-and-connector view}
    \optionC{An allocation view}
    \optionD{They are not represented by a view}
 \putOptions
\end{ClosedQuestion}
}

% Module architectural style one

\newcommand{\qMemcachedModulesINGLES}{
  \begin{ClosedQuestion}
    Consider the following description of \emph{Memcached}, which is
    adapted from its Wiki:
    \begin{quote}
      Memcached is an in-memory key-value store for small chunks of
      arbitrary data from results of database calls, API calls, or
      page rendering.  It is made up of:
      \begin{itemize}
      \item Client software, which is given a list of available memcached servers.
      \item A client-based hashing algorithm, which chooses a server
        based on the "key" input.
      \item Server software, which stores your values with their keys
        into an internal hash table.
      \item Server algorithms, which determine when to throw out old
        data (if out of memory), or reuse memory.
      \end{itemize}
    \end{quote}
    Suppose that you want to present an architectural view for
    \emph{Memcached} that represents the above information.  Which
    view is more adequate?

    \optionA{A view of the Data Model style}
    \optionB{A view of the Layers style}
    \optionC{A view of the Decomposition style}
    \optionD{A view of the Uses style}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qSubcontractorsINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are developing a software architecture for a new
    large scale system and that you intend to resort extensively to
    third party subcontractors for the development of various parts of
    the system.  Which architectural styles are most useful to plan
    the development of the system in this case?

    \optionA{The Decomposition and the Work Assignment styles}
    \optionB{The Decomposition and the Layers styles}
    \optionC{The Decomposition and the Uses styles}
    \optionD{The Decomposition and the SOA styles}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

% Module architectural style two

\newcommand{\qAspectsINGLES}{
  \begin{ClosedQuestion}
    Using the Aspects architectural style promotes the modifiability
    of a system because
    
    \optionA{It imposes restrictions on which uses relationships may
      exist between the system's modules}
    \optionB{It makes it easier to create generalization relationships
      between the system's modules}
    \optionC{It separates in new modules responsibilities that were
      spread over various of the system's modules}
    \optionD{It allows the decomposition of each of the system's
      modules into finer grained modules}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qUsesStyle}{
\begin{ClosedQuestion}
  To achieve a faster time-to-market, software companies are
  increasingly using a strategy of incremental releases of their
  software, where each new release has a set of new features.  Which
  architectural style is better to analyse whether the system's
  software architecture is adequate for the planned incremental
  releases?
 
  \optionA{The Decomposition style}
  \optionB{The Deployment style}
  \optionC{The Uses style}
  \optionD{The Work-assignment style}
 \putOptions 
\end{ClosedQuestion}
}


% Module architectural style three

\newcommand{\qLayeredAspectsDataModelTwo}{
\begin{ClosedQuestion}
	 Suppose that you are implementing a module in a system that has a two layered architecture.
	 Knowing that your module belongs to the upper layer (assuming the usual notation
	 for the layer style), this means that you
	 
	 \optionA{Can use the operations defined in any of the system's modules}
	 \optionB{Can use the operations defined in the lower layer, but not the ones defined in
	 	the upper layer}
	 \optionC{Can use the operations defined in the upper layer, but not the ones defined in
	 	the lower layer}
	 \optionD{Should use some operation defined in the lower layer}
  \putOptions
\end{ClosedQuestion}
}

\newcommand{\qnginxModuleTypesINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes nginx:
    \begin{quote}
      nginx's modular architecture generally allows developers to
      extend the set of web server features without modifying the
      nginx core.  nginx modules come in slightly different
      incarnations, namely core modules, event modules, phase
      handlers, protocols, variable handlers, filters, upstreams and
      load balancers.  [...]  Event modules provide a particular
      OS-dependent event notification mechanism like kqueue or epoll.
      Protocol modules allow nginx to communicate through HTTPS,
      TLS/SSL, SMTP, POP3 and IMAP.
    \end{quote}
    Which architectural style is more adequate to represent the
    information presented above?

    \optionA{The Generalization style}
    \optionB{The Uses style}
    \optionC{The Layers style}
    \optionD{The Aspects style}
    \putOptions
    % Resposta: A
  \end{ClosedQuestion}
}


% Adventure Builder One

\newcommand{\qAdventureBuilderThree}{
\begin{ClosedQuestion}
  	Consider the following architectural view of the Adventure Builder system, designed around the Order Processing Center
	
	\begin{center}
		\includegraphics[width=12cm]{../AdventureBuilderCandC}
	\end{center}
	
	The views \textbf{does not} use the architectural style

   	\optionA{Per-to-peer}
	\optionB{Shared-data}
    \optionC{Communicating processes}
    \optionD{Publish-subscribe}
		
    \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderFour}{
\begin{ClosedQuestion}
  	Consider the following architectural view of the Adventure Builder system, designed around the Order Processing Center
	
	\begin{center}
		\includegraphics[width=12cm]{../AdventureBuilderCandC}
	\end{center}
	
	The views \textbf{does not} allow the reason about the quality of

   	\optionA{Interoperability}
	\optionB{Modifiability}
    \optionC{Performance}
    \optionD{Security}
		
    \putOptions
\end{ClosedQuestion}
}

% Adventure Builder Two

\newcommand{\qAdventureBuilderFive}{
\begin{ClosedQuestion}
  	Consider the following requirement for availability of the Adventure Builder system
	
	\begin{quote}
		The Consumer Web site sent a purchase order request to the order processing center (OPC). The OPC processed that request but didn't reply to Consumer Web site within five seconds, so the Consumer Web site resends the request to the OPC.
	\end{quote}
	
	If we represent this requirement as a scenario

   	\optionA{The stimulus is an omission and the tactic is retry}
	\optionB{The stimulus is a crash and the tactic is retry}
    \optionC{The stimulus is an incorrect timing and the tactic is ignore faulty behaviour}
    \optionD{The stimulus is incorrect response and the tactic is voting}
		
    \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderSix}{
\begin{ClosedQuestion}
  	Consider the following requirement for availability of the Adventure Builder system
	
	\begin{quote}
		The Consumer Web site is available to the user 24x7. If an instance of OPC application fails, the fault is detected and the system administrator is notified in 30 seconds; the system continues taking order requests; another OPC instance is automatically created; and data remains in consistent state.
	\end{quote}
	
	In order to support this quality it is necessary to 

   	\optionA{Use a passive redundancy tactic in the OPC (Order Processing Center)}
	\optionB{Use a passive redundancy tactic in the Consumer Web site}
    \optionC{Use an active redundancy tactic in the OPC (Order Processing Center) }
    \optionD{Use an active redundancy tactic in the Consumer Web site}
		
    \putOptions
\end{ClosedQuestion}
}


% Catalog of DVDs

\newcommand{\qDVDCatalogMeta}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVD Catalog application. The architect knows about a new requirement 
	
	\begin{quote}
		The application should support other kinds of catalogs (CDs, games, books, ...). 
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The layered view to support a new specific layer for the customization of the catalog}
    \optionB{The layered view to accommodate a new layer for each kind of catalog, which other layers may use}
    \optionC{The data model view in order to define entities for each kind of catalog}
    \optionD{The data model view in order to define generic entities that can be customized for different kinds of catalogs}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qDVDCatalogMobile}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To support iPhone/iPad/Android version with sync, which allows offline use of the application in the mobile device and data synchronization to occur when a connection is available
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The decomposition view to include a module for the synchronization responsibilities}
    \optionB{The uses view to represent how the mobile device uses the Catalog application}
    \optionC{The layered view to include a layer for each type of device}
    \optionD{The domain layer of the layered style to represent the types of devices}
 \putOptions
\end{ClosedQuestion}
}


% Component-and-connector viewtypes

\newcommand{\qAvailabilityINGLES}{
  \begin{ClosedQuestion}
    Suppose that, to satisfy an availability requirement related with
    the occurrence of faults at the network infrastructure used by
    your system, you want to use the tactic named \emph{Ping/Echo}.
    How does the use of that tactic manifests in the architectural
    views of your system?

    \optionA{Only in the Deployment view}
    \optionB{Only in the Decomposition view}
    \optionC{Only in a component-and-connector view}
    \optionD{Both in a component-and-connector and the Deployment
      views}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qTiposVistaDesempenhoINGLES}{
  \begin{ClosedQuestion}
    To analyse the performance of a system

    \optionA{Only views of the component-and-connector viewtype are needed}
    \optionB{All viewtypes may be necessary}
    \optionC{Only views of the component-and-connector viewtype and allocation viewtype are needed}
    \optionD{Views of the module viewtype are not needed}
    \putOptions
% Resposta: B
 \end{ClosedQuestion}
}


% Component-and-connector style one

\newcommand{\qPeerToPeerDynamicReconfiguration}{
\begin{ClosedQuestion}
	In the description of the Gnutella system can be read:
	
	\begin{quote}
		The topology of the system changes at runtime as peer components connect and disconnect to the network.
	\end{quote}
	
    \optionA{When a peer connects to the network it establishes connections with all other peers in the network}
    \optionB{The behavior described in the sentence can be represented in a view where the dynamic reconfiguration architectural style is used}
    \optionC{When a peer receives a connection it sends all its files to the peer connecting it}
    \optionD{The behavior described in the sentence can be represented in a view where the tier architectural style is used}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qPeerToPeerSpace}{
\begin{ClosedQuestion}
	The Peer-to-Peer architectural style provides high scalability and availability. In the context of a file sharing system  
	
    \optionA{The file transfers follows the same path of nodes used to identify where the file was located}
    \optionB{The peer initiating the request for a file needs to know where the file is located}
    \optionC{If a peer providing a file crashes it is necessary to restart downloading the file from the begin}
    \optionD{The price for high scalability and availability is the need to have several replicas of the files to be shared}
 \putOptions
\end{ClosedQuestion}
}



% Component-and-connector style two

\newcommand{\qPipeFilterComposition}{
\begin{ClosedQuestion}
	The Pipe-and-Filter style allows composition of filters 
	
    \optionA{But when the filters are executed sequentially the composition power is reduced}
    \optionB{Which improves modifiability, because filters are decoupled through pipes}
    \optionC{But the size of buffers may reduce the composition power}
    \optionD{And filters do not have to agree on the data formats}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qTresTiersINGLES}{
  \begin{ClosedQuestion}
    Currently, the most popular architecture for an enterprise
    application is composed of 3 tiers.  The three tiers are

    \optionA{The presentation logic layer, domain logic layer, and
      data access layer}
    \optionB{The traditional web applications, the mashups, and the rich internet applications (RIAs)}
    \optionC{The web browser, o web server, and the data base}
    \optionD{The web services layer, the domain logic layer, and the
      data access layer}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


% Component-and-connector style three

\newcommand{\qSOAINGLES}{
  \begin{ClosedQuestion}
    In the Service Oriented Architecture style it is common to have a
    specialized component, named \emph{Enterprise Service Bus} (ESB).
    The goal of using of an ESB in a system is

    \optionA{To facilitate the interaction among heterogeneous
      components that use distinct communication protocols}
    \optionB{To promote the use of a common communication protocol for
      all the remaining components of the system}
    \optionC{To increase the performance of the interaction between
      the components of the system}
    \optionD{To create a strong coupling between the various services
      provided by the organization}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qSOAInteroperability}{
\begin{ClosedQuestion}
	The Service-Oriented Architecture style improves interoperability because
	
    \optionA{It enforces the use of a single implementation language among all applications}
    \optionB{The orchestration is in charge of improving the transparent location of service providers}
    \optionC{The enterprise service bus coordinates the execution of several services}
    \optionD{It decouples applications developed for different organizations}
 \putOptions
\end{ClosedQuestion}
}

% Component-and-connector style four

\newcommand{\qWhiteBoxTestingINGLES}{
  \begin{ClosedQuestion}
    Consider the following excerpt from the Wikipedia page on
    \emph{white-box testing}:
    \begin{quote}
      White-box testing is a method of testing software that tests
      internal structures or workings of an application, as opposed to
      its functionality. In white-box testing an internal perspective
      of the system (including the module's code), as well as
      programming skills, are required and used to design test
      cases. The tester chooses inputs to exercise paths through the
      code and determine the appropriate outputs.
    \end{quote}
  
    Assuming that you belong to the team testing a complex system and
    that you are responsible for performing white box tests on the
    system, which of the following architectural views of the system
    would be most useful to you?

    \optionA{Work Assignment views}
    \optionB{Generalization views}
    \optionC{Deployment views}
    \optionD{Implementation views}
    \putOptions

  \end{ClosedQuestion}
}

\newcommand{\qInstallView}{
\begin{ClosedQuestion}
  Consider a system that will require a significative configuration effort during deployment, because it provides several variations of the same functionalities and it is necessary to choose which functionalities better fit in each case. The most helpful architectural view for this situation is
 
  \optionA{Work assignment view}
  \optionB{Install view}
  \optionC{Implementation view}
  \optionD{Deployment view}
 \putOptions
\end{ClosedQuestion}
}

% Component-and-connector style five

\newcommand{\qArqChrome}{
\begin{ClosedQuestion}
	The Chromium is a web browser that introduced an innovative architecture. In the Chromium description we can read:
 
  \begin{quote}
    We use separate processes for browser tabs to protect the overall
    application from bugs and glitches in the rendering engine.  We
    also restrict access from each rendering engine process to others
    and to the rest of the system.  In some ways, this brings to web
    browsing the benefits that memory protection and access control
    brought to operating systems.

    We refer to the main process that runs the UI and manages tab and
    plugin processes as the "browser process" or "browser."  Likewise,
    the tab-specific processes are called "render processes" or
    "renderers."  The renderers use the WebKit open-source layout
    engine for interpreting and laying out HTML.
  \end{quote}
  
  Which architectural style should we use to represent this aspect of Chromium?

    \optionA{Communicating Processes}
    \optionB{Client-Server}
    \optionC{Peer-to-Peer}
    \optionD{Uses}
  \putOptions
\end{ClosedQuestion}
}

\newcommand{\qChromeMultiPlatform}{
\begin{ClosedQuestion}
	The Chromium is a web browser that introduced an innovative architecture. In the Chromium description we can read:

  \begin{quote}
    Chromium is a large and complex cross-platform product.  We try to
    share as much code as possible between platforms, while
    implementing the UI and OS integration in the most appropriate way
    for each.  While this gives a better user experience, it adds
    extra complexity to the code.  This document describes the
    recommended practices for keeping such cross-platform code clean.

    We use a variety of different file naming suffixes to indicate
    when a file should be used:
    \begin{itemize}
    \item Windows files use the \texttt{\_win} suffix.
    \item Cocoa (Mac UI) files use the \texttt{\_cocoa} suffix, and lower-level Mac files use the \texttt{\_mac} suffix.
    \item Linux files use \texttt{\_linux} for lower-level files, \texttt{\_gtk} for GTK-specific files, and \texttt{\_x} for X Windows (with no GTK) specific files.
    \item Posix files shared between Mac and Linux use the \texttt{\_posix} suffix.
    \item Files for Chrome's ``Views'' UI (on Windows and experimental GTK) layout system use the \texttt{\_views} suffix.
   \end{itemize}

    The separate front-ends of the browser are contained in their own directories:
    \begin{itemize}
    \item Windows Views (and the experimental GTK-views): \\
      \texttt{chrome/browser/ui/views}
    \item Linux GTK: \texttt{chrome/browser/gtk}
    \item Mac: \texttt{chrome/browser/cocoa}
    \end{itemize}
  \end{quote}
  
  Which architectural style should we use to represent this aspect of Chromium?

    \optionA{Implementation}
    \optionB{Work assignment}
    \optionC{Decomposition}
    \optionD{None, because this description does not describe any architectural aspect of the system}
  \putOptions
\end{ClosedQuestion}
}

% Twitter - Timelines of Scale - Scenario

\newcommand{\qTwitterOne}{
\begin{ClosedQuestion}
	Consider the following description of the behavior of Twitter ingestion mechanisms
	
	\begin{quote}
		Write. when a tweet  comes in there's an O(n) process to write to Redis clusters, where n is the number of people following you. Painful for Lady Gaga and Barack Obama where they are doing 10s of millions of inserts across the cluster. All the Redis clusters are backing disk, the Flock cluster stores the user timeline to disk, but usually timelines are found in RAM in the Redis cluster.
	\end{quote}
	
	\optionA{The quality being addressed is performance and the tactic multiple copies of data}
	\optionB{The quality being addressed is performance and the tactic multiple copies of computation}
	\optionC{The quality being addressed is performance and the tactics multiple copies of data and multiple copies of computation}
	\optionD{The quality being addressed is availability and the tactic passive redundancy}
	
	\putOptions
\end{ClosedQuestion}
}

\newcommand{\qTwitterTwo}{
\begin{ClosedQuestion}
	Consider the following description of the behavior of Twitter
	
	\begin{quote}
		Solution is a write based fanout approach. Do a lot of processing when tweets arrive to figure out where tweets should go. This makes read time access fast and easy. Don't do any computation on reads. With all the work being performed on the write path ingest rates are slower than the read path, on the order of 4000 QPS.
	\end{quote}
	
	To describe this behavior we need to 
	
	\optionA{Write a single scenario on performance}
	\optionB{Write two scenarios on performance}
	\optionC{Write a scenario on performance and a scenario on interoperability}
	\optionD{Write a single scenario on interoperability}
	
	\putOptions
\end{ClosedQuestion}
}


% Twitter - Timelines of Scale - Tactic

\newcommand{\qTwitterThree}{
\begin{ClosedQuestion}
	Consider the following description of the behavior of Twitter
	
	\begin{quote}
		Solution is a write based fanout approach. Do a lot of processing when tweets arrive to figure out where tweets should go. This makes read time access fast and easy. Don't do any computation on reads. With all the work being performed on the write path ingest rates are slower than the read path, on the order of 4000 QPS.
	\end{quote}
	
	To describe the performance quality of this behavior, and considering that the number of reads is much higher than the number of writes, we need to have a view that includes
	
	\optionA{Tiers style}
	\optionB{Client-server style}
	\optionC{Shared-data style}
	\optionD{Pipe-and-filter style}
	
	\putOptions
\end{ClosedQuestion}
}

\newcommand{\qTwitterFour}{
\begin{ClosedQuestion}
	Consider the following description of the behavior of Twitter ingestion mechanisms
	
	\begin{quote}
		Write. when a tweet  comes in there's an O(n) process to write to Redis clusters, where n is the number of people following you. Painful for Lady Gaga and Barack Obama where they are doing 10s of millions of inserts across the cluster. All the Redis clusters are backing disk, the Flock cluster stores the user timeline to disk, but usually timelines are found in RAM in the Redis cluster.
	\end{quote}
	
	The view that represents this behavior should be of the
	
	\optionA{Module viewtype}
	\optionB{Component-and-connector viewtype}
	\optionC{Install architectural style of the allocation viewtype}
	\optionD{It is not necessary to represent this behavior because it does not describe any qualities}
	
	\putOptions
\end{ClosedQuestion}
}

% Microservices

\newcommand{\qMicroservicesOne}{
\begin{ClosedQuestion}
	Consider the Microservice architectural style. Which of the following sentences \textbf{does not} describe an advantage of microservices?
			
    \optionA{Each service can be developed and deployed independently}
    \optionB{Easier to scale development}
    \optionC{Eliminates any long-term commitment to a technology stack}
    \optionD{Testing is easier}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qMicroservicesTwo}{
\begin{ClosedQuestion}
	Consider the following definition of Microservice architectural style by Martin Fowler
	
	\begin{quote}
		The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.
	\end{quote}
	
	To represent an architecture based on Microservices 
			
    \optionA{We do not need a view of the module viewtype because it is about the runtime properties of the system}
    \optionB{We do not need a view of the allocation viewtype because deployment is automated}
    \optionC{The component-and-connector view should emphasize the performance qualities of systems following the microservices architecture}
    \optionD{It is necessary to use views of the three viewtypes}
 \putOptions 
\end{ClosedQuestion}
}

% Amazon architecture

\newcommand{\qMicroAndAmazonThree}{
\begin{ClosedQuestion}
	In the interview Werner Vogels from Amazon gives to Jim Gray, Werner Vogels says that
	
	\begin{quote}
		The stored data formats are decoupled from the format in which you communicate data items. If there is no need for sharing schemas of the actual storage layout, you can focus on making sure that the service interfaces can evolve in a way that allows you to handle variations of data formats. 
	\end{quote}
	
	Which means that in the software architecture of Amazon's systems
			
    \optionA{The shared-data architectural style is not applied because data is encapsulated inside services}
    \optionB{The sharing of data is done using a service-oriented architecture}
    \optionC{Modifiability is not a concern of their architecture}
    \optionD{The decouple of data formats does not support scalability because of the transactional properties}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qWorldWideEN}{
  \begin{ClosedQuestion}
	  In world-wide systems like Facebook or Amazon,
	  
      \optionA{All functionalities can be transactional}
      \optionB{Only a small set of functionalities are transactional}
      \optionC{It is not necessary to have transactional properties because all data is in memory}
      \optionD{Only the isolation property of transactions is supported} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

% Boundaded Contexts and transactional architecture

\newcommand{\qBoundedContextOne}{
  \begin{ClosedQuestion}
	  Consider the following representation of a system following a microservices architecture,
	  
  	\begin{center}
  		\includegraphics[width=14cm]{../MicroservicesArchitecture}
  	\end{center}
	  
	  After an invocation through the REST API
	  
      \optionA{an ACID transaction occurs in all the involved applications}
      \optionB{a two-phase commit protocol takes place between the involved applications}
      \optionC{a ACID transaction occurs in each of the involved applications, but we can not infer which transaction occurs first}
      \optionD{an ACID transaction occurs in the invoked application and ACID transactions in the other involved applications will eventually occur later} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qBoundedContextTwo}{
  \begin{ClosedQuestion}
	  Consider the following representation of a system following a microservices architecture,
	  
  	\begin{center}
  		\includegraphics[width=14cm]{../MicroservicesArchitecture}
  	\end{center}
	  
      \optionA{When an event is published to the distributed log, the order of delivery to the different subscribing applications is predefined}
      \optionB{When two events are published to the distributed log they are delivered to the different subscribing applications in the same order}
      \optionC{The distributed log guarantees that events will be delivered only once}
      \optionD{The distributed log may not deliver some of the events that are published to their subscribers} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

% Effective aggregate design

\newcommand{\qDomainDesignOne}{
  \begin{ClosedQuestion}
	  Consider the following figure
	  
  	\begin{center}
  		\includegraphics[width=7cm]{../ProductDomainModelTwo}
  	\end{center}
	  
      \optionA{The access to two different aggregate instances in the context of the same request does not hinder scalability}
      \optionB{This is the solution followed by Twitter client applications}
      \optionC{It describes the typical behavior of a microservices system}
      \optionD{To support high scalability the request of \texttt{User 1} needs to be decomposed into a request to only one of the aggregate instances and the processing in the other aggregate occurs in the background} 
	  

     \putOptions
% Resposta: 
   \end{ClosedQuestion}
}

\newcommand{\qDomainDesignTwo}{
  \begin{ClosedQuestion}
	  Consider the following data model
	  
  	\begin{center}
  		\includegraphics[width=8cm]{../ProductDomainModel}
  	\end{center}
	  
      \optionA{It allows high scalability because the data model has only four entities}
      \optionB{It allows high scalability because it is possible the implement transactions associated to each one of the aggregates}
      \optionC{It allows high scalability because the only synchronized access is to the \texttt{ProductId}, so it requires a single contention point}
      \optionD{It does not allow high scalability} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}






% Fourth Mini-test


% Component-and-connector viewtypes

% Reused with changes
\newcommand{\qComponentConnectorTwo}{
\begin{ClosedQuestion}
	The connectors on component-and-connector view
	
	\optionA{Represent the hardware infrastructure that allows components to communicate
		with each other}
	\optionB{May, on another view of the system, be represented by a set of components
		and connectors}
	\optionC{Represent the dependency relations that exist among the various components}
	\optionD{Represent the control flow during an execution of the system}
	
	\putOptions
\end{ClosedQuestion}
}

% Reused
\newcommand{\qInterfaceDelegation}{
\begin{ClosedQuestion}
	Consider the concept of interface delegation 
		
    \optionA{It corresponds to a particular case of a specialization in a generalization view}
    \optionB{It represents a relation between a connector's role and a port of one of its internal components}
    \optionC{It represents a relation between a component's port and a port of one of its internal components}
    \optionD{It represent a relation between a component's port and a connector's role}
 \putOptions
\end{ClosedQuestion}
}



% Component-and-connector styles

% Reused
\newcommand{\qPipesFilters}{
\begin{ClosedQuestion}
	Consider that you intend to develop a system where it is necessary to change the emails received by the server (for instance, to remove potential virus or URLs for phishing sites). The goal is that each email is processed by this system before it is sent to other servers or it is stored locally. Additionally, the system should be easily modified to support new kinds of transformations. Which style is more suitable to satisfy these requirements? 

    \optionA{Peer-to-Peer}
    \optionB{Pipe-and-Filter}
    \optionC{Client-Server}
    \optionD{Publish-Subscribe}
 \putOptions
\end{ClosedQuestion}
}

% Reused
\newcommand{\qCommunicationProcesses}{
\begin{ClosedQuestion}
	The Java web servers, like Tomcat, use threads to process requests. For each request they create (or reuse) a thread to process it.
	To draw a architectural view that describes this behaviour we should use 
	
    \optionA{A Module viewtype view}
    \optionB{A Allocation viewtype view}
    \optionC{A Communicating processes view}
    \optionD{A Install view}
 \putOptions
\end{ClosedQuestion}
}

% Reused
\newcommand{\qTiers}{
\begin{ClosedQuestion}
	The Tiers architectural style
	
    \optionA{Applies layers to tiers}
    \optionB{Restricts the communication between components because, for instance, a group of components should be located in the same hardware}
    \optionC{Is an extension of the Client-Server architectural style}
    \optionD{Defines tiers as components}
 \putOptions
\end{ClosedQuestion}
}

% Reused - changed
\newcommand{\qPublishSubscribe}{
\begin{ClosedQuestion}
	In the Publish-Subscribe architectural style 
	
    \optionA{A component can subscribe to events}
    \optionB{It is always guaranteed that all the published events are received by their subscribing components}
    \optionC{The events should be delivered by the same order they are sent}
    \optionD{The set of events types are predefined at initialization time}
 \putOptions
\end{ClosedQuestion}
}

% Reused
\newcommand{\qGraphiteViewsOne}{
 \begin{ClosedQuestion}
    In Graphite system  the \emph{receiver} and the \emph{writer threads} support asynchronous writing of metrics to optimize disk accesses. The interaction between these two components follow the architectural style

    \optionA{Client-server}
    \optionB{Communicating Processes}
    \optionC{Repository}
    \optionD{Pipes-and-Filters}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

% Reused
\newcommand{\qGraphiteViewsTwo}{
  \begin{ClosedQuestion}
	  A high-level component-and-connect view of Graphite system can be designed using only the architectural style(s)

    \optionA{Shared-data and Communicating-Processes}
    \optionB{Communicating-Processes}
    \optionC{Tiers}
    \optionD{Client-Server and Shared-data}

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}


% Adventure Builder

% Reused
\newcommand{\qAdventureBuilderOne}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=12cm]{AdventureBuilder-SOA}
	\end{center}
	
	In this view the following architectural styles are used
	
		
    \optionA{Service-oriented architecture, and Client-server}
    \optionB{Service-oriented architecture, and Shared-data}
    \optionC{Service-oriented architecture, Shared-data, and Peer-to-peer}
    \optionD{Service-oriented architecture, Shared-data, Peer-to-peer, and Client-server}
 \putOptions 
\end{ClosedQuestion}
}
	
% Reused
\newcommand{\qAdventureBuilderTwo}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=14cm]{AdventureBuilder-Tiers}
	\end{center}
	
	In this view the following architectural styles are used
		
    \optionA{Tiers}
    \optionB{Tiers, and Shared-data}
    \optionC{Tiers, Shared-data, and Service-oriented architecture}
    \optionD{Tiers, Shared-data, Service-oriented architecture, and Client-server}
 \putOptions 
\end{ClosedQuestion}
}




% Third Mini-test


% Architectural Views

% REUSED
\newcommand{\qUsesCalls}{
\begin{ClosedQuestion}
	A function call is not necessarily a uses relation of the Uses architectural style of the Module viewtype because
	
    \optionA{The correctness of the caller module may not depend on the correct implementation of the invoked function in the called module}
    \optionB{The invoked function may not have any input parameter}
    \optionC{The invoked function may not have any output parameter}
    \optionD{The invoked function may not have both any input parameter nor any output parameter}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qModuleComponent}{
\begin{ClosedQuestion}
	Consider the kind of relations between components and modules.
		
    \optionA{A module contains the code that executes in a single component and a component executes the code of a single module}
    \optionB{A module contains the code that can execute in several components and a component executes the code of a single module}
    \optionC{A module contains the code that executes in a single component and a component can execute the code of several modules}
    \optionD{A module contains the code that can execute in several components and a component can execute the code of several modules}
 \putOptions
\end{ClosedQuestion}
}


% Module viewtype

% REUSED
\newcommand{\qModuleViewtypeTwo}{
\begin{ClosedQuestion}
	Consider the Uses architectural style of the Module viewtype
		
    \optionA{Cycles in the uses relation between modules are a good sign, because it indicates that several modules should be tested together}
    \optionB{The project manager uses this view to get advice on the incremental development of the system}
    \optionC{The uses relation should be applied to the coarse-grained modules, because it allows to identify circular dependences}
    \optionD{There isn't any relation with the layered architectural style because the allowed-to-use relation is more generic}
 \putOptions 
\end{ClosedQuestion}
}

% REUSED
\newcommand{\qModuleViewtypeThree}{
\begin{ClosedQuestion}
	Consider the Layered architectural style of the Module viewtype
		
    \optionA{The modules inside a layer cannot use other modules in the same layer}
    \optionB{A layer cannot call the layer above}
    \optionC{Each layer defines a virtual machine because it provides a set of cohesive functionalities to the upper layer}
    \optionD{It is possible to have a circular allowed-to-use relationship between several layers}
 \putOptions 
\end{ClosedQuestion}
}

% REUSED
\newcommand{\qAspects}{
\begin{ClosedQuestion}
	An architect is decomposing a system into a set of responsibilities using a view of the Decomposition style. However, she had already to backtrack several times and try new decompositions because she always end up with some responsibility that cannot fit within a single module.
	
    \optionA{This means that in this software system it is not possible to modularize each responsibility in a cohesive module}
    \optionB{She should define finer-grained modules where she splits the unassigned responsibility}
    \optionC{She should try to use a view of the Aspects style, assign this responsibility to a single module and define where it crosscuts the other modules}
    \optionD{She should try to use a view of the Layered style and assign this responsibility to a module in the bottom layer that can be used by all the other modules}
 \putOptions
\end{ClosedQuestion}
}

% REUSED
\newcommand{\qDataModelFacebook}{
\begin{ClosedQuestion}
	In Facebook it is not possible to have the information about more that one bilion users in a single disk. Therefore, a sharding technique is applied, where the persistent information is split between several database servers, and applications are routed to the right servers for queries and updates. To describe this architecture
	
    \optionA{It is not necessary to have any view of the Data Model architectural style because Facebook information has a very simple structure}
    \optionB{It is enough to design a view of the Data Model architectural style at the conceptual level because Facebook information has a very simple structure}
    \optionC{It is enough to design a view of the Data Model architectural style at the logical level because the information will be stored in a relational database}
    \optionD{It is necessary to design a view of the Data Model architectural style at the physical level to deal with performance and consistency issues of the access to data}
 \putOptions
\end{ClosedQuestion}
}


% Adventure Builder

\newcommand{\qAdventureBuilderModuleOne}{
\begin{ClosedQuestion}
	Consider the following modifiability scenario for the Adventure Builder system 
	
	\begin{quote}
		A new business partner (airline, lodging, or activity provider) that uses its own web services interface is added to the system in no more than 10 person-days of effort for the implementation. The business goal is easy integration with new business partners.
	\end{quote}
	
	and the following architectural view
	
	\begin{center}
		\includegraphics[width=12cm]{AdventureBuilderHighLevelVIew}
	\end{center}
	
    \optionA{The view does not address the scenario}
    \optionB{The view addresses the scenario because it separates the \texttt{Consumer Website} module from the \texttt{OpcApp} module}
    \optionC{The view addresses the scenario because it separates the modules that represent the interfaces a new business partner has to implement}
    \optionD{The view addresses the scenario because the \texttt{Consumer Website} module does not use the interfaces a new business partner has to implement}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qAdventureBuilderModuleTwo}{
\begin{ClosedQuestion}
	Consider the following performance/scalability scenario for the Adventure Builder system 
	
	\begin{quote}
		Up to 500 users click to see the catalog of adventure packages following a random distribution over 1 minute; the system is under normal operating conditions; the maximal latency to serve the first page of content is under 5 seconds; average latency for same is less than 2 seconds. If required, the system should easily support an increase in the number of simultaneous requests while maintaining the same latency per request.
	\end{quote}
	
	and the following architectural view
	
	\begin{center}
		\includegraphics[width=10.5cm]{AdventureBuilderHighLevelVIew}
	\end{center}
	
    \optionA{The view does not address the scenario}
    \optionB{The view addresses the scenario because it separates the \texttt{Consumer Website} module from the \texttt{OpcApp} module to allow the execution of the \texttt{Consumer Website} module in a component that can have multiple copies of computation}
    \optionC{The view addresses the scenario because it separates the modules that represent the interfaces a new business partner has to implement}
    \optionD{The view addresses the scenario because the \texttt{Consumer Website} module uses the \texttt{gwt} and \texttt{waf} modules}
 \putOptions
\end{ClosedQuestion}
}

% Catalog of DVDs

\newcommand{\qDVDCatalogMultiPlatform}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To support multi-platform (Mac, Windows, Linux)
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The layered view to deal with the aspects of portability}
    \optionB{The uses view to show the coupling between the different platforms}
    \optionC{The uses view to show the uses relationships between the different platforms}
    \optionD{The data model view to represent each one of the platforms}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qDVDCatalogAspects}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To allow the share of catalogs with family and friends, including some access control. 
	\end{quote}
	
	This requirement requires 
	
    \optionA{A change to the uses view to represent that friends can use each other catalog}
    \optionB{A change of the layered view to support different presentations, one for each friend}
    \optionC{A change of the decomposition view to include a set of new modules with the responsibilities associated with the access control}
    \optionD{A new aspect view that includes a module with the responsibilities associated with the access control and that crosscuts some of the other modules}
 \putOptions
\end{ClosedQuestion}
}



% Second Mini-test


% Availability

% REUSED BUT CHANGED
\newcommand{\qOmissionRetry}{
\begin{ClosedQuestion}
	Considering the availability architectural quality, the tactic of retry

    \optionA{Can be applied to any kind stimulus in availability scenarios}
    \optionB{Is useful to support scenarios where the stimulus is an omission}
    \optionC{Can guarantee that the system will not become unavailable}
    \optionD{When applied it increases the latency of the availability scenario's response time}
 \putOptions 
\end{ClosedQuestion}
}

% REUSED
\newcommand{\qAvailability}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to detect faults of type
    \emph{response} in your system, which tactic is more adequate?

    \optionA{The Ping/Echo tactic}
    \optionB{The Heartbeat tactic}
    \optionC{The Voting tactic}
    \optionD{The Removal from Service tactic}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

% Performance

% REUSED BUT CHANGED
\newcommand{\qScalability}{
  \begin{ClosedQuestion}
    Several of the cases studied in this course have scalability
    requirements.  That means that those systems should be designed in
    such a way that they

    \optionA{Have high throughput}
    \optionB{Have low latency}
    \optionC{Allow many simultaneous users}
    \optionD{May be easily changed to increase their storage capacity}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

% REUSED BUT CHANGED
\newcommand{\qPerformance}{
\begin{ClosedQuestion}
	Consider a scenario for performance where the arrival of events is stochastic with a distribution where there are peeks of events but the arrival of events over a long period is uniform. The best tactic to apply is
		
    \optionA{Manage sampling rate}
    \optionB{Limit event response}
    \optionC{Prioritize events}
    \optionD{Bound execution time}
 \putOptions 
\end{ClosedQuestion}
}



% Modifiablity

\newcommand{\qModifiabilityOne}{
\begin{ClosedQuestion}
	In a modifiability scenario the environment can be characterized as design time, compile time, build time, initiation time, and runtime.
	
    \optionA{When the environment is design time it means that the change should be done before the system enters into production}
    \optionB{When the environment is build time it means that it is necessary to codify a new module that is added by rebuilding the system}
    \optionC{When the environment is initiation time it means that it is necessary to restart the system for the change to effect}
    \optionD{When the environment is runtime the cost of doing the change is higher than in the other environments}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qModifiabilityTwo}{
\begin{ClosedQuestion}
	Consider that a module, that contains a complex business logic, needs to invoke a remote entity using a particular communication protocol and it is needs to manage the invocation, like deal with the possible errors, delays and omissions in the invocation, transform the data before sending it, etc. Which tactic should be applied for a scenario where there will be changes in the communication protocol. Note that the business logic comprises a set of functionalities that is independent of the remote invocation technological aspects. 
			
    \optionA{Encapsulate the module such that the clients of the module should not be aware of the remote invocations}
    \optionB{Use an intermediary that contains all the code associated with the remote invocation separating it from the modules' business logic}
    \optionC{Refactor the common parts between the business logic and the remote invocation}
    \optionD{Increase the semantic coherence between the business logic code and the remote invocation code}
 \putOptions 
\end{ClosedQuestion}
}



% Graphite

% REUSED
\newcommand{\qGraphiteScenarioTacticsOne}{
  \begin{ClosedQuestion}
    In the Graphite system the component \emph{carbon} provides to \emph{webapp} components an access interface to the \emph{buffers} in order to improve the quality of

    \optionA{Performance}
    \optionB{Interoperability}
    \optionC{Availability (Reliability)}
    \optionD{Security}

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

% REUSED
\newcommand{\qGraphiteScenarioTacticsTwo}{
  \begin{ClosedQuestion}
	  Which quality, or qualities, of the Graphite system are described by the sentence: \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL}

    \optionA{Usability and Performance}
    \optionB{Usability}
    \optionC{Performance}
    \optionD{Testability}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}



% Hadhoop

% REUSED
\newcommand{\qHadoopCheckpoint}{
  \begin{ClosedQuestion}
    In the HDFS system when the \emph{CheckpointNode} and the \emph{NameNode} are deployed in different nodes, the \emph{CheckpointNode} provides:
    \optionA{Performance and availability qualities}
    \optionB{Performance qualities only}
    \optionC{Availability qualities only}
    \optionD{Performance and security qualities}

    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

% REUSED BUT CHANGED
\newcommand{\qHadoopNameNodeReplica}{
  \begin{ClosedQuestion}
    The architecture of the HDFS system only allows the existence of
    one NameNode.  Given the responsibilities of this component and
    the current architecture of HDFS, what would be the consequences
    of adding the possibility of having replicas of the NameNode in
    the system?

    \optionA{The system would respond faster to all the
      clients' requests}
    \optionB{The performance of the system would not change}
    \optionC{The system would respond faster to requests about
      file locations}
    \optionD{The system would respond faster to requests made by
      DataNodes to update the metadata}
    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}





% First Mini-test

% Software Architecture

% REUSED
\newcommand{\qSoftwareArchitecture}{
\begin{ClosedQuestion}
  The software architecture of a system

    \optionA{Depends mostly on the system's functional requirements}
    \optionB{Depends more on the architect's experience than on anything else}
    \optionC{Should not depend on the skills of the developing team}
    \optionD{None of the above}
 \putOptions
\end{ClosedQuestion}
}

% REUSED
\newcommand{\qEarlyDecisions}{
\begin{ClosedQuestion}
	In his article, \emph{Who Needs and Architect?}, Martin Fowler cites Ralph Johnson definition:
	
	\begin{quote}
		Architecture is the set of decisions that must be made early in a project.
	\end{quote}
	
	In his opinion:
		
    \optionA{This is right because if you don't the project fails}
    \optionB{This is wrong because you can easily change these decisions during the project lifetime}
    \optionC{This is right but you cannot be completely sure whether the decisions are the right ones}
    \optionD{This is wrong because it is against the agile way of thinking the software development process}
 \putOptions
\end{ClosedQuestion}
}


% Requirements

% REUSED
\newcommand{\qGeneralScenario}{
\begin{ClosedQuestion}
	A general scenario for a quality attribute

    \optionA{Describes a concrete quality that a particular system has to implement}
    \optionB{Enumerates, for each kind of quality attribute, all the possible types of source of stimulus, stimulus, response, etc}
    \optionC{Can omit some of the elements like, for instance, the environment, if they are not relevant for the general scenario}
    \optionD{Is a very reusable scenario that can be effectively used in many different concrete situations}
 \putOptions 
\end{ClosedQuestion}
}

% NEW
\newcommand{\qArchitecturalTactics}{
\begin{ClosedQuestion}
	An architectural tactic for a system describes

    \optionA{A non-functional requirement a system has to achieve}
    \optionB{How to control the response to one or more stimulus}
    \optionC{What should be the system response in the occurrence of a stimulus}
    \optionD{A decomposition of the system that fulfills an architectural quality}
 \putOptions 
\end{ClosedQuestion}
}


% Timelines of Scale

\newcommand{\qTwitterScaleOne}{
\begin{ClosedQuestion}
	In the description of the Twitter system we can read:
	
	\begin{quote}
		 Twitter is optimized to be highly available on the read path on the home timeline. Read path is in the 10s of milliseconds.
	\end{quote}
	
	This is achieved because:

    \optionA{The writing of a tweet is a synchronous process where different users have a consistent view of the sequence of tweets}
    \optionB{A tweet is written in each one of the Twitter's servers}
    \optionC{The tweet unique ID is written in the home timeline of each one of the writer's followers}
    \optionD{The tweet content is written in the home timeline of each one of the writer's followers}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qTwitterScaleTwo}{
\begin{ClosedQuestion}
	In the description of the Twitter system we can read:
	
	\begin{quote}
		On the search timeline:
		 Write. when a tweet comes in and hits the Ingester only one Early Bird machine is hit. Write time path is O(1). A single tweet is ingested in under 5 seconds between the queuing and processing to find the one Early Bird to write it to.
	\end{quote}
	
    \optionA{The search timeline is the most important business use case for Twitter}
    \optionB{The ingestion process includes tokenizing of the tweet to include in an index}
    \optionC{The Early Bird server contains the tweet content}
    \optionD{The write in the Early Bird server is synchronous, only when it finishes does the user receives the feedback of a successful post}
 \putOptions 
\end{ClosedQuestion}
}



% Architectures for scalable web applications

\newcommand{\qProxyServer}{
\begin{ClosedQuestion}
	Consider the following figure that presents a Proxy Server, which collapses requests from different users.
	
	\begin{center}
		\includegraphics[width=12cm]{ProxyServer}
	\end{center}
	
	
    \optionA{This solution optimizes the performance in terms of the latency of each request}
    \optionB{This solution allows an "infinite"\ increase of the number clients by allowing the inclusion of more Request Nodes}
    \optionC{This solution continues to provide service even if a crash occurs in the Data server}
    \optionD{This solution optimizes the performance in terms of the throughput of processed requests}
 \putOptions 
\end{ClosedQuestion}
}


\newcommand{\qQueues}{
\begin{ClosedQuestion}
	Consider the following figure that presents a Queue where client applications write their requests to be served by a server.
	
	\begin{center}
		\includegraphics[width=13cm]{Queues}
	\end{center}
	
	
    \optionA{This solution assures a consistency view to the clients of the data that is written}
    \optionB{In this solution the clients invocations have to be synchronous}
    \optionC{In this solution the tasks in the queue need to be sequentially processed, only when a task is finished can another start to be processed}
    \optionD{This solution allows the dimensioning of the number of activities (threads or processes) that run in the server, taking into consideration the server's hardware capacity, in order to have a efficient usage of the server's CPU}
 \putOptions 
\end{ClosedQuestion}
}




% Hadoop


\newcommand{\qHadoopCluster}{
\begin{ClosedQuestion}
	Consider the following figure that presents the Hadoop cluster topology.
	
	\begin{center}
		\includegraphics[width=10cm]{HadoopClusterTopology}
	\end{center}
	
    \optionA{When a new block is created, the first replica is written in the node where the writer is located, to improve availability}
    \optionB{When a new block is created, the second replica is not stored in the same rack than the first replica to increase the availability when a Data Node fails}
    \optionC{When a new block is created, the third replica is stored in the same rack than the second replica to improve the performance of reads}
    \optionD{When a read occurs, the client, if it is located in the cluster, receives a list of the DataNodes where the replicas are, ordered by its closeness to the client, to improve performance of reads}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qHadoopCreateFile}{
\begin{ClosedQuestion}
	In the description of Hadoop we can red.
	
	\begin{quote}
		The CheckpointNode periodically combines the existing checkpoint and journal to create a new checkpoint and an empty journal. The CheckpointNode usually runs on a different host from the NameNode since it has the same memory requirements as the NameNode.
	\end{quote}
	
    \optionA{The periodic rebuild of the checkpoint is done to increase the availability of the NameNode}
    \optionB{The advantage of running the CheckpointNode in a different host is to not degrade the availability of the NameNode during checkpoint construction}
    \optionC{The periodic rebuild of the checkpoint improves the performance of the NameNode during normal operation}
    \optionD{The periodic rebuild of the checkpoint improves the performance of the NameNode during its initialization}
 \putOptions 
\end{ClosedQuestion}
}



%%% Perguntas de anos anteriores
%%%

%% =========================================================================
%% exams 2015/2016
%% =========================================================================



%%% EXAMS

%1 Architecture Influence Cycle
\newcommand{\qArchitectureInfluenceCycleOne}{
\begin{ClosedQuestion}
	Consider the following sentence by Melvin Conways, also known as Conway's Law
	
	\begin{quote}
		organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations
	\end{quote}
		
    \optionA{This law highlights the impact of the business on the architecture}
    \optionB{This law can be seen as an example of the architecture influence cycle}
    \optionC{This law states that architectures impact on the structure of the organization}
    \optionD{This law does not apply to the design of architectures}
 \putOptions 
\end{ClosedQuestion}
}


\newcommand{\qArchitectureInfluenceCycleTwo}{
\begin{ClosedQuestion}
  	  Designing the software architecture for a complex system

   	 \optionA{Is useful only if done (even if only partially) before the
	 	system's implementation is concluded, given that the architecture
    	is used for restricting the implementation}
	\optionB{Is useful only if done (even if only partially) before the
    	system's implementation is concluded, because if the system is
    	already implemented, its implementation uniquely determines the
    	architecture}
    \optionC{Is useful only if done (even if only partially) before the
    	system passes all of the acceptance tests by the client, given
    	that no more requirements changes will take place after that time}
    \optionD{Is useful even if the implementation is concluded and the
    	system has entered the maintenance phase}
		
    \putOptions %D
\end{ClosedQuestion}
}


%2 Adventure Builder - NEW
\newcommand{\qAdventureBuilderOne}{
\begin{ClosedQuestion}
  	Consider the following architectural view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=8cm]{../AdventureBuilderDeployment}
	\end{center}
	
	According to this view the stakeholders can see that the Adventure Builder system

   	\optionA{Becomes unavailable for clients if there is a fault in the hardware of web server (srv-web)}
	\optionB{Becomes unavailable for clients if there is a fault in the hardware of database server (srv-db)}
    \optionC{Becomes unavailable for clients if there is a fault in the hardware of service server (srv-opc)}
    \optionD{Becomes unavailable for banks if there is a fault in the hardware of service server (srv-opc)}
		
    \putOptions
\end{ClosedQuestion}
}

%2 Adventure Builder - NEW
\newcommand{\qAdventureBuilderTwo}{
\begin{ClosedQuestion}
  	Consider the following architectural view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=12cm]{../AdventureBuilderComponentConector}
	\end{center}
	
	In this component-and-connector view the interactions the interactions between components follow the architectural style(s)

   	\optionA{Communicating processes}
	\optionB{Communicating processes and shared-data}
    \optionC{Communicating processes, shared-data and service-oriented architecture}
    \optionD{Communicating processes, shared-data, service-oriented architecture, and peer-to-peer}
		
    \putOptions %D
\end{ClosedQuestion}
}



%3 Featuritis Performitis Flexibilities
\newcommand{\qRequirementsOne}{
\begin{ClosedQuestion}
	Frank Buschmann cites the characterization Marquardt does of Performitis:
		
	\begin{quote}
		Each part of the system is directly influenced by local performance tuning measures. There is no global performance strategy, or it ignores other qualities of the system as testability and maintainability.
	\end{quote}
	
	From this problem you can conclude that:

    \optionA{Performance is a quality that you have to address at the end of the development process}
    \optionB{There is no system which can have good performance and be easily maintainable}
    \optionC{We have to distinguish architectural performance from opportunistic performance}
    \optionD{The system performance quality has impact on the performance of the execution of tests}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qRequirementsTwo}{
\begin{ClosedQuestion}
  The architecturally significant requirements are important in the process of creating
  the software architecture for a system because they are

  \optionA{The most important requirements (both functional and
  	qualities) that the system must achieve}
  \optionB{The components that manage the communication between the
  	remaining elements in the system}
  \optionC{The stakeholders that drive the development of the system}
  \optionD{The tactics that satisfy the most important requirements for
  	the system}
  
 \putOptions
\end{ClosedQuestion}
}


%4 Architecture Definition
\newcommand{\qArchitectureDefinitionOne}{
	\begin{ClosedQuestion}
	    Consider that a software development team uses an agile methodology
	    such as XP (Extreme Programming), where no documentation is
	    produced.  Then, the systems developed by that team

	    \optionA{Typically have a software architecture that results
	      from the common knowledge about the system that is shared among
	      the team members}
	    \optionB{Do not have a software architecture, because in agile
	      methodologies there is no architectural design phase}
	    \optionC{Do not have a software architecture, because the practice of
	      refactoring allows changing every part of the system easily}
	    \optionD{May have a software architecture, but that architecture is
	      not known because it was neither designed nor documented}
	 	
    \putOptions
	\end{ClosedQuestion}
}

\newcommand{\qArchitectureDefinitionTwo}{
	\begin{ClosedQuestion}
	 	The software architecture of a system

    	\optionA{Depends mostly on the system's functional requirements}
    	\optionB{Depends more on the architect's experience than on anything else}
    	\optionC{Should not depend on the skills of the developing team}
    	\optionD{None of the above}
    \putOptions
	\end{ClosedQuestion}
}


%5 Module vs Component
\newcommand{\qModuleComponentOne}{
  \begin{ClosedQuestion}
    Consider the Figure that describes the use of
    caches in web services.  
	
	\begin{center}
		\includegraphics[width=8cm]{../RequestNodeCache}
	\end{center}
	
	In that Figure, there is a
    rectangle with the name \emph{Cache} within another rectangle with
    the name \emph{Request Node}.  Taking into account the description
    made in the text and the goal of that Figure, those rectangles
    correspond to which type of software elements?

    \optionA{They are both modules}
    \optionB{They are both components}
    \optionC{The \emph{Request Node} is a component and the
      \emph{Cache} is a module}
    \optionD{The \emph{Request Node} is a module and the \emph{Cache}
      is a component}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qModuleComponentTwo}{
 \begin{ClosedQuestion}
    Which of the following phrases best describe the relationship
    between modules and components?

    \optionA{A module may contain code from different components}
    \optionB{A component may execute code from different modules}
    \optionC{A module may execute code from different components}
    \optionD{A component may contain code from different modules}
    \putOptions

 \end{ClosedQuestion}
}


%6 Scenarios and Tactics
\newcommand{\qScenariosTacticsOne}{
\begin{ClosedQuestion}
  As part of the process of creating an architecture, we talked about
  a framework for capturing some of the requirements for a system.  In
  this context, \textbf{concrete scenarios} are used for

  \optionA{Describing what are the qualities that the system should possess}
  \optionB{Describing a set of steps that a user of the system must
  	perform to accomplish some task}
  \optionC{Describing a use case for the system that makes clear what
    should be the system's responses to each of the user's inputs}
  \optionD{Describing the system's features by way of different
    usage scenarios for it, in which users play the role of actors}
  \putOptions
\end{ClosedQuestion}
}

\newcommand{\qScenariosTacticsTwo}{
\begin{ClosedQuestion}
	General scenarios play an important role in the development of a software architecture
	because
	
	\optionA{They describe general requirements that all systems should try to satisfy}
	\optionB{They allow us to build a more robust architecture that satisfies less specific
		requirements, which address a wider range of situations that may happen in
		the system}
	\optionC{They identify the most important requirements that the system should satisfy}
	\optionD{They guide us in the requirement elicitation process with the system's stakeholders}
	
	\putOptions
\end{ClosedQuestion}
}

%7 Availability
\newcommand{\qAvailabilityOne}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to deal with faults of type
    \emph{omission} in your system, which tactic is more adequate?

    \optionA{Retry}
    \optionB{Active redundancy}
    \optionC{Ignore faulty behaviour}
    \optionD{Ping/Echo}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qAvailabilityTwo}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to detect faults of type
    \emph{response} in your system, which tactic is more adequate?

    \optionA{Ping/Echo}
    \optionB{Heartbeat}
    \optionC{Voting}
    \optionD{Removal from Service}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%8 Performance
\newcommand{\qPerformanceOneOne}{
  \begin{ClosedQuestion}
    Consider the change in the architecture associated with the use of caches in web services shown in the figure
	
	\begin{center}
		\includegraphics[width=15cm]{../LocalDistributedCache}
	\end{center}
	
	That change has the goal and the consequence of, respectively

    \optionA{Increasing performance and availability}
    \optionB{Increasing availability and decreasing performance}
    \optionC{Increasing performance and decreasing availability}
    \optionD{Increasing performance, scalability and availability}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qPerformanceTwoOne}{
  \begin{ClosedQuestion}
    Consider the change in the architecture associated with the use of caches in web services shown in the figure 
	
	\begin{center}
		\includegraphics[width=10cm]{../LocalGlobalCache}
	\end{center}
	
	Taking into consideration that this change involves adding a server, which has a larger storage capacity than the request Nodes, that change has the impact of

    \optionA{Increasing performance and availability}
    \optionB{Increasing availability and decreasing performance}
    \optionC{Increasing performance and decreasing availability}
    \optionD{Increasing scalability and availability}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%9 Modifiability
\newcommand{\qModifiabilityOneOne}{
  \begin{ClosedQuestion}
    Consider that an architect needs to design a system which interacts with two external sources of information, and it has to import some of the information to store it in the system's internal database. The stakeholders inform him that it will be necessary to include new sources of information in the future, besides the two already identified, but they cannot precisely define which they are. This changes will occur after the first version of the system is in production. Additionally, the stakeholders define a short period of time to integrate a new source of information. Given this requirements the architect should
		
    \optionA{Consider the requirements not realistic}
    \optionB{Apply tactics of defer binding to allow the addition of the new sources of information in initialization time}
    \optionC{Identify what should be the common and specific parts of the module responsible for the interaction with the external sources, before interacting again with the stakeholders}
    \optionD{Consider this requirement as a non architecturally significant requirement}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qModifiabilityTwoOne}{
  \begin{ClosedQuestion}
    Several of the cases studied in this course had scalability
    requirements.  That means that those systems should be designed in
    such a way that they

    \optionA{Have high throughput}
    \optionB{Have low latency}
    \optionC{Allow many simultaneous users}
    \optionD{May be easily changed to increase their performance}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%10 nginx Scenarios and Tactics
\newcommand{\qNginxScenariosTacticsOne}{
\begin{ClosedQuestion}
	Consider the following excerpt from Nginx case study

	\begin{quote}
		nginx configuration is kept in a number of plain text files which typically reside in /usr/local/etc/nginx or /etc/nginx. The main configuration file is usually called nginx.conf. 		To keep it uncluttered, parts of the configuration can be put in separate files which can be automatically included in the main one. However, it should be noted here that nginx 		does not currently support Apache-style distributed configurations (i.e., .htaccess files). All of the configuration relevant to nginx web server behavior should reside in a 		centralized set of configuration files.
	\end{quote}
	
	When comparing the configuration in Nginx with the configuration in Apache we can say that
	
	  \optionA{Due to its configuration strategy Apache has better performance}
	  \optionB{Performance was the main concern of the design of the configuration strategy in Nginx}
	  \optionC{Apache emphasizes the usability quality for system administrators by allowing to split the configuration by different files}
	  \optionD{Nginx emphasizes the usability quality for system administrators by reducing the number or errors}
  
	  \putOptions
	\end{ClosedQuestion}
	}

\newcommand{\qNginxScenariosTacticsTwo}{
\begin{ClosedQuestion}
  Web servers typically receive requests from different users
  concurrently (that is, either different users make requests
  simultaneously or they make them fast enough that it is not possible
  for the web server to answer one request from one user before
  receiving another request from another user).  To process all the
  requests, web servers may use different implementation strategies.
  Assuming that we want to develop a web server to serve only static
  pages with more or less the same size to a set of clients on the
  same LAN network as the server, which of the following strategies
  would be better?

  \optionA{Launch a new process for processing each request}
  \optionB{Spawn a new thread for processing each request}
  \optionC{Put the requests into a queue and schedule their processing}
  \optionD{Buy a server with high processing power}
  
  \putOptions
\end{ClosedQuestion}
}

%11 Continuous Integration Scenarios and Tactics - NEW
\newcommand{\qContinousIntegrationScenariosTacticsOne}{
  \begin{ClosedQuestion}
	  In the Continous integration case study can be read about Jenkins
	  
	  \begin{quote}
		  It takes advantage of the JUnit XML standard for unit test and code coverage reporting to integrate reports from a variety of test tools. Jenkins originated with Sun, but is very widely used and has a robust open-source community associated with it.
	  \end{quote}
	  
	  Consider that a scenario is written from the above sentence
    
    \optionA{The stimulus is to integrate reports from a variety of test tools}
    \optionB{The response is JUnit XML standard}
    \optionC{The source of the stimulus is Sun}
    \optionD{The measure of the response is a robust open-source community associated with it}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qContinousIntegrationScenariosTacticsTwo}{
  \begin{ClosedQuestion}
	  In the Continous integration case study can be read about Jenkins
	  
	  \begin{quote}
		  It takes advantage of the JUnit XML standard for unit test and code coverage reporting to integrate reports from a variety of test tools. Jenkins originated with Sun, but is very widely used and has a robust open-source community associated with it.
	  \end{quote}
	  
	  The quality of Jenkins that is emphasized in the above sentence is
    
    \optionA{Modifiability}
    \optionB{Availability}
    \optionC{Testability}
    \optionD{Interoperability}
    \putOptions

 \end{ClosedQuestion}
}


%12 Infinispan Scenarios and Tactics - NEW
\newcommand{\qInfinispanScenariosTacticsOne}{
  \begin{ClosedQuestion}
	  In the Infinispan case study can be read
	  
	  \begin{quote}
		  When persisting for durability, persistence can either be online, where the application thread is blocked until data is safely written to disk, or offline, where data is flushed to disk periodically and asynchronously. In the latter case, the application thread is not blocked on the process of persistence, in exchange for uncertainty as to whether the data was successfully persisted to disk at all.
	  \end{quote}
	  
	  From the description we can infer a trade-off between the qualities of
    
    \optionA{Modifiability and Performance}
    \optionB{Availability and Modifiability}
    \optionC{Performance and Reliability}
    \optionD{Reliability and Security}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qInfinispanScenariosTacticsTwo}{
  \begin{ClosedQuestion}
	  In the Infinispan case study can be read
	  
	  \begin{quote}
		  Infinispan supports several pluggable cache stores-adapters that can be used to persist data to disk or any form of secondary storage. The current default implementation is a simplistic hash bucket and linked list implementation, where each hash bucket is represented by a file on the filesystem. While easy to use and configure, this isn't the best-performing implementation.
	  \end{quote}
	  
	  The main architectural quality addressed in the above excerpt is 
	  
    \optionA{Performance}
    \optionB{Modifiability}
    \optionC{Usability}
    \optionD{Security}
    \putOptions

 \end{ClosedQuestion}
}


%13 Designing-an-Architecture
\newcommand{\qDesigningArchitectureOne}{
  \begin{ClosedQuestion}
    According to the attribute-driven design process, we should design
    the software architecture for a system based on a selected list of
    requirements, which are called the \textit{architecture significant requirements}.
    These requirements should be sorted according to their
    importance for the system's stakeholders because

    \optionA{We should always satisfy in the first place the requirements
      of more important stakeholders (such as the client)}
    \optionB{If no order was established among them, we would not know
      from where should we start the design process}
    \optionC{If one of the stakeholders complains that his requirement
      is not satisfied, we may explain to him that there were other more
      important requirements first}
    \optionD{When it is not possible to satisfy all of the requirements
      optimally, we should be aware of their relative importance so that
      we may find a solution that corresponds to a satisfactory trade-off}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qDesigningArchitectureTwo}{
\begin{ClosedQuestion}
	During the different steps on how to create an architecture, the precise specification of architecture quality attributes is initially relevant to

    \optionA{Make a business case for the system}
    \optionB{Understand the architecturally significant requirements}
    \optionC{The system design}
    \optionD{Documenting and communicating the architecture}
 \putOptions
\end{ClosedQuestion}
}


%14 Module Viewtype
\newcommand{\qModuleViewtypeOneOne}{
  \begin{ClosedQuestion}
    Consider the following description of \emph{Memcached}, which is
    adapted from its Wiki:
    \begin{quote}
      Memcached is an in-memory key-value store for small chunks of
      arbitrary data from results of database calls, API calls, or
      page rendering.  It is made up of:
      \begin{itemize}
      \item Client software, which is given a list of available memcached servers.
      \item A client-based hashing algorithm, which chooses a server
        based on the "key" input.
      \item Server software, which stores your values with their keys
        into an internal hash table.
      \item Server algorithms, which determine when to throw out old
        data (if out of memory), or reuse memory.
      \end{itemize}
    \end{quote}
    Suppose that you want to present an architectural view for
    \emph{Memcached} that represents the above information.  Which
    view is more adequate?

    \optionA{A view of the Data Model style}
    \optionB{A view of the Layers style}
    \optionC{A view of the Decomposition style}
    \optionD{A view of the Uses style}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qModuleViewtypeTwoOne}{
  \begin{ClosedQuestion}
	  Suppose that in the development of an enterprise application (which needs to access a
	  database) it was decided to use the Hibernate framework to simplify the development
	  of the data access code. Which architectural view is the most adequate to represent this
	  decision?
	  
	  \optionA{A Deployment view}
	  \optionB{A Component-and-Connector view}
	  \optionC{A Uses view}
	  \optionD{A Decomposition view}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%15 Uses and Generalization architectural styles
\newcommand{\qUsesGeneralizationOne}{
\begin{ClosedQuestion}
  To achieve a faster time-to-market, software companies are
  increasingly using a strategy of incremental releases of their
  software, where each new release has a set of new features.  Which
  architectural style is better to analyse whether the system's
  software architecture is adequate for the planned incremental
  releases?

  \optionA{The Decomposition style}
  \optionB{The Deployment style}
  \optionC{The Uses style}
  \optionD{The Work-assignment style}
  \putOptions
\end{ClosedQuestion}
}

\newcommand{\qUsesGeneralizationTwo}{
\begin{ClosedQuestion}
	Suppose that in the process of designing a system's software architecture you come to
	the conclusion that there are uses relations in both directions in almost all of the system's
	modules. This means that
	
	\optionA{There is a high level of communication between the several modules, and this
		will cause the system to have a low performance}
	\optionB{It is not possible to install the system in more than one machine}
	\optionC{It is not possible to develop and to test the system incrementally}
	\optionD{It is very hard to explain what the system does, because we need to understand
		all the execution fluxes}
		
  \putOptions
\end{ClosedQuestion}
}


%16 Layered, Aspects and Data Model
\newcommand{\qLayeredAspectsDataModelOne}{
\begin{ClosedQuestion}
  In a layered architecture composed by four layers, where the topmost
  layer is the layer number 1 and the bottommost layer is the layer
  number 4, which of the layers is more modifiable?

    \optionA{Layer 1}
    \optionB{Layer 4}
    \optionC{In a layered architecture all layers are equally modifiable}
    \optionD{Modifiability is not made easier by a layered architecture}
  \putOptions
\end{ClosedQuestion}
}

\newcommand{\qLayeredAspectsDataModelTwo}{
\begin{ClosedQuestion}
	 Suppose that you are implementing a module in a system that has a two layered architecture.
	 Knowing that your module belongs to the upper layer (assuming the usual notation
	 for the layer style), this means that you
	 
	 \optionA{Can use the operations defined in any of the system's modules}
	 \optionB{Can use the operations defined in the lower layer, but not the ones defined in
	 	the upper layer}
	 \optionC{Can use the operations defined in the upper layer, but not the ones defined in
	 	the lower layer}
	 \optionD{Should use some operation defined in the lower layer}
  \putOptions
\end{ClosedQuestion}
}


%17 Component and Connector
\newcommand{\qComponentConnectorOne}{
\begin{ClosedQuestion}
  Suppose that there are certain performance requirements for a
  system, and that you want to show to the stakeholders of the system
  that the software architecture that you designed meet those
  requirements. To do this

    \optionA{It makes no sense to use views of the module viewtype, as
    	they give only a static view of the system}
    \optionB{You should use only views of the component-and-connector
    	viewtype, which describe the dynamic aspects of the system}
    \optionC{You may need to use views of the three viewtypes}
    \optionD{The only views that are relevant to performance
    	requirements are views of the Deployment style}
	 
	\putOptions
\end{ClosedQuestion}
}

\newcommand{\qComponentConnectorTwo}{
\begin{ClosedQuestion}
	The connectors on component-and-connector view
	
	\optionA{Represent the network infrastructure that allows components to communicate
		with each other}
	\optionB{May, on another view of the system, be represented by a set of components
		and connectors}
	\optionC{Represent the dependency relations that exist among the various components}
	\optionD{Represent the control flow during a execution of the system}
	
	\putOptions
\end{ClosedQuestion}
}


%18 Repository and Client-Server
\newcommand{\qRepositoryClientServerOne}{
  \begin{ClosedQuestion}
    Suppose that you are designing the software architecture for an
    enterprise application that has requirements about the maximum
    response time for a certain type of requests.  Moreover, assume
    that those requests arrive at the system periodically, whereas the
    remaining requests have an unpredictable frequency.  Finally,
    assume that your system will have a single server that will be
    executing on a predefined machine with a 12-core AMD processor.
    To show to the stakeholders that your system satisfies the
    performance requirements you have to use views of which
    architectural style?

    \optionA{The Work Assignment style}
    \optionB{The Client-Server style}
    \optionC{The Deployment style}
    \optionD{The Communicating Processes style}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qRepositoryClientServerTwo}{
  \begin{ClosedQuestion}
    The email system is composed of various types of components
    playing different roles.  For example, to send an email, a user
    uses a \emph{mail user agent} (MUA), to compose his message and
    send it.  To send the message, the MUA typically connects to a
    \emph{mail transfer agent} (MTA) that receives the message,
    analyzes the message's headers to determine the recipients and,
    after querying the DNS system to determine the MTA responsible for
    each recipient, it connects to the MTAs responsible for the
    destination addresses to deliver the message.  Each of these MTAs
    receives the message and stores it locally or forwards it to
    others MTAs until the message reaches its destination MTA.
    The recipient user of the message will then use his MUA to see the
    messages that were sent to him.  To do it, the MUA connects to an
    IMAP or POP server to obtain the user's messages.  Those IMAP and
    POP servers obtain the messages for a user by reading the messages
    stored by the MTA.

    Given this simplified description of the operation of the email
    system, which of the following architectural styles is more
    appropriate to represent the pattern of interaction between the
    MTA and the servers IMAP and POP?

    \optionA{The Peer-to-Peer style}
    \optionB{The Client-Server style}
    \optionC{The Shared-Data style}
    \optionD{The Publish-subscribe style}

    \putOptions
  \end{ClosedQuestion}
}


%19 Tiers, Dynamic reconfiguration, Peer-to-peer, Publish-subscribe
\newcommand{\qTiersDynamicreconfigurationPeertopeerPublishsubscribeOne}{
  \begin{ClosedQuestion}
	  Typically, Instant Messaging clients have a window to list the contacts of the user, and
	  show in that window the status of each contact (whether it is available, unavailable, busy,
	  etc). Given that the status of a contact may be changed at any time, and that the contact's
	  status is given by the Instant Messaging application of that contact, which architectural
	  style represents best the interaction pattern between these components?

	   \optionA{The Shared Data style}
	   \optionB{The Pipes-and-filters style}
	   \optionC{The Publish-subscribe style}
	  \optionD{The Client-Server style}
   \putOptions

  \end{ClosedQuestion}
}

\newcommand{\qTiersDynamicreconfigurationPeertopeerPublishsubscribeTwo}{
  \begin{ClosedQuestion}
    Consider the following excerpt from the tutorial on the Hadoop
    MapReduce:

    \begin{quote}
      Hadoop MapReduce is a software framework for easily writing
      applications which process vast amounts of data (multi-terabyte
      data-sets) in-parallel on large clusters (thousands of nodes) of
      commodity hardware in a reliable, fault-tolerant manner.

      A MapReduce job usually splits the input data-set into
      independent chunks which are processed by the map tasks in a
      completely parallel manner.  The framework sorts the outputs of
      the maps, which are then input to the reduce tasks. Typically
      both the input and the output of the job are stored in a
      file-system.  The framework takes care of scheduling tasks,
      monitoring them and re-executes the failed tasks.
    \end{quote}

    Which architectural style of the component-and-connector viewtype
    is more adequate to describe how the MapReduce works, taking into
    account its main advantages in solving a problem?

    \optionA{The Shared data style}
    \optionB{The Pipes-and-filters style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Communicating Processes style}
   \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%20 SOA, Pipes-and-Filters
\newcommand{\qSOAPipesFiltersOne}{
  \begin{ClosedQuestion}
	  Imagine that you want to develop a system that is to be used in email servers, whose goal
	  is to allow changing the emails that are received by the server (for example, to remove
	  potential viruses or URLs linking to phishing sites). The goal is that the server feeds each
	  received email through this system before processing it (e.g., forward it to another server,
	  or store it locally). The system is supposed to be easily modifiable, to support new types
	  of email transformations. Which architectural style is the most adequate to satisfy these
	  requirements?

	   \optionA{The Peer-to-Peer style}
	   \optionB{The Pipes-and-filters style}
	   \optionC{The Client-Server style}
	   \optionD{The Publish-subscribe style}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}


\newcommand{\qSOAPipesFiltersTwo}{
  \begin{ClosedQuestion}
    Suppose that you are developing the software architecture of a new
    system for an organization composed of several organizational
    units, each one with its own information systems, which have been
    developed independently of each other over the course of several
    years and depending on the particular needs of each unit.  Your
    system has the goal of integrating the various existing systems,
    providing in this way not only a unified view of how the
    organization works, but also allowing the creation of new
    processes within the organization that involve more than one unit.
    Which architectural style is better suited to design such a
    system?

    \optionA{The Decomposition style}
    \optionB{The Client-Server style}
    \optionC{The Service Oriented Architecture style}
    \optionD{The Communicating Processes style}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%21 Allocation viewtype
\newcommand{\qAllocationOneOne}{
\begin{ClosedQuestion}
  The Work-assignment is an architectural style of the allocation
  viewtype, where

    \optionA{Components are allocated to persons and teams}
    \optionB{Modules are allocated to persons and teams}
    \optionC{Components and modules are allocated to persons and teams}
    \optionD{None of the above}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}

\newcommand{\qAllocationTwoOne}{
\begin{ClosedQuestion}
  In the software architecture of a system, the Deployment view is
  best suited for

    \optionA{Analysing the performance of the system}
    \optionB{Planning incremental releases of the system}
    \optionC{Estimating the effort needed to implement the system}
    \optionD{Analysing the system's portability and reusability}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


%22 nginx views
\newcommand{\qnginxOne}{
\begin{ClosedQuestion}
  Web servers implemented in Java, such as the Tomcat web server,
  typically use a thread-based model for processing requests.  That
  is, they process each request on a different thread within the same
  JVM process, rather than on a different process.  One of the reasons
  for this is that

  \optionA{Launching a new process for processing each request is too expensive}
  \optionB{Using threads ensures that the processing of each request is
  	isolated from the remaining requests}
  \optionC{With this approach they may use all of the available cores
  	in multiprocessor machines}
  \optionD{They are used for implementing enterprise applications that
  	typically have complex domain logic and, by using threads, it is
  	easier to reuse code from one request to another}
  \putOptions
  
  % Resposta: A
\end{ClosedQuestion}
}

\newcommand{\qnginxTwo}{
  \begin{ClosedQuestion}
    In Nginx, given that a \emph{worker} processes various requests during its
    life, how does it do it?

    \optionA{By interleaving the various processing phases of each
      request in a sequential process}
    \optionB{By executing in parallel each of the phases of the
      pipeline corresponding to the processing of a request}
    \optionC{By executing in parallel the processing of the various requests}
    \optionD{By processing completely each request before moving to
      the next one, in a sequential process}
    \putOptions
	
    % Resposta: A
  \end{ClosedQuestion}
}


%23 Continuous Integration Views - NEW
\newcommand{\qContinousIntegrationViewsOne}{
  \begin{ClosedQuestion}
	 Consider the following architectural view of the Pony-Build system as described in the Continous integration case study
	  
	\begin{center}
		\includegraphics[width=10cm]{../PonyBuildArchitecture}
	\end{center}
	
	According to this view the quality of performance is achieved through
    
    \optionA{An increase resource efficiency tactic}
    \optionB{A schedule resources tactic}
    \optionC{A multiple copies of computation tactic}
    \optionD{A manage sampling rate tactic}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qContinousIntegrationViewsTwo}{
  \begin{ClosedQuestion}
	  In the Continous integration case study can be read about future features for Pony-Build
	  
	  \begin{quote}
		  Currently, each continuous integration system reinvents the wheel by providing its own build configuration language, which is manifestly ridiculous; there are fewer than a dozen commonly used build systems, and probably only a few dozen test runners. Nonetheless, each CI system has a new and different way of specifying the build and test commands to be run. In fact, this seems to be one of the reasons why so many basically identical CI systems exist: each language and community implements their own configuration system, tailored to their own build and test systems, and then layers on the same set of features above that system. Therefore, building a domain-specific language (DSL) capable of representing the options used by the few dozen commonly used build and test tool chains would go a long way toward simplifying the CI landscape.
	  \end{quote}
	  
	  Suppose that you are the architect that has to change the architecture to accomodate this new feature. Therefore, as an architect
    
    \optionA{You need to change the decomposition view to represent modules with the responsibilities associated with the DSL}
    \optionB{You need to design a client-server view representing the interaction between the DSL and the servers that execute its commands}
    \optionC{You need to design an implementation view to allow system administrators configure the builds}
    \optionD{You do not need to change the views because the DSL does not have any architectural impact}
    \putOptions

 \end{ClosedQuestion}
}


%24 Infinispan Views - NEW
\newcommand{\qInfinispanViewsOne}{
  \begin{ClosedQuestion}
	  In the Infinispan case study can be read
	  
	  \begin{quote}
		 Infinispan's core data structures make use of software transactional memory techniques for concurrent access to shared data. This minimizes the need for explicit locks, mutexes and other forms of synchronization, preferring techniques like compare-and-set operations within a loop to achieve correctness when updating shared data structures. Such techniques have been proven to improve CPU utilization in multi-core and SMP systems, and despite the increased code complexity, has paid off in overall performance when under load.
	  \end{quote}
	  
	  These properties of Infinispan can be represented by
    
    \optionA{A decomposition view which represent the module for compare-and-set}
    \optionB{A client-server view with non-blocking connectors for the interaction between threads and core data structures}
    \optionC{A communicating-processes view with non-blocking connectors for the interaction between threads and core data structures}
    \optionD{A deployment view which allocate threads to the multi-cores}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qInfinispanViewsTwo}{
  \begin{ClosedQuestion}
	  In the Infinispan case study can be read
	  
	  \begin{quote}
		 Infinispan uses its own serialization scheme, where full class definitions are not written to the stream. Instead, magic numbers are used for known types where each known type is represented by a single byte. This greatly improves not just serialization and de-serialization speed qualities, but also produces a much more compact byte stream for transmission across a network. An externalizer is registered for each known data type, registered against a magic number. This externalizer contains the logic to convert object to bytes and vice versa.
	  \end{quote}
	  
	  These properties of Infinispan can be represented by
    
    \optionA{A uses view which represent modules for the externalizers}
    \optionB{A client-server view which represent the byte stream for transmission across a network}
    \optionC{A connector that has the serialization and de-serialization speed qualities}
    \optionD{A decomposition view which contains the serialization/de-serilization modules}
    \putOptions

 \end{ClosedQuestion}
}


%25 Web2.0 
\newcommand{\qWebTwoOne}{
  \begin{ClosedQuestion}
    With the evolution of the web application technologies, it is now
    possible to develop web applications with a user interface similar
    to the interface of desktop applications.  Yet, for this to
    happen, part of the code that was executing in the web server is
    now executing in the web browser.  How does this change manifests
    in the software architecture of the system?

    \optionA{In the Deployment view, because the presentation
      component is now executing in a different place}
    \optionB{In the component-and-connector view, because the
      connector between the web client and the web server has to change}
    \optionC{In the Layer view, because the order of the layers will
      have to change}
    \optionD{In the mapping between layers of the system and the
      components where they execute}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qWebTwoTwo}{
  \begin{ClosedQuestion}
    One of the evolutions in the development of web applications was
    the appearance of \emph{mashups}, which are described in Wikipedia
    as follows:

    \begin{quote}
      In web development, a mashup is a web page or application that
      uses and combines data, presentation or functionality from two
      or more sources to create new services.
    \end{quote}

    Knowing that the sources used by \emph{mashups} do not know about
    the existence of the \emph{mashups} and that they change
    frequently, forcing the adaptation of the \emph{mashups} to
    accomodate those changes, what is the best architecture to
    minimize the effects of those changes?

    \optionA{A \emph{web services} architecture}
    \optionB{A Client-Server architecture, where the \emph{mashup}
      is the client and the various sources are the servers}
    \optionC{A layered architecture, where the access to the various
      sources is the responsibility of the bottommost layer}
    \optionD{A Publish-Subscribe architecture, where the various
      sources publish events with the changes made and the
      \emph{mashup} subscribes those events}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%26 Microservices architecture - NEW
\newcommand{\qMicroservicesArchitectureOne}{
  \begin{ClosedQuestion}
    Consider the following figure depicting two different architectures for web applications
	
	\begin{center}
		\includegraphics[width=10cm]{../Microservices}
	\end{center}
	
    \optionA{The left part of the figure represents a three-layered architecture}
    \optionB{The most relevant architectural style in the right part of the figure is shared-data}
    \optionC{The system represented in the left part of the figure tends to be non-transactional}
    \optionD{The system represented in the right part of the figure tends to have good modifiability}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qMicroservicesArchitectureTwo}{
  \begin{ClosedQuestion}
    Consider the following figure depicting two different architectures for web applications
	
	\begin{center}
		\includegraphics[width=14cm]{../Microservices}
	\end{center}
	
    \optionA{The main quality of the system in the right part of the figure is scalability}
    \optionB{The main quality of the system in the left part of the figure is scalability}
    \optionC{The main quality of the system in the right part of the figure is ease of development}
    \optionD{The main quality of the system in the left part of the figure is to promote cross-functional teams}
    \putOptions

 \end{ClosedQuestion}
}


%27 Amazon - NEW
\newcommand{\qAmazonOne}{
  \begin{ClosedQuestion}
    Consider the following excerpt about the Amazon system
	
	\begin{quote}
		Over time, this grew into hundreds of services and a number of application servers that aggregate the information from the services. The application that renders the Amazon.com Web pages is one such application server, but so are the applications that serve the Web-services interface, the customer service application, the seller interface, and the many third-party Web sites that run on our platform.
	\end{quote}
	
	The architectural style that better represents these aspects of the Amazon architecture is
	
    \optionA{Service-oriented architecture to express how clients can access the services}
    \optionB{Client-server to express how multiple clients can access the applications}
    \optionC{Tiers to express that different applications define their own contexts}
    \optionD{Decomposition to express the different responsibilities assigned to each application}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qAmazonTwo}{
  \begin{ClosedQuestion}
    Consider the following excerpt about the Amazon system
	
	\begin{quote}
		Mainly, I think service orientation has helped us there. The stored data formats are decoupled from the format in which you communicate data items. If there is no need for sharing schemas of the actual storage layout, you can focus on making sure that the service interfaces can evolve in a way that allows you to handle variations of data formats. You could dictate a rigorous single format, but that would not be realistic if you are in Amazon's platform business. We have to make sure that the platform can be extended by our customers to meet their needs.
	\end{quote}
	
	The architectural style that better represents these aspects of the Amazon architecture is
	
    \optionA{Data model to express the stored data formats}
    \optionB{Decomposition to express the services interfaces}
    \optionC{Aspects to express the evolution of service interfaces}
    \optionD{Publish-subscribe to express how data is shared between services}
    \putOptions

 \end{ClosedQuestion}
}


%28 Scalable web architecture and distributed systems tactics - NEW
\newcommand{\qScalableArchitectureOne}{
  \begin{ClosedQuestion}
    Consider the following excerpt about the Scalable web architecture and distributed systems case study about two different possible implementations of a global cache
	
	\begin{quote}
		 The majority of applications leveraging global caches tend to use the first type, where the cache itself manages eviction and fetching data to prevent a flood of requests for the same data from the clients. However, there are some cases where the second implementation makes more sense. For example, if the cache is being used for very large files, a low cache hit percentage would cause the cache buffer to become overwhelmed with cache misses; in this situation it helps to have a large percentage of the total data set (or hot data set) in the cache. 	\end{quote}
	
    \optionA{The solution where the application is responsible for the eviction has better availability}
    \optionB{The solution where the cache is responsible for the eviction has better availability}
    \optionC{The solution where the application is responsible for the eviction has better modifiability}
    \optionD{The solution where the cache is responsible for the eviction has better performance}
    \putOptions

 \end{ClosedQuestion}
}

\newcommand{\qScalableArchitectureTwo}{
  \begin{ClosedQuestion}
    Consider the following excerpt about the Scalable web architecture and distributed systems case study
	
	\begin{quote}
		 Employing such a strategy maximizes data locality for the requests, which can result in decreased request latency. For example, let's say a bunch of nodes request parts of B: partB1, partB2, etc. We can set up our proxy to recognize the spatial locality of the individual requests, collapsing them into a single request and returning only bigB, greatly minimizing the reads from the data origin.
	\end{quote}
	
	The quality that is achieved with this tactic is
	
    \optionA{Performance because all requests will be processed faster}
    \optionB{Performance because it allows the processing of more requests per unit of time}
    \optionC{Availability because even if PartB1 is not available partB2 can be provided}
    \optionD{Reliability because a single correct read is used to respond to several requests}
    \putOptions

 \end{ClosedQuestion}
}


%29 Graphite scenarios and tactics
\newcommand{\qGraphiteScenarioTacticsOne}{
  \begin{ClosedQuestion}
    In the Graphite system the component \emph{carbon} provides to \emph{webapp} components an access interface to the \emph{buffers} in order to improve the quality of

    \optionA{Performance}
    \optionB{Interoperability}
    \optionC{Reliability}
    \optionD{Security}

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGraphiteScenarioTacticsTwo}{
  \begin{ClosedQuestion}
	  Which quality, or qualities, of the Graphite system are described by the sentence: \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL.}

    \optionA{Usability and Performance}
    \optionB{Usability}
    \optionC{Performance}
    \optionD{Testability}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}


% 30 Graphite views
\newcommand{\qGraphiteViewsOne}{
 \begin{ClosedQuestion}
    In Graphite system  the \emph{receiver} and the \emph{writer threads} support asynchronous writing of metrics to optimize disk accesses. The interaction between these two components follow the architectural style

    \optionA{Client-server}
    \optionB{Communicating Processes}
    \optionC{Repository}
    \optionD{Pipes-and-Filters}

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qGraphiteViewsTwo}{
  \begin{ClosedQuestion}
	  A high-level component-and-connect view of Graphite system can be designed using only the architectural style(s)

    \optionA{Shared-data and Communicating-Processes}
    \optionB{Communicating-Processes}
    \optionC{Tiers}
    \optionD{Client-Server and Shared-data}

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}


% Quarto Mini-teste


% Component-and-Connector styles

%1
\newcommand{\qComponentAndConnectorOne}{
\begin{ClosedQuestion}
	Consider the Service-Oriented Architecture architectural style
		
    \optionA{The main quality this style addresses is interoperability.}
    \optionB{It cannot be applied when the system includes legacy systems.}
    \optionC{Its enterprise service bus cannot support asynchronous communication between the components.}
    \optionD{The typical communication pattern is point-to-point.}
 \putOptions 
\end{ClosedQuestion}
}

%2
\newcommand{\qComponentAndConnectorTwo}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=8cm]{AdventureBuilder-SOA}
	\end{center}
	
	In this view the following architectural styles are used
	
		
    \optionA{Service-oriented architecture, and Client-server.}
    \optionB{Service-oriented architecture, and Shared-data.}
    \optionC{Service-oriented architecture, Shared-data, and Peer-to-peer.}
    \optionD{Service-oriented architecture, Shared-data, Peer-to-peer, and Client-server.}
 \putOptions 
\end{ClosedQuestion}
}
	
%3
\newcommand{\qComponentAndConnectorThree}{
\begin{ClosedQuestion}
	Consider the following view of the Adventure Builder system
	
	\begin{center}
		\includegraphics[width=10cm]{AdventureBuilder-Tiers}
	\end{center}
	
	In this view the following architectural styles are used
		
    \optionA{Tiers.}
    \optionB{Tiers, and Shared-data.}
    \optionC{Tiers, Shared-data, and Service-oriented architecture.}
    \optionD{Tiers, Shared-data, Service-oriented architecture, and Client-server.}
 \putOptions 
\end{ClosedQuestion}
}

% Allocation viewtype

%4
\newcommand{\qAllocationOne}{
\begin{ClosedQuestion}
	Consider the work assignment architectural style of the allocation viewtype.
			
    \optionA{It assigns components and connectors to people and teams.}
    \optionB{It is useful for the project managers.}
    \optionC{It does not consider the software that is outsourced.}
    \optionD{It allows to estimate the cost of hardware.}
 \putOptions 
\end{ClosedQuestion}
}

%5
\newcommand{\qAllocationTwo}{
\begin{ClosedQuestion}
	Consider the deployment architectural style of the allocation viewtype.
			
    \optionA{It assigns modules to the hardware.}
    \optionB{It cannot assign software elements to virtual servers because they are not hardware.}
    \optionC{For each set of software elements there is a single possible assignment to hardware.}
    \optionD{It is useful for system administrators.}
 \putOptions 
\end{ClosedQuestion}
}

%6
\newcommand{\qAllocationThree}{
\begin{ClosedQuestion}
	Consider the install architectural style of the allocation viewtype.
			
    \optionA{The development team is the main stakeholder interesting in these views.}
    \optionB{It assigns modules to files.}
    \optionC{It is completely independent of the deployment architectural style.}
    \optionD{It helps on the configuration of systems.}
 \putOptions 
\end{ClosedQuestion}
}

% Infinispan views

%7
\newcommand{\qInfinispanOne}{
\begin{ClosedQuestion}
	Consider the Infinispan system when it is configured as a remote data grid. The relation between the Applications and the Grid is
			
    \optionA{Client-server.}
    \optionB{Peer-to-peer.}
    \optionC{Master-slave.}
    \optionD{Pipe-and-filter.}
 \putOptions 
\end{ClosedQuestion}
}

%8
\newcommand{\qInfinispanTwo}{
\begin{ClosedQuestion}
	In the description of Infinispan system can be read
	
	\begin{quote}
		Infinispan supports several pluggable cache stores-adapters that can be used to persist data to disk or any form of secondary storage. The current default implementation is a simplistic hash bucket and linked list implementation, where each hash bucket is represented by a file on the filesystem. While easy to use and configure, this isn't the best-performing implementation.
	\end{quote}
	
	The architectural style(s) that should be used to illustrate the sentence is (are)
			
    \optionA{Decomposition.}
    \optionB{Generalization.}
    \optionC{Decomposition and Generalization.}
    \optionD{Peer-to-peer.}
 \putOptions 
\end{ClosedQuestion}
}

%9
\newcommand{\qInfinispanThree}{
\begin{ClosedQuestion}
	In the description of Infinispan system can be read
	
	\begin{quote}
		When dealing with thread pools to process such asynchronous tasks, there is always a context switching overhead. That threads are not cheap resources is also noteworthy. Allocating appropriately sized and configured thread pools is important to any installation making use of any of the asynchronous features of Infinispan.
	\end{quote}
	
	The architectural style that should be used to illustrate the sentence is
			
    \optionA{Client-server.}
    \optionB{Communicating processes.}
    \optionC{Peer-to-peer.}
    \optionD{Shared-data.}
 \putOptions 
\end{ClosedQuestion}
}

% Micro-services and Amazon Cloud

%10
\newcommand{\qMicroAndAmazonOne}{
\begin{ClosedQuestion}
	Consider the following distinction between Monoliths and Microservices made by Martin Fowler
	
	\begin{center}
		\includegraphics[width=10cm]{MonolithsVsMicroservices}
	\end{center}
	
	If we try to map this figure into a set of views we will need.
			
    \optionA{A decomposition view.}
    \optionB{A view of the component-and-connector viewtype.}
    \optionC{A view of the component-and-connector viewtype and a deployment view.}
    \optionD{A decomposition view, a view of the component-and-connector viewtype and a deployment view.}
 \putOptions 
\end{ClosedQuestion}
}

%11
\newcommand{\qMicroAndAmazonTwo}{
\begin{ClosedQuestion}
	Consider the following representation of Amazon's architecture (sorry for the figure's layout: \textbf{save trees})
			
	\begin{center}
		\includegraphics[width=8cm]{AmazonArchitecture}
	\end{center}
	
	What is the most relevant architecture style that is used in this figure?
	
    \optionA{Client-server to represent performance.}
    \optionB{Tiers to represent scalability.}
    \optionC{Service-oriented architecture to represent interoperability.}
    \optionD{Shared-data to represent modifiability.}
 \putOptions 
\end{ClosedQuestion}
}

%12
\newcommand{\qMicroAndAmazonThree}{
\begin{ClosedQuestion}
	In the interview Werner Vogels from Amazon gives to Jim Gray, Werner Vogels says that
	
	\begin{quote}
		The stored data formats are decoupled from the format in which you communicate data items. If there is no need for sharing schemas of the actual storage layout, you can focus on making sure that the service interfaces can evolve in a way that allows you to handle variations of data formats. 
	\end{quote}
	
	Which means that in the software architecture of Amazon's systems
			
    \optionA{The data-shared architectural style is not applied because data is encapsulated inside services.}
    \optionB{The sharing of data is done using a service-oriented architecture.}
    \optionC{Modifiability is not a concern of their architecture.}
    \optionD{The decouple of data formats does not support scalability because of the transactional properties.}
 \putOptions 
\end{ClosedQuestion}
}

% Jenkings views

%13
\newcommand{\qJenkinsOne}{
\begin{ClosedQuestion}
	Consider the following representation of the Buildbot system.
	
	\begin{center}
		\includegraphics[width=8cm]{BuildbotArchitecture}
	\end{center}
	
	The architecture style between the Buildbot Master and the Clients is:
			
    \optionA{Peer-to-peer.}
    \optionB{Shared-data where the Buildbot is the data accessor.}
    \optionC{Client-server where the Buildbot is the client.}
    \optionD{Client-server where the Buildbot is the server.}
 \putOptions 
\end{ClosedQuestion}
}

%14
\newcommand{\qJenkinsTwo}{
\begin{ClosedQuestion}
	In the Continuous Integration case can be read
	\begin{quote}
		Build notification: The outcomes of builds generally need to be communicated to interested clients, either via pull (Web, RSS, RPC, etc.) or push notification (e-mail, Twitter, etc.) This can include notification of all builds, or only failed builds, or builds that haven't been executed within a certain period.
	\end{quote}
		The architectural style used in push notifications is
			
    \optionA{Publish-subscribe.}
    \optionB{Client-server.}
    \optionC{Shared-date.}
    \optionD{Generalization.}
 \putOptions 
\end{ClosedQuestion}
}

%15
\newcommand{\qJenkinsThree}{
\begin{ClosedQuestion}
	Consider the following representation of the CDash system
	
	\begin{center}
		\includegraphics[width=8cm]{DashArchitecture}
	\end{center}
	
	The architecture style between the Dashboard and the Clients is:
			
    \optionA{Peer-to-peer.}
    \optionB{Shared-data where the Dashboard is the repository.}
    \optionC{Client-server where the Dashboard is the client.}
    \optionD{Client-server where the Dashboard is the server.}
 \putOptions 
\end{ClosedQuestion}
}



% Terceiro Mini-teste


% Module viewtype

%1
\newcommand{\qModuleViewtypeOne}{
\begin{ClosedQuestion}
	Consider the Decomposition architectural style of the Module viewtype
		
    \optionA{Its main goal is to establish the reusability qualities of the architecture.}
    \optionB{Project managers are not interested in views that use this style because it lacks the necessary level of detail.}
    \optionC{Incremental development is a criteria that drives the design of views of this type.}
    \optionD{There should be at least one view of the system using this architectural style.}
 \putOptions 
\end{ClosedQuestion}
}

%2
\newcommand{\qModuleViewtypeTwo}{
\begin{ClosedQuestion}
	Consider the Uses architectural style of the Module viewtype
		
    \optionA{Cycles in the uses relation between modules are a good sign, because it indicates that several modules should be tested together.}
    \optionB{The project manager uses this view to get advice on the incremental development of the system.}
    \optionC{The uses relation should be applied to the coarse-grained modules, because it allows to identify circular dependences.}
    \optionD{There isn't any relation with the layered architectural style because the allowed-to-use relation is more generic.}
 \putOptions 
\end{ClosedQuestion}
}

%3
\newcommand{\qModuleViewtypeThree}{
\begin{ClosedQuestion}
	Consider the Layered architectural style of the Module viewtype
		
    \optionA{The modules inside a layer cannot use other modules in the same layer.}
    \optionB{A layer cannot call the layer above.}
    \optionC{Each layer defines a virtual machine because it provides a set of cohesive functionalities to the upper layer.}
    \optionD{It is possible to have a circular allowed-to-use relationship between several layers.}
 \putOptions 
\end{ClosedQuestion}
}

% Continuous Integration

%4
\newcommand{\qContinuousIntegrationOne}{
\begin{ClosedQuestion}
	In the Continuous Integration case study can be read
	
	\begin{quote}
		The space of architectures for continuous integration systems seems to be dominated by two extremes: master/slave architectures, in which a central server directs and controls remote builds; and reporting architectures, in which a central server aggregates build reports contributed by clients. All of the continuous integration systems of which we are aware have chosen some combination of features from these two architectures.
	\end{quote}
	
	The tactic that is referred in both architectures is
		
    \optionA{Passive redundancy.}
    \optionB{Active redundancy.}
    \optionC{Voting.}
    \optionD{Maintain multiples copies of computation.}
 \putOptions 
\end{ClosedQuestion}
}

%5
\newcommand{\qContinuousIntegrationTwo}{
\begin{ClosedQuestion}
	In the Continuous Integration case study can be read
	
	\begin{quote}
		External resource coordination: Integration tests may depend on non-local resources such as a staging database or a remote web service. The CI system may therefore need to coordinate builds between multiple machines to organize access to these resources.
	\end{quote}
	
	The referred tactic is
		
    \optionA{Schedule resources.}
    \optionB{Introduce concurrency.}
    \optionC{Tailor interface.}
    \optionD{Increase resources.}
 \putOptions 
\end{ClosedQuestion}
}

%6
\newcommand{\qContinuousIntegrationThree}{
\begin{ClosedQuestion}
	In the Continuous Integration case study can be read
	
	\begin{quote}
		It takes advantage of the JUnit XML standard for unit test and code coverage reporting to integrate reports from a variety of test tools.
	\end{quote}
	
	The referred quality is
		
    \optionA{Interoperability.}
    \optionB{Usability.}
    \optionC{Performance.}
    \optionD{Modifiability.}
 \putOptions 
\end{ClosedQuestion}
}

% Infinspan

%7
\newcommand{\qInfinispanOne}{
\begin{ClosedQuestion}
	The Infinispan system can be used as a library, in which case it is embedded into a Java application, or as a server, in which case it is a remote data grid.
		
    \optionA{The library approach allows non-java applications.}
    \optionB{The server approach can scale independently of the number of applications.}
    \optionC{The server approach implements a local cache.}
    \optionD{The library approach does not build a cluster.}
 \putOptions 
\end{ClosedQuestion}
}

%8
\newcommand{\qInfinispanTwo}{
\begin{ClosedQuestion}
	In the Infinispan case study can be read
	
	\begin{quote}
		This allows applications to theoretically address an unlimited amount of in-memory storage as nodes are added to the cluster, increasing overall capacity.
	\end{quote}
	
	The quality that is referred is
		
    \optionA{Modifiability.}
    \optionB{Availability.}
    \optionC{Performance.}
    \optionD{Scalability.}
 \putOptions 
\end{ClosedQuestion}
}

%9
\newcommand{\qInfinispanThree}{
\begin{ClosedQuestion}
	In the Infinispan case study can be read
	
	\begin{quote}
		Before putting data on the network, application objects need to be serialized into bytes so that they can be pushed across a network, into the grid, and then again between peers. The bytes then need to be de-serialized back into application objects, when read by the application. In most common configurations, about 20\% of the time spent in processing a request is spent in serialization and de-serialization.
	\end{quote}
	
	The above description can motivate a scenario for
		
    \optionA{Performance.}
    \optionB{Availability.}
    \optionC{Modifiability.}
    \optionD{Reliability.}
 \putOptions 
\end{ClosedQuestion}
}


% Component-and-Connector viewtype

\newcommand{\qComponentAndConnectorOne}{
\begin{ClosedQuestion}
	Consider the Component-and-Connector viewtype
		
    \optionA{A component cannot be decomposed into a set of components and connectors.}
    \optionB{A connector cannot be decomposed into a set of components and connectors.}
    \optionC{A connector embodies a communication protocol.}
    \optionD{A component can only have a single type of port.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorTwo}{
\begin{ClosedQuestion}
	Consider the Component-and-Connector viewtype
		
    \optionA{A component is an instance and a view can have several instances of the same component type.}
    \optionB{A component type is made of a single architectural style.}
    \optionC{Only components can be associated with application-specific types.}
    \optionD{A component-and-connector view can only use a single architectural style.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qComponentAndConnectorThree}{
\begin{ClosedQuestion}
	Consider the two following views
	
	\begin{center}
		\includegraphics[width=10cm]{pipes-and-filters}
	\end{center}
	
		
    \optionA{The Merge component executes the module merge.}
    \optionB{The Merge component executes the modules merge and stdio.}
    \optionC{The module main is executed in the Merge component.}
    \optionD{The Pipe connectors do not execute any module.}
 \putOptions 
\end{ClosedQuestion}
}


% Component-and-Connector Styles

\newcommand{\qCCStyleOne}{
\begin{ClosedQuestion}
	When describing their system people refer to a part of it as containing a database server. Applying the component-and-connector styles learned in the course we can say that this system uses

    \optionA{A client-server style.}
    \optionB{A shared-data style.}
    \optionC{Both, client-server and shared-data styles.}
    \optionD{A blackboard style.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qCCStyleTwo}{
\begin{ClosedQuestion}
	Consider the peer-to-peer architectural style
		
    \optionA{All the peers are equal.}
    \optionB{Any peer can access any other peer.}
    \optionC{Peers are only used to share files.}
    \optionD{The interaction between peers is symmetric.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qCCStyleThree}{
\begin{ClosedQuestion}
	Consider the shared-data style. Which of the following qualities does it support?

    \optionA{Modifiability, because the Data Accessors do not depend on the data model.}
    \optionB{Scalability of read requests, because it is easy add more repositories to where reads are distributed, though there may be some level of inconsistency.}
    \optionC{Scalability of write requests, because a transactional system will synchronize the writes among the several repositories.}
    \optionD{Confidentially of data, because it can be replicated in several repositories.}
 \putOptions 
\end{ClosedQuestion}
}


% Segundo Mini-teste

% Performance scenarios and tactics

%1
\newcommand{\qPerformanceOne}{
\begin{ClosedQuestion}
	Consider a scenario for performance where the arrival of events is stochastic with a distribution where there are peeks of events but the arrival of events over a long period is uniform. The best tactic to apply is
		
    \optionA{Manage sampling rate.}
    \optionB{Limit event response.}
    \optionC{Prioritize events.}
    \optionD{Bound execution time.}
 \putOptions 
\end{ClosedQuestion}
}

%2
\newcommand{\qPerformanceTwo}{
\begin{ClosedQuestion}
	The two basic contributors for the response time are the processing time and the blocking time. Which tactic for performance may reduce the blocking time
		
    \optionA{Manage sampling rate.}
    \optionB{Limit event response.}
    \optionC{Prioritize events.}
    \optionD{Maintain multiple copies of computation.}
 \putOptions 
\end{ClosedQuestion}
}

%3
\newcommand{\qPerformanceThree}{
\begin{ClosedQuestion}
	Jeff Atwood wrote an article in its blog about performance of software systems that is entitled, \emph{Hardware is Cheap, Programmers are Expensive}. Which performance tactic(s) is he suggesting
		
    \optionA{Increase resource efficiency.}
    \optionB{Increase resources.}
    \optionC{Increase resource efficiency and Increase resources.}
    \optionD{Increase resources and Maintain multiple copies of computation.}
 \putOptions 
\end{ClosedQuestion}
}

% Modiafiability scenarios and tactics

%4
\newcommand{\qModifiabilityOne}{
\begin{ClosedQuestion}
	The modifiability tactic Use an Intermediary between two modules
		
    \optionA{Has as main goal the reduction of the modules' size.}
    \optionB{Results in the creation of a third module that does not have to change when any of the original modules are changed.}
    \optionC{Increases the cohesion between the two modules.}
    \optionD{Cannot be used together with the Reduce Overhead performance tactic.}
 \putOptions 
\end{ClosedQuestion}
}

%5
\newcommand{\qModifiabilityTwo}{
\begin{ClosedQuestion}
	Consider the following scenario: \emph{A system administrator simultaneously launches several instances of the system, each one using a different database, and is able to do it in less than 10 minutes.}
		
    \optionA{This is a performance scenario because the stimulus is an input, \emph{launches several instances of the system}.}
    \optionB{This is a modifiability scenario which has a defer binding tactic.}
    \optionC{This is not a modifiability scenario because the source of the stimulus cannot be a system administrator.}
    \optionD{This is a modifiability scenario and its environment design time.}
 \putOptions 
\end{ClosedQuestion}
}

%6
\newcommand{\qModifiabilityThree}{
\begin{ClosedQuestion}
	Consider the modifiability quality and the cost of change.
		
    \optionA{A low cost of change may imply a high cost of development.}
    \optionB{A low cost of change implies a low cost of development, because changing the code is part of development.}
    \optionC{There is no relation between the cost of change and the cost of development.}
    \optionD{A high cost of change occurs if it is necessary to defer the binding of what needs to be changed.}
 \putOptions 
\end{ClosedQuestion}
}

% From business goals to architectural tactics and design

\newcommand{\qBusinessToDesignOne}{
\begin{ClosedQuestion}
	The Attribute-Driven Design method is characterized by 
		
    \optionA{In each iteration one or more architecturally significant requirements are used to decompose a software element of the system design.}
    \optionB{The architect cannot backtrack the decomposition decisions she made.}
    \optionC{During the design process the number of architecturally significant requirements cannot change.}
    \optionD{Contraints cannot be used as requirements for the decomposition process.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qBusinessToDesignTwo}{
\begin{ClosedQuestion}
	Architecturally significant requirements (ASR) are captured in a utility tree where each one of the ASRs are classified in terms of its architectural impact and business value.
		
    \optionA{Only the scenarios that have high architectural impact and high business value should appear in the tree.}
    \optionB{A scenario for a power outage should have a low business value because the fault is temporary.}
    \optionC{A scenario for a 24 hours x 7 days availability of the system should appear as a leaf of the utility tree.}
    \optionD{The utility tree covers all the significant qualities the system has to address.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qBusinessToDesignThree}{
\begin{ClosedQuestion}
	It was decided that the Fnix system should be based on open-source software.
		
    \optionA{This decision does not have any impact on the architecture.}
    \optionB{This decision corresponds to a constraint requirement.}
    \optionC{This decision needs to be made concrete by an interoperability scenario.}
    \optionD{This decision is not a consequence of the Fnix business case.}
 \putOptions 
\end{ClosedQuestion}
}

% Graphite

\newcommand{\qGraphiteOne}{
\begin{ClosedQuestion}
	Consider the following fragment in the description of the Graphite system:
	
	\begin{quote}
		The Graphite webapp allows users to request custom graphs with a simple URL-based API. Graphing parameters are specified in the query-string of an HTTP GET request, and a PNG image is returned in response. 
	\end{quote}
		
    \optionA{It describes a performance scenario where the stimulus is the request of a custom graph.}
    \optionB{The scenario is supported by a manage sampling rate tactic because several requests to the same graph return the same result.}
    \optionC{It describes a usability scenario where the source of stimulus is a non-technical user.}
    \optionD{A support user initiative tactic based on the definition of a language is used to achieve this scenario.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qGraphiteTwo}{
\begin{ClosedQuestion}
	Consider the following fragment in the description of the Graphite system:
	
	\begin{quote}
		To avoid this kind of catastrophe, I added several features to carbon including configurable limits on how many data points can be queued and rate-limits on how quickly various whisper operations can be performed. These features can protect carbon from spiraling out of control and instead impose less harsh effects like dropping some data points or refusing to accept more data points. However, proper values for those settings are system-specific and require a fair amount of testing to tune. They are useful but they do not fundamentally solve the problem. For that, we'll need more hardware.
	\end{quote}
	
	The performance tactics referred in the above description are:
		
    \optionA{Bound execution times, bound queue sizes, and increase resources.}
    \optionB{Bound execution times, and increase resources.}
    \optionC{Manage sampling rate, bound queue sizes, and increase resources.}
    \optionD{Bound queue sizes, and increase resources.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qGraphiteThree}{
\begin{ClosedQuestion}
	Consider the following fragment in the description of the Graphite system:
	
	\begin{quote}
		Imagine that you have 60,000 metrics that you send to your Graphite server, and each of these metrics has one data point per minute. Remember that each metric has its own whisper file on the filesystem. This means carbon must do one write operation to 60,000 different files each minute. As long as carbon can write to one file each millisecond, it should be able to keep up. This isn't too far fetched, but let's say you have 600,000 metrics updating each minute, or your metrics are updating every second, or perhaps you simply cannot afford fast enough storage. Whatever the case, assume the rate of incoming data points exceeds the rate of write operations that your storage can keep up with. How should this situation be handled?
	\end{quote}
			
    \optionA{It describes a reliability scenario because the data points for each metric will be split between a buffer and disk.}
    \optionB{It describes a performance scenario for the execution of reads.}
    \optionC{The tactic used to solve the problem is based in the fact that data points are appended to the end of the metric file.}
    \optionD{The tactic used to solve the problem is not manage sampling rate because there isn't any loss of data points.}
 \putOptions 
\end{ClosedQuestion}
}

% Nginx

\newcommand{\qNginxOne}{
\begin{ClosedQuestion}
	Consider the following fragment in the description of the nginx case study.
	
	\begin{quote}
		nginx's configuration system was inspired by Igor Sysoev's experiences with Apache. His main insight was that a scalable configuration system is essential for a web server. The main scaling problem was encountered when maintaining large complicated configurations with lots of virtual servers, directories, locations and datasets. In a relatively big web setup it can be a nightmare if not done properly both at the application level and by the system engineer himself.
	\end{quote}
			
    \optionA{It describes an availability scenario because the configuration allows to define redundant virtual servers.}
    \optionB{It describes a scalability scenario because it is possible to increment the size of the configuration at a linear cost.}
    \optionC{It describes a usability scenario where the stimulus is reduce the number of errors when configuring the system.}
    \optionD{It describes a modifiability scenario because of the cost associated with maintaining the configuration.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qNginxTwo}{
\begin{ClosedQuestion}
	In the description of the nginx case study we can read:
	
	\begin{quote}
		nginx is event-based, so it does not follow Apache's style of spawning new processes or threads for each web page request. The end result is that even as load increases, memory and CPU usage remain manageable. nginx can now deliver tens of thousands of concurrent connections on a server with typical hardware.
	\end{quote}
	
	The tactic nginx follows to achieve tens of thousands of concurrent connections is
			
    \optionA{Introduce concurrency.}
    \optionB{Increase resources.}
    \optionC{Schedule resources.}
    \optionD{Maintain multiple copies of computation.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qNginxThree}{
\begin{ClosedQuestion}
	In the description of the nginx case study we can read:
	
	\begin{quote}
		nginx's modular architecture generally allows developers to extend the set of web server features without modifying the nginx core. nginx modules come in slightly different incarnations, namely core modules, event modules, phase handlers, protocols, variable handlers, filters, upstreams and load balancers. At this time, nginx doesn't support dynamically loaded modules; i.e., modules are compiled along with the core at build stage.
	\end{quote}
	
	The above sentence corresponds to
			
    \optionA{A security scenario because it allows the introduction of filters to encrypt the messages.}
    \optionB{A availability scenario because it allows the introduction of load balancers.}
    \optionC{A modifiability scenario where defer binding occurs at compile time.}
    \optionD{A usability scenario because developers can extend the system without having to modify the nginx core.}
 \putOptions 
\end{ClosedQuestion}
}


% Primeiro Mini-Teste

% The role of the architect

%1
\newcommand{\qPragmaticArchitect}{
\begin{ClosedQuestion}
	According to Frank Buschmann in the article \emph{Introducing the Pragmatic Architect}
		
    \optionA{The business aspects of the system are for business architects, not the software architects.}
    \optionB{Dealing with the technological aspects of the system should be delayed to the implementation stage of development.}
    \optionC{The modeling of a system is not part of the software architect duties.}
    \optionD{The level of abstraction of the system an architect works may vary.}
 \putOptions 
\end{ClosedQuestion}
}

%2
\newcommand{\qArchitecturalInfluenceCycle}{
\begin{ClosedQuestion}
	Suppose that after designing a successful architecture for a particular client the software house management decides to create a cross-functional internal department to start providing products for this particular segment of the market.
		
    \optionA{This is a case of an architectural influence cycle where the feedback cycle resulted in changes on the business.}
    \optionB{This is a case of an architectural influence cycle where the feedback cycle resulted in changes on the project.}
    \optionC{This is a case of an architectural influence cycle where the feedback cycle resulted in changes on the business and project.}
    \optionD{This is a case of an architectural influence cycle without feedback.}
 \putOptions 
\end{ClosedQuestion}
}

%3
\newcommand{\qDiplomat}{
\begin{ClosedQuestion}
	Very often, when a software architecture is being designed, conflicting requirements are identified, like between security and availability. The role of the software architect is to
		
    \optionA{Design an architectural solution together with the stakeholders to be sure that everybody agrees on the resolution of conflicts.}
    \optionB{Solve the conflicts between requirements by deciding on the best trad-offs the system should support.}
    \optionC{Facilitate the communication among the stakeholders such that they can decide on what are the architecturally significant requirements.}
    \optionD{Design an architecture that supports all the conflicting requirements and present it to the stakeholders.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qDiplomatPT}{
\begin{ClosedQuestion}
	Frequentemente, quando uma arquitetura de software  desenhada, so identificados requisitos conflituosos, como seja entre segurana e disponibilidade. O papel da arquitetura de software 
		
    \optionA{Desenhar uma soluo arquitetural conjuntamente com os \emph{stakeholders} para ter a certeza que todas as partes concordam com a resoluo de conflitos.}
    \optionB{Resolver os conflitos entre os requisitos decidindo quais os compromissos que o sistema deve suportar.}
    \optionC{Facilitar a comunicao entre os \emph{stakeholders} de forma a que eles decidam quais so os requisitos arquiteturalmente relevantes.}
    \optionD{Desenhar uma arquitetura que suporta todos os requisitos conflituosos e apresent-la aos \emph{stakeholders}.}
 \putOptions 
\end{ClosedQuestion}
}

% The Software Architecture

%4
\newcommand{\qEarlydDecisions}{
\begin{ClosedQuestion}
	In his article \emph{Who Needs an Architect?} Martin Fowler refers to the following architecture definition
		
	\begin{quote}
		\emph{architecture is the set of design decisions that must be made early in a project}
	\end{quote}

    \optionA{Martin Fowler disagrees with this definition because we should delay the design decisions and focus on features first.}
    \optionB{Martin Fowler complains about this definition because the early decisions are not necessarily the right ones.}
    \optionC{Martin Fowler complains about this definition because architecture should stress flexibility which can only be necessary later.}
    \optionD{Martin Fowler disagrees with this definition because to design an architecture it is not necessary to make any decision.}
 \putOptions 
\end{ClosedQuestion}
}

%5
\newcommand{\qSharedUnderstanding}{
\begin{ClosedQuestion}
	In his article \emph{Who Needs an Architect?} Martin Fowler refers to the following architecture definition
		
	\begin{quote}
		\emph{the expert developers working on that project have a shared understanding of the system design}
	\end{quote}

    \optionA{This shared understanding can be represented by a set of architectural views.}
    \optionB{This shared understanding includes the architecturally significant requirements.}
    \optionC{The system algorithms should be part of the shared understanding.}
    \optionD{The shared understanding describes the system from a high-level perspective.}
 \putOptions 
\end{ClosedQuestion}
}

%6
\newcommand{\qASDefinition}{
\begin{ClosedQuestion}
	The definition of software architecture, on the course book, is
	\begin{quote}
		\emph{The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both.}
	\end{quote}
	
	According to this definition

    \optionA{The set of structures is needed to support different levels of performance for the system.}
    \optionB{To reason about a system is to verify whether the architecturally significant requirements are considered by the architecture.}
    \optionC{The hardware is an example of a software element.}
    \optionD{There isn't any relation between the properties of the software elements and the ability to reason about the system.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qASDefinitionPT}{
\begin{ClosedQuestion}
	A definio da arquitetura de software no livro 
	\begin{quote}
		\emph{The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both.}
	\end{quote}
	
	De acordo com esta definio

    \optionA{Um conjunto de estruturas  necessrio para suportar os diferentes nveis de desempenho do sistema.}
    \optionB{Raciocinar acerca do sistema  verificar se os requisitos arquiteturalmente relevantes so considerados pela arquitetura.}
    \optionC{O hardware  um exemplo de um elemento de software.}
    \optionD{No existe nenhuma relao entre as propriedades dos elementos de software e a capacidade de raciocinar acerca do sistema.}
 \putOptions 
\end{ClosedQuestion}
}

% Architectures for scalable web applications

%7
\newcommand{\qImageHostingPerformance}{
\begin{ClosedQuestion}
	Consider the following informal view of an Image Hosting System
	
\begin{center}
	\includegraphics[width=10cm]{ImageHostingPerformance}
\end{center}

    \optionA{This view highlights the availability of the system.}
    \optionB{This view highlights the performance of the \texttt{Image File Storage}.}
    \optionC{This view highlights the different performance levels for \texttt{upload} and \texttt{dowload} operations.}
    \optionD{This view highlights the scalability of \texttt{upload} and \texttt{dowload} operations.}
 \putOptions 
\end{ClosedQuestion}
}

%8
\newcommand{\qImageHostingScalability}{
\begin{ClosedQuestion}
	Consider the following informal view of an Image Hosting System
	
\begin{center}
	\includegraphics[width=10cm]{ImageHostingScalability}
\end{center}

    \optionA{This view highlights the security of the system.}
    \optionB{This view highlights the scalability of \texttt{upload} and \texttt{dowload} operations.}
    \optionC{This view highlights the scalability of storage.}
    \optionD{This view highlights the scalability of \texttt{upload} and \texttt{dowload} operations, and of storage.}
 \putOptions 
\end{ClosedQuestion}
}

%9
\newcommand{\qImageHostingReads}{
\begin{ClosedQuestion}
	Consider the following informal view of an Image Hosting System
	
\begin{center}
	\includegraphics[width=10cm]{ImageHostingReads}
\end{center}

    \optionA{This view highlights the availability of the \texttt{Image File Storage}.}
    \optionB{This view highlights the performance of the \texttt{download} operations.}
    \optionC{This view highlights the performance of \texttt{upload} operations.}
    \optionD{This view highlights the scalability of \texttt{upload} and \texttt{dowload} operations.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qImageHostingReadsPT}{
\begin{ClosedQuestion}
	Considere a seguinte vista informal de um Image Hosting System
	
\begin{center}
	\includegraphics[width=10cm]{ImageHostingReads}
\end{center}

    \optionA{Esta vista d relevncia  disponibilidade do \texttt{Image File Storage}.}
    \optionB{Esta vista d relevncia ao desempenho das operaes de \texttt{download}.}
    \optionC{Esta vista d relevncia ao desempenho das operaes de \texttt{upload}.}
    \optionD{Esta vista d relevncia  escalabilidade das operaes de \texttt{upload} e \texttt{dowload}.}
 \putOptions 
\end{ClosedQuestion}
}

% Requirements

%10
\newcommand{\qGeneralScenario}{
\begin{ClosedQuestion}
	A general scenario for a quality attribute

    \optionA{Should be avoided because scenarios should describe very concrete situations.}
    \optionB{Enumerates, for each kind of quality attribute, all the possible types of source of stimulus, stimulus, etc.}
    \optionC{Can omit some of the elements like, for instance, the environment, if they are not relevant for the general scenario.}
    \optionD{Is a very reusable scenario that can be used in many different concrete situations.}
 \putOptions 
\end{ClosedQuestion}
}

%11
\newcommand{\qInteroperabilityStimulus}{
\begin{ClosedQuestion}
	In a scenario for interoperability

    \optionA{The exchange of information is the stimulus.}
    \optionB{The request to adapt an interface is the stimulus.}
    \optionC{The design of a reusable interface is the stimulus.}
    \optionD{The data input to the system is the stimulus.}
 \putOptions 
\end{ClosedQuestion}
}

%12
\newcommand{\qRequirementsImpact}{
\begin{ClosedQuestion}
	The requirements impact on how an architecture is designed

    \optionA{However, functional requirements do not have any impact on the architecture because the systemic qualities of an architecture are non-functional.}
    \optionB{The functional requirements have a large impact on the definition of views of the component-and-connector viewtype because each component executes a functionality.}
    \optionC{The functional requirements have a large impact on the definition of views of the module viewtype because they are used to define the high cohesion and low coupling of modules.}
    \optionD{The functional requirements can be considered as constraints on the software architecture design.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qRequirementsImpactPT}{
\begin{ClosedQuestion}
	Os requisitos tm um impacto sobre como a arquitetura  desenhada

    \optionA{Contudo, os requisitos funcionais no tm nenhum impacto na arquitetura pois as qualidades sistmicas de uma arquitetura so no funcionais.}
    \optionB{Os requisitos funcionais tm um grande impacto na definio tipo vista componente-e-conetor porque cada componente executa uma funcionalidade.}
    \optionC{Os requisitos funcionais tm uma grande impactos na definio de vistas do tipo vista mdulo porque elas so usadas para definir a coeso forte e a ligao fraca.}
    \optionD{Os requisitos funcionais podem ser considerados como as restries sobre o desenho da arquitetura de software.}
 \putOptions 
\end{ClosedQuestion}
}

% Availability scenarios and tactics

%13
\newcommand{\qOmissionRetry}{
\begin{ClosedQuestion}
	Considering the availability architectural quality, the tactic of retry

    \optionA{Can be applied to any kind of availability scenario.}
    \optionB{Is useful to support scenarios where the stimulus is an omission.}
    \optionC{Guarantees that the system will not become unavailable.}
    \optionD{Reduces the availability scenario response time because the request occurs twice.}
 \putOptions 
\end{ClosedQuestion}
}

%14
\newcommand{\qPingEchoHeartbeat}{
\begin{ClosedQuestion}
	Considering the availability architectural quality and the tactics of ping/echo and heartbeat

    \optionA{These tactics cannot not be applied in conjunction with the self-test tactic.}
    \optionB{These tactics are used to prevent the occurrence of a fault.}
    \optionC{Heartbeat is more scalable than ping/echo because the monitor does not need to know in advance the addresses of the components.}
    \optionD{In ping/echo the components have the initiative to start the interaction.}
 \putOptions 
\end{ClosedQuestion}
}

%15
\newcommand{\qRestartInRedundancy}{
\begin{ClosedQuestion}
	Considering the availability architectural quality and the tactics of active redundancy, passive redundancy, and spare

    \optionA{Active redundancy can be used together with a voting tactic to detect and recover from faults.}
    \optionB{These tactics are used to prevent the occurrence of a fault.}
    \optionC{Spare guarantees immediate recover.}
    \optionD{Passive redundancy does not work with non-deterministic behavior of request's execution.}
 \putOptions 
\end{ClosedQuestion}
}

\newcommand{\qRestartInRedundancyPT}{
\begin{ClosedQuestion}
	Considerando a qualidade arquitetural da disponibilidade e as tticas de redundncia ativa, redundncia passiva e substituio

    \optionA{A redundncia ativa pode ser usada conjuntamente com uma ttica de votao para detectar e recuperar de faltas.}
    \optionB{Estas tticas so usadas para prevenir a ocorrncia de faltas.}
    \optionC{Substituio garante recuperao imediata.}
    \optionD{Redundncia passiva no funciona com comportamento no determinista durante a execuo.}
 \putOptions 
\end{ClosedQuestion}
}


%% =========================================================================
%% exams 2014/2015
%% =========================================================================

% Primeiro Exame

%1 Architecture Influence Cycle - REUSED
\newcommand{\qArchitectureInfluenceCycle}{
\begin{ClosedQuestion}
  The software architecture of a system

    \optionA{Depends mostly on the system's functional requirements.}
    \optionB{Depends more on the architect's experience than on anything
    else.}
    \optionC{Should not depend on the skills of the developing team.}
    \optionD{Is driven by a trade-off among the stakeholders needs.}
 \putOptions 
\end{ClosedQuestion}
}


%2 Pragmatic Architect
\newcommand{\qTechoGeeks}{
\begin{ClosedQuestion}
	Frank Buschmann, \emph{Introducing the Pragmatic Architect}, defines the \emph{techno-geeks} architects. This kind of architect
	
    \optionA{May be responsible for the Featuritis problems of architectures.}
    \optionB{May be responsible for the Performitis problems of architectures.}
    \optionC{Is focused on creating common generalizations of several systems.}
    \optionD{Is focused on the details of the architecture.}
 \putOptions
\end{ClosedQuestion}
}


%3 Featuritis Performitis Flexibilities
\newcommand{\qFeaturitisOrderPad}{
\begin{ClosedQuestion}
	Frank Buschmann states that:
		
	\begin{quote}
		Featuritis is the tendency to trade functional coverage for quality - the more functions the earlier they're delivered, the better.
	\end{quote}
	
	In the OrderPad system the architect regretted not getting performance tests going earlier. The OrderPad system

    \optionA{Suffered from featuritis, because the architect decided to delay the difficult parts for latter in the development.}
    \optionB{Did not suffer from featuritis.}
    \optionC{Suffered from some level of featuritis, but it allowed to have a pilot from which the team learned.}
    \optionD{Suffered from featuritis, but it had no impact on the final development.}
 \putOptions 
\end{ClosedQuestion}
}

%4 Architecture Definition - REUSED
\newcommand{\qArchitectureDefinition}{
\begin{ClosedQuestion}
  The software architecture of a system

  \optionA{Is a high-level view of the system with the purpose of
  understanding what are the system's goals and features.}
  \optionB{Is composed of things such as code units, runtime elements,
  hardware, and people, together with the relationships among them.}
  \optionC{Is a set of guidelines that the developing team should
  follow in the development of the system.}
  \optionD{Is a set of diagrams that show the runtime elements of the
  system and their relationships.}
 \putOptions 
\end{ClosedQuestion}
}

%5 Module vs Component - REUSED
\newcommand{\qModuleComponent}{
\begin{ClosedQuestion}
  Which of the following phrases best describe the relationship
  between modules and components?

  \optionA{A module may contain code from different components.}
  \optionB{A component may execute code from different modules.}
  \optionC{A module may execute code from different components.}
  \optionD{A component may contain code from different modules.}
 \putOptions 
\end{ClosedQuestion}
}

%6 Scenarios and Tactics
\newcommand{\qScenario}{
\begin{ClosedQuestion}
	Consider the following scenario
	
	\begin{quote}
		Our vehicle information system send our current location to the traffic monitoring system. The traffic monitoring system combines our location with other information, overlays this information on a Google Map, and broadcasts it. Our location information is correctly included with a probability of 99.99\%.
	\end{quote}
	
    \optionA{The current location is the source of the stimulus.}
    \optionB{The traffic monitoring system is the environment.}
    \optionC{The Google Map is the artefact.}
    \optionD{The location information is correctly included with a probability of 99.99\% is the response measure.}
 \putOptions
\end{ClosedQuestion}
}

%7 Availability
\newcommand{\qChecksum}{
\begin{ClosedQuestion}
	Checksum is a technic that it is often used in architectural design. It can be used as
		
    \optionA{A Condition Monitoring tactic for the Availability quality.}
    \optionB{An Encrypt Data tactic for the Security quality.}
    \optionC{A Verify Message Integrity tactic to React to Attacks for the Security quality.}
    \optionD{An Exception Prevention tactic to Prevent Faults for the Availability quality.}
 \putOptions
\end{ClosedQuestion}
}

%8 Security
\newcommand{\qAttack}{
\begin{ClosedQuestion}
	An attack is
		
    \optionA{The source of stimulus for scenarios of the Availability quality.}
    \optionB{The stimulus for scenarios of the Availability quality.}
    \optionC{The stimulus for scenarios of the Security quality.}
    \optionD{The source of stimulus for scenarios of the Security quality.}
 \putOptions
\end{ClosedQuestion}
}

%9 SocialCal Scenarios and Tactics
\newcommand{\qSocialCalcTactics}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		As the user scrolls the spreadsheet through our custom-drawn scroll bars, we dynamically update the innerHTML of the pre-drawn \textsc{<td>} elements. This means we don't need to create or destroy any \textsc{<tr>} or \textsc{<td>} elements in many common cases, which greatly speeds up response time.
	\end{quote} 
	
	This corresponds to the application of

    \optionA{Manage sampling rate tactic.}
    \optionB{Increase resource efficiency tactic.}
    \optionC{Introduce concurrency tactic.}
    \optionD{Schedule resources tactic.}
 \putOptions
\end{ClosedQuestion}
}

%10 Thounsand Parsec Scenarios and Tactics
\newcommand{\qThousandParsecTactics}{
\begin{ClosedQuestion}
	In the description of the Thousand Parsec case study can be read:
	
	\begin{quote}
		A ruleset designer thus has the ability to create new object types or store additional information in the existing object types as required by the ruleset, allowing for virtually unlimited extensibility in terms of the available physical objects in the game.
	\end{quote} 
	
	This excerpt can be represented as a modifiability scenario where

    \optionA{The source of stimulus is the ruleset.}
    \optionB{The ruleset designer is the stimulus.}
    \optionC{The environment is design time.}
    \optionD{The response is defer binding.}
 \putOptions
\end{ClosedQuestion}
}

%11 Git and GitHub Scenarios and Tactics
\newcommand{\qGitTactics}{
\begin{ClosedQuestion}
	In the description of the Git case study can be read:
	
	\begin{quote}
		Git tackles the storage space problem by packing objects in a compressed format, using an index file which points to offsets to locate specific objects in the corresponding packed file.
	\end{quote}
	
	The tactic addressed in this fragments is:
	
    \optionA{Schedule resources.}
    \optionB{Condition monitoring.}
    \optionC{Reduce overhead.}
    \optionD{Increase resource efficiency.}
 \putOptions
\end{ClosedQuestion}
}


%12 Designing-an-Architecture - REUSED
\newcommand{\qDesigningArchitecture}{
\begin{ClosedQuestion}
  The architectural significant requirements are important in the process of creating
  the software architecture for a system because they define
 
  \optionA{The most important requirements (both functional and
  qualities) that the system must achieve.}
  \optionB{How the components manage the communication between the
  remaining elements in the system.}
  \optionC{The stakeholders that drive the development of the system.}
  \optionD{The tactics that satisfy the most important requirements for
  the system.}
 \putOptions 
\end{ClosedQuestion}
}

%13 Module Viewtype - REUSED
\newcommand{\qDecompositionGeneralization}{
\begin{ClosedQuestion}
  Consider that a chess game should
  provide an automatic and intelligent chess player, and that to
  implement that player we will use some of the many chess engines
  already available in the market.  Moreover, the system should allow
  the user to choose which engine to use for each new game.  Given
  these requirements, which of the architectural styles from the
  module viewtype are best suited to satisfy them?
 
  \optionA{The Decomposition style.}
  \optionB{The Decomposition and Uses styles.}
  \optionC{The Layered style.}
  \optionD{The Generalization and Decomposition styles.}
 \putOptions 
\end{ClosedQuestion}
}

%14 Uses and Generalization architectural styles - REUSED
\newcommand{\qUsesStyle}{
\begin{ClosedQuestion}
  To achieve a faster time-to-market, software companies are
  increasingly using a strategy of incremental releases of their
  software, where each new release has a set of new features.  Which
  architectural style is better to analyse whether the system's
  software architecture is adequate for the planned incremental
  releases?
 
  \optionA{The Decomposition style.}
  \optionB{The Deployment style.}
  \optionC{The Uses style.}
  \optionD{The Work-assignment style.}
 \putOptions 
\end{ClosedQuestion}
}

%15 Layered, Aspects and Data Model - REUSED
\newcommand{\qLayered}{
\begin{ClosedQuestion}
  Assume that one of the requirements for a graphical chess game is
  that it should be able to run both in Microsoft's Windows and
  Apple's Mac OS X operating systems.  A good solution for this system
  would:

  \optionA{Create a decomposition where there is a module corresponding
  to the Windows OS and another one for the Mac OS X, each one
  responsible for containing the OS-specific code.}
  \optionB{Use a classic 3-layer architecture with the following
  layers, from top to bottom: Presentation, Domain Logic, and Data
  Access.}
  \optionC{Use an aspect-oriented architecture, where an aspect is used to generate a graphical interface.}
  \optionD{Use two deployment views, each one allocating different
  components to different machines with different operating systems.}
 \putOptions 
\end{ClosedQuestion}
}

%16 Component and Connector
\newcommand{\qInterfaceDelegation}{
\begin{ClosedQuestion}
	Consider the concept of interface delegation 
		
    \optionA{It corresponds to a particular case of a specialization in a generalization view.}
    \optionB{It represents a relation between a connector's role and a port of one of its internal components.}
    \optionC{It represents a relation between a component's port and a port of one of its internal components.}
    \optionD{It represent a relation between a component's port and a connector's role.}
 \putOptions
\end{ClosedQuestion}
}


%17 Repository and Client-Server - REUSED
\newcommand{\qRepository}{
\begin{ClosedQuestion}
  A requirement for a chess game is that it keeps a table with the best scores obtained in the game.
  Naturally, this information should be kept between two different
  executions of the system.  Assuming that the game is a web-based application, then

  \optionA{We have to use a Repository component-and-connector style.}
  \optionB{It is not necessary to use a ``Data Access'' layer because the information is simple.}
  \optionC{We must identify a module for writing the scores in a
  Decomposition style.}
  \optionD{We may assign the responsibility of writing the scores to
  another module that already has other responsibilities.}
 \putOptions 
\end{ClosedQuestion}
}

%18 Tiers, Dynamic reconfiguration, Peer-to-peer, Publish-subscribe - REUSED
\newcommand{\qPeerToPeer}{
\begin{ClosedQuestion}
  An email client such as Mozilla's Thunderbird or Microsoft's Outlook
  allows a user both to read the emails that were sent to him and to
  send new emails to other people.  To do that, the email client
  connects to other components (one or more): some of these components
  keep the user's mailboxes with all the emails that were sent to him,
  whereas other components know how to forward the emails sent by the
  user to their final destinations (associated with a new set of destinations).  In either case, it is always the
  email client that makes a request to the other components, but
  whereas in the first case the email client receives all the
  information about the user's emails, in the second case only a
  success or failure error code is returned.  The architectural
  patterns that best describe the interactions between the components from the client to the final destinations

  \optionA{Client-server in both cases.}
  \optionB{Client-server in the first case and Peer-to-peer in the second.}
  \optionC{Peer-to-peer in both cases.}
  \optionD{Peer-to-peer in the first case and Client-Server in the second.}
 \putOptions 
\end{ClosedQuestion}
}

%19 SOA, Pipes-and-Filters - REUSED
\newcommand{\qPipesFilters}{
\begin{ClosedQuestion}
	Consider that you intend to develop a system where it is necessary to change the emails received by the server (for instance, to remove potential virus or URLs for phishing sites). The goal is that each email is processed by this system before it is sent to other servers or it is stored locally. Additionally, the system should be easily modified to support new kinds of transformations. Which style is more suitable to satisfy these requirements? 

    \optionA{Peer-to-Peer.}
    \optionB{Pipe-and-Filter.}
    \optionC{Client-Server.}
    \optionD{Publish-Subscribe.}
 \putOptions
\end{ClosedQuestion}
}

%20 Allocation viewtype
\newcommand{\qInstallView}{
\begin{ClosedQuestion}
  Consider a system that will require a significative configuration effort during deployment, because it provides several variations of the same functionalities and it is necessary to choose which functionalities better fit in each case. The most helpful architectural view for this situation is
 
  \optionA{Work assignment view.}
  \optionB{Install view.}
  \optionC{Implementation view.}
  \optionD{Deployment view.}
 \putOptions
\end{ClosedQuestion}
}

%21 ThousandParsec views
\newcommand{\qThounsandParsecView}{
\begin{ClosedQuestion}
	Consider the architectural views for the ThousandParsec system. In the case description can be read:
	
	\begin{quote}
		The Requirements function verifies that each component added to the design conforms to the rules of other previously added components.
	\end{quote}
	
	The following diagram depicts a fragment of a proposal for the decomposition view of the system.
	
	\centering
	\includegraphics[width=10cm]{x-ThousandParsec-ruleset}

    \optionA{The Requirements function is part of the Design module.}
    \optionB{The Requirements function is not part of the RulesSet module.}
    \optionC{The Requirements function is part of the Objects module.}
    \optionD{The Requirements function is part of the Dynamic Design module.}
 \putOptions
\end{ClosedQuestion}
}

%22 SocialCalc Views
\newcommand{\qSocialCalcView}{
\begin{ClosedQuestion}
	Consider the architectural views for the SocialCalc system. In the case description can be read:
	
	\begin{quote}
		The save format is in standard MIME multipart/mixed format, consisting of four text/plain; charset=UTF-8 parts, each part containing newline-delimited text with colon-delimited data fields. The parts are...
		
		This format is designed to be human-readable, as well as being relatively easy to generate programmatically. This makes it possible for Drupal's Sheetnode plugin to use PHP to convert between this format and other popular spreadsheet formats, such as Excel (.xls) and OpenDocument (.ods).
	\end{quote}
	
	From the above excerpt can be inferred the need to have
	
    \optionA{A component-and-connector view using a shared-data style.}
    \optionB{A data model view.}
    \optionC{A service-oriented architecture view.}
    \optionD{A data model view and a component-and-connector view using a shared-data style.}
 \putOptions
\end{ClosedQuestion}
}

%23 Git and GitHub Views
\newcommand{\qGitViews}{
\begin{ClosedQuestion}
	The architectural style that best represents the runtime execution of a system Git installed for a small group of developers is
			
    \optionA{Peer-to-peer style.}
    \optionB{Pipe-and-Filter style.}
    \optionC{Shared-data style.}
    \optionD{Publish-subscribe style.}
 \putOptions
\end{ClosedQuestion}
}

%24 The architecture of the OrderPad
\newcommand{\qOrderPad}{
\begin{ClosedQuestion}
  In the OrderPad system they have decided to use a Row Data Gateway data access pattern because
 
  \optionA{The team did not know the FenixFramework.}
  \optionB{The domain only needs CRUD (Create, Read, Update, and Delete) operations.}
  \optionC{A domain layer is absent from the architecture.}
  \optionD{Most of the information is stored in the client.}
 \putOptions
\end{ClosedQuestion}
}

%25-28 EtherCalc - 4
\newcommand{\qEtherCalcAllocation}{
\begin{ClosedQuestion}
  Consider the architectural views of EtherCalc system. In the case study description can be read
  
  \begin{quote}
	  The Socialtext platform has both behind-the-firewall and on-the-cloud deployment options, imposing unique constraints on EtherCalc's resource and performance requirements.
  \end{quote} 
 
  \optionA{It is necessary to design two deployment views, one for each deployment option.}
  \optionB{It is necessary to design a single deployment view that contains all the variation, because only the hardware capabilities change.}
  \optionC{Two different component-and-connector views are necessary to represent the same runtime behavior of the system.}
  \optionD{The deployment options have a large impact on the work assignment view.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qEtherCalcRedundancy}{
\begin{ClosedQuestion}
  In EtherCalc initial prototype clients send their local commands and snapshots to the server, which result on redundant information on the server about the state of the spreadsheet. This redundancy is an application of
 
  \optionA{Passive redundancy for availability, because it is possible to recover from the commands log.}
  \optionB{Undo tactic for usability, because the server can undo the snapshot.}
  \optionC{Increase resource efficiency tactic for performance, because it reduces the need of upfront calculus/computation on new clients.}
  \optionD{Multiple copies of data tactic for performance, clients do not have to execute the commands.}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qEtherCalcSnapshotPerformance}{
\begin{ClosedQuestion}
  In EtherCalc initial prototype clients send their local commands, cursor movements and snapshots to the server.
 
  \optionA{The server propagates them to all the clients.}
  \optionB{The server propagates local commands and cursor movements to the clients, and keeps the snapshots for the initialization of new clients.}
  \optionC{The server only propagates local commands to the clients and keeps cursor movements in a log and the snapshots in a repository.}
  \optionD{The server propagates the snapshots and the cursor movements to the clients and store the local commands for the initialization of new clients.}
 \putOptions
\end{ClosedQuestion}
}


\newcommand{\qEtherCalcModifiabilityTestability}{
\begin{ClosedQuestion}
  In the EtherCalc case description can be read
 
  \begin{quote}
	  The in-browser SocialCalc engine is written in JavaScript. We considered translating that logic into Perl, but that would have carried the steep cost of maintaining two code bases. 
  \end{quote} 
  
  The excerpt is referring to a quality of
 
  \optionA{Testability.}
  \optionB{Modifiability.}
  \optionC{Testability and Modifiability.}
  \optionD{Performance.}
 \putOptions
\end{ClosedQuestion}
}


%29-30 Domain Logic and Access Patterns

%29 - REUSED
\newcommand{\qServiceLayer}{
\begin{ClosedQuestion}
  The Service Layer pattern is typically used in conjunction with
 
  \optionA{The Transaction Script pattern to help demarcate the
  business transactions.}
  \optionB{The Domain Model pattern to reduce the interface of the
  Domain Logic layer to a controlled set.}
  \optionC{The Data Access layer to be able to access the data that it
  needs in each service.}
  \optionD{The Table Module pattern to hide the details of the table
  structure for the Presentation layer.}
 \putOptions
\end{ClosedQuestion}
}

%30 - REUSED
\newcommand{\qActiveRecord}{
\begin{ClosedQuestion}
  The Active Record pattern is best used when we are also using
 
  \optionA{The Transaction Script pattern.}
  \optionB{The Table Module pattern.}
  \optionC{The Domain Model pattern.}
  \optionD{The Service Layer pattern.}
 \putOptions
\end{ClosedQuestion}
}

% Segundo Exame

%1 Architecture Influence Cycle - REUSED
\newcommand{\qArchitectureKnowledge}{
\begin{ClosedQuestion}
  Assuming that you were asked to document the software architecture
  of an existing (and already developed) system, the best thing for
  you to do would be

  \optionA{To analyse the source code of the system to see how it is built}
  \optionB{To analyse the system's functional requirements to see what
  is the system supposed to do}
  \optionC{To analyse the implemented set of features to see what is it
  that the system actually does}
  \optionD{To talk with the people that developed the system to know
  what they did and why they did it}
 \putOptions
\end{ClosedQuestion}
}

%2 Pragmatic Architect
\newcommand{\qArchitectureEvolution}{
\begin{ClosedQuestion}
  Ralph Johnson says that
  
  \begin{quote}
	  Architecture is the decisions that you wish you could get right early in a project.
  \end{quote}
  
  This sentence reflects the fact that

  \optionA{The architecture of a system cannot change}
  \optionB{The main goal of an architect is to identify the quality attributes of system}
  \optionC{Architecture is the design that gets harder to change as development progresses}
  \optionD{The main goal of an architect is to design a detailed structure of the system that supports most of the requirements}
 \putOptions
\end{ClosedQuestion}
}

%3 Featuritis Performitis Flexibilities
\newcommand{\qPerformitis}{
\begin{ClosedQuestion}
	Marquardt characterizes performitis as:
	
	\begin{quote}
		Each part of the system is directly influenced by local performance tuning measures. There is no global performance strategy, or it ignores other qualities of the system such as testability and maintainability.
	\end{quote}
	
	This means that

  \optionA{It is not a good idea to consider performance when designing the architecture of the system}
  \optionB{The performance of a system only depends on the global performance strategies} 
  \optionC{Testability and maintainability always conflict with performance} 
  \optionD{None of the above}
 \putOptions
\end{ClosedQuestion}
}


%4 Architecture Definition - REUSED
\newcommand{\qArchitecturalViews}{
\begin{ClosedQuestion}
	The software architecture of a system is usually represented through several views because we need to

  \optionA{Represent different architectural qualities and they may not be all represented in a single view}
  \optionB{Have a view for each stakeholder} 
  \optionC{Have at least a view for each viewtype} 
  \optionD{Have a view for each group of interconnected components, and very often a system has several groups of interconnected components}
 \putOptions
\end{ClosedQuestion}
}

%5 Module vs Component
\newcommand{\qModueComponent}{
\begin{ClosedQuestion}
  On the web page of Memcached can be read:
  
  \begin{quote}
	  ..., high-performance, distributed memory object caching system, generic in nature, but intended for use in speeding up dynamic web applications by alleviating database load.
  \end{quote}
  
  According to this information, Memcached is

  \optionA{A module}
  \optionB{A component}
  \optionC{Both, a module and a component}
  \optionD{An allocation element}
 \putOptions
\end{ClosedQuestion}
}

%6 Scenarios and Tactics - REUSED
\newcommand{\qConcreteScenario}{
\begin{ClosedQuestion}
  As part of the process of creating an architecture, we talked about
  a framework for capturing some of the requirements for a system.  In
  this context, \textbf{concrete scenarios} are used for

  \optionA{Describing what are the qualities that the system should possess}
  \optionB{Describing a set of steps that a user of the system must
  perform to accomplish some task}
  \optionC{Describing a use case for the system that makes clear what
  should be the system's responses to each of the user's inputs}
  \optionD{Describing the system's features by way of different
  usage scenarios for it, in which users play the role of actors}
 \putOptions
\end{ClosedQuestion}
}

%7 Availability
\newcommand{\qAvailabilityPingEchoHeartbeat}{
\begin{ClosedQuestion}
	Ping-and-echo and Heartbeat are two availability tactics to detect faults.

    \optionA{Ping-and-echo requires the availability monitor to know the addresses of the components it is monitoring}
    \optionB{Heartbeat requires the availability monitor to confirm the reception of the signal}
    \optionC{In Ping-and-echo the availability monitor should always send the same request}
    \optionD{In Heartbeat, the monitored components can change the message rate}
 \putOptions
\end{ClosedQuestion}
}

%8 Security - REUSE
\newcommand{\qSecurityDatabase}{
\begin{ClosedQuestion}
	Consider that when designing the architecture of a web application, the architect intends to guarantee of the confidentiality of persistent data in face of an attack from a system administrator.

    \optionA{It is not possible to achieve this requirement. A non-architectural solution is to be careful when hiring system administrators}
    \optionB{It is necessary to use the authenticate authors tactic to authenticate system administrators before they access to the database}
    \optionC{It is necessary to use the encrypt data tactic to encrypt the information with a password that is in a configuration file}
    \optionD{It is necessary to use the encrypt data tactic to encrypt the information on the client web browser, before it is send to the web server}
 \putOptions
\end{ClosedQuestion}
}

%9 SocialCal Scenarios and Tactics
\newcommand{\qSocialCalcTactic}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		A simple improvement is for each client to broadcast its cursor position to other users, so everyone can see which cells are being worked on.
	\end{quote}
	
	This sentence describes a tactic for usability which is

    \optionA{Maintain task model}
    \optionB{Maintain user model}
    \optionC{Maintain system model}
    \optionD{Aggregate}
 \putOptions
\end{ClosedQuestion}
}

%10 Thounsand Parsec Scenarios and Tactics
\newcommand{\qThousandParsecScenario}{
\begin{ClosedQuestion}
	In the description of the ThousandParsec case study can be read:
	
	\begin{quote}
		The Thousand Parsec Component Language (TPCL) exists to allow clients to create designs locally without server interaction - allowing for instant feedback about the properties, makeup, and validity of the designs. 
	\end{quote}
	
	From this sentence can be written

    \optionA{A scenario for performance associated with a multiple copies of computation tactic}
    \optionB{A scenario for usability associated with a support system initiative tactic}
    \optionC{A scenario for performance associated with a limit event response tactic}
    \optionD{A scenario for usability associated with a support user initiative tactic}
 \putOptions
\end{ClosedQuestion}
}

%11 Git and GitHub Scenarios and Tactics
\newcommand{\qGitTactic}{
\begin{ClosedQuestion}
	In the description of GitHub case study can be read
	
	\begin{quote}
		Once the Smoke proxy has determined the user's route, it establishes a transparent proxy to the proper file server. We have four pairs of fileservers. Their names are fs1a, fs1b, ..., fs4a, fs4b. These are 8 core, 16GB RAM bare metal servers, each with six 300GB 15K RPM SAS drives arranged in RAID 10. At any given time one server in each pair is active and the other is waiting to take over should there be a fatal failure in the master. All repository data is constantly replicated from the master to the slave via DRBD.
	\end{quote}
	
	In this description we can find the application of tactics like 

  \optionA{Multiple copies of computation}
  \optionB{Active redundancy}
  \optionC{Increase resource efficiency}
  \optionD{All of the above}
 \putOptions
\end{ClosedQuestion}
}

%12 Designing-an-Architecture - REUSED
\newcommand{\qArchitecturallySignificantRequirements}{
\begin{ClosedQuestion}
  According to the attribute-driven design process, we should design
  the software architecture for a system based on a selected list of
  requirements, which are called the \textit{architecturally significant requirements}.
  These architecturally significant requirements should be sorted according to their
  importance for the system's stakeholders because
 
    \optionA{We should always satisfy in the first place the requirements
    of the more important stakeholders (such as the client)}
    \optionB{If no order was established among them, we would not know
    from where should we start the design process}
    \optionC{If one of the stakeholders complains that her requirement
    is not satisfied, we may explain to her that there were other more
    important requirements first}
    \optionD{When it is not possible to satisfy all of the requirements
    optimally, we should be aware of their relative importance so that
    we may find a solution that corresponds to a satisfactory trade-off}
 \putOptions
\end{ClosedQuestion}
}

%13 Module Viewtype
\newcommand{\qModuleTraceability}{
\begin{ClosedQuestion}
	Views of the module viewtype can be used to support requirements traceability analysis, determine how the functional requirements of a system are supported. This is represented by
	
    \optionA{Decomposition view}
    \optionB{Data model view}
    \optionC{Generalization view}
    \optionD{Layered view}
 \putOptions
\end{ClosedQuestion}
}


%14 Uses and Generalization architectural styles - REUSED
\newcommand{\qGeneralizationInterfaces}{
\begin{ClosedQuestion}
	You have to develop an application that collects news from different web sources and process that information to present a digest to the application users. The different sources provide similar information through different interfaces (APIs). Additionally, the new sources may change the interfaces, for instance to enhance their service. Which architectural style can be used to represent this requirements?
	
    \optionA{Peer-to-Peer to represent the communication between the components}
    \optionB{Client-Server to represent the request the application makes to the different new sources}
    \optionC{Generalisation to represent an abstraction common to all interfaces and keep API-specific details in child modules}
    \optionD{Layers to create a virtual machine that hides the internals of the application from its users interface code to allow the support of different user interfaces}
 \putOptions
\end{ClosedQuestion}
}

%15 Layered, Aspects and Data Model - REUSED
\newcommand{\qUsesIncremental}{
\begin{ClosedQuestion}
  When designing the architecture for a system the architect realises that most of the modules have bidirectional uses relationships. This has impact on

    \optionA{Performance because there is an overhead of communication between the modules.}
    \optionB{Install because most of the modules need to be assigned to the same executable file}
    \optionC{Development because it is not possible to do incremental development}
    \optionD{Availability because if a module fails the failure easily propagates to all the other modules}
 \putOptions
\end{ClosedQuestion}
}

%16 Component and Connector - REUSED
\newcommand{\qComponentAndConnnector}{
\begin{ClosedQuestion}
	The Java web servers, like Tomcat, use threads to process requests. For each request they create (or reuse) a thread to process it.
	To draw a architectural view that describes this behaviour we should use 
	
    \optionA{A Module viewtype view}
    \optionB{A Allocation viewtype view}
    \optionC{A Communicating processes view}
    \optionD{A Install view}
 \putOptions
\end{ClosedQuestion}
}

%17 Repository and Client-Server - REUSED
\newcommand{\qLoadBalancer}{
\begin{ClosedQuestion}
	To increase the availability of a web application it is possible to use a load-balancer between the clients and the servers that detects server failures and transparently redirects the requests to the servers that are functioning properly. To represent this architecture

    \optionA{It is enough to show the load-balancer between the web clients machines and the servers machines using a deployment view}
    \optionB{It is necessary to change the connector between the web clients and the web servers, in the component-and-connector view, to show the semantics that is provided by the load-balancer}
    \optionC{It is necessary to create a uses view to show how clients require the correct functioning of servers} 
    \optionD{It is necessary to change the component-and-connector view to show the communicating processes}
 \putOptions
\end{ClosedQuestion}
}

%18 Tiers, Dynamic reconfiguration, Peer-to-peer, Publish-subscribe - REUSED
\newcommand{\qThreeTiers}{
\begin{ClosedQuestion}
  One way to increase the performance of a 3-tier enterprise
  application (with the standard separation in the web client, web
  server, and database tiers) is to replicate the web server tier and
  to add a load-balancer between the web clients and the web servers.
  Unfortunately, for some enterprise applications that option is not
  enough (or does not work at all), because

    \optionA{They have many different use cases, corresponding to many
    distinct user interfaces}
    \optionB{They have to process very large amounts of data in each request}
    \optionC{They need to be able to process concurrent requests from
    the users}
    \optionD{They have a very complex domain logic that requires much
    processing power for answering each request}
 \putOptions
\end{ClosedQuestion}
}

%19 SOA, Pipes-and-Filters
\newcommand{\qPublishSubscribe}{
\begin{ClosedQuestion}
  Typically, Instant Messaging clients have a window to list the contacts of the user, and
  show in that window the status of each contact (whether it is available, unavailable, busy,
  etc). Given that the status of a contact may be changed at any time, and that the contact's
  status is given by the Instant Messaging application of that contact, which architectural
  style represents best the interaction pattern between these components?

    \optionA{The Shared Data style}
    \optionB{The Pipes-and-filters style}
    \optionC{The Publish-subscribe style}
    \optionD{The Client-Server style}
 \putOptions
\end{ClosedQuestion}
}

%20 Allocation viewtype - REUSED
\newcommand{\qDeploymentPerformance}{
\begin{ClosedQuestion}
  In the software architecture of a system, the Deployment view is
  best suited for

    \optionA{Analysing the performance of the system}
    \optionB{Planning incremental releases of the system}
    \optionC{Estimating the effort needed to implement the system}
    \optionD{Analysing the system's portability and reusability}
 \putOptions
\end{ClosedQuestion}
}

%21 ThousandParsec views
\newcommand{\qThousandParsecPersistence}{
\begin{ClosedQuestion}
  In the description of ThousandParsec case study can be read
  
  \begin{quote}
	  The flagship server, \textsc{tpserver-cpp}, provides an abstract persistence interface and a modular plugin system to allow for various database back ends. 
  \end{quote}
  
	This above sentence can be diagrammatically represented using
	  
    \optionA{A generalisation architectural style}
    \optionB{An aspects architectural style}
    \optionC{A data model architectural style}
    \optionD{A shared-data architectural style}
 \putOptions
\end{ClosedQuestion}
}

%22 SocialCalc Views
\newcommand{\qSocialCalcBroadcastEvents}{
\begin{ClosedQuestion}
  Consider the (partial) component-and-connector view for the \textsc{:SpreadSheet} component of the SocialCalc system
  
	\centering
	\includegraphics[width=7cm]{x-SocialCalc-spreadsheet-component}
	
    \begin{flushleft}
  	  The \textsc{sub1} port
    \end{flushleft}

    \optionA{Subscribes to the same kind of events that the \textsc{sub2} port}
    \optionB{Subscribes to the same kind of events that the \textsc{inputSub} port}
    \optionC{Subscribes to cursor position events}
    \optionD{It is unnecessary in the diagram because the \textsc{:TableEditor} can use port \textsc{sub2} through the \textsc{:Sheet} component}
 \putOptions
\end{ClosedQuestion}
}

%23 Git and GitHub Views
\newcommand{\qGitHubViews}{
\begin{ClosedQuestion}
	In the description of GitHub case study can be read
	
	\begin{quote}
		For requests to the main website, the load balancer ships your request off to one of the four frontend machines. Each of these is an 8 core, 16GB RAM bare metal server. Their names are fe1, ..., fe4. Nginx accepts the connection and sends it to a Unix domain socket upon which sixteen Unicorn worker processes are selecting. One of these workers grabs the request and runs the Rails code necessary to fulfill it.
	\end{quote}
	
	To represent the above description it is necessary to use	

  \optionA{The communicating processes architectural style}
  \optionB{The client-server architectural style}
  \optionC{The deployment architectural style}
  \optionD{All of the above}
 \putOptions
\end{ClosedQuestion}
}

%24 The architecture of the OrderPad
\newcommand{\qOrderPadTactics}{
\begin{ClosedQuestion}
	In the description of architecture of the OrderPad case study, it can be read that the updates the user does on the OrderPad when it is offline are not lost. This availability quality is achieved through a	

  \optionA{Ignore faulty behaviour tactic}
  \optionB{Ping-and-echo tactic}
  \optionC{Active redundancy tactic}
  \optionD{Retry tactic}
 \putOptions
\end{ClosedQuestion}
}

%25-28 EtherCalc - 4

\newcommand{\qEtherCalcPerformance}{
\begin{ClosedQuestion}
	In the description of EtherCalc case study can be read
	
	\begin{quote}
		Because all jsdom code runs in a single thread, subsequent REST API calls are blocked until the previous command's rendering completes. Under high concurrency, this queue eventually triggered a latent bug that ultimately resulted in server lock-up.
	\end{quote}	
	
	The above sentence is related to a quality for

  \optionA{Performance, because it describes what is the response to REST API calls}
  \optionB{Modifiability, because the jsdom code can not be reused by several threads}
  \optionC{Security, because it describes a "queue overflow" attack}
  \optionD{Interoperability, because the REST API allow the exchange of information with external applications}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qEtherCalcTactic}{
\begin{ClosedQuestion}
	In the description of EtherCalc case study can be read
	
	\begin{quote}
		So, we removed jsdom from the RenderSheet function, re-implemented a minimal DOM in 20 lines of LiveScript for HTML export, then ran the profiler again. Much better! We have improved throughput by a factor of 4, HTML exporting is 20 times faster, and the lock-up problem is gone.
	\end{quote}	
	
	The above sentence describes a

  \optionA{Reduce overhead tactic}
  \optionB{Increase resource efficiency tactic}
  \optionC{Increase resources tactic}
  \optionD{Testability tactic}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qEtherCalcTestability}{
\begin{ClosedQuestion}
	In the description of EtherCalc case study can be read how the architect tried to increase the performance in a multi-core context
	
	\begin{quote}
	Is there a way to make use of all those spare CPUs in the multi-tenant server?

	For other Node.js services running on multi-core hosts, we utilized a pre-forking cluster server that creates a process for each CPU.
	
		However, while EtherCalc does support multi-server scaling with Redis, the interplay of Socket.io clustering with RedisStore in a single server would have massively complicated the logic, making debugging much more difficult.
	\end{quote}	
	
	This possible solution has impact on the

  \optionA{Overall costs, because of deployment}
  \optionB{Availability, because of the interprocess communication}
  \optionC{Testability, because of the logic complexity}
  \optionD{Performance, because there is not a significative improvement by using more CPUs}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qEtherCalcViews}{
\begin{ClosedQuestion}
	In the description of EtherCalc case study can be read how the architect increased the performance in a multi-core context
	
	\begin{quote}
	Instead of pre-forking a fixed number of processes, we sought a way to create one background thread for each server-side spreadsheet, thereby distributing the work of command execution among all CPU cores.
	\end{quote}	
	
	Which is represented by the diagram
	\newline
	
	\centering
	\includegraphics[width=12cm]{x-EtherCalc-multi-tenant}
	
	\begin{flushleft}
		The above diagram, describing a server spreadsheet, can be represented using 
	\end{flushleft}

  \optionA{A publish-subscribe style}
  \optionB{A peer-to-peer style}
  \optionC{A client-server style}
  \optionD{A communication processes style}
 \putOptions
\end{ClosedQuestion}
}

%29-30 Domain Logic and Access Patterns - REUSED

\newcommand{\qTransactionScript}{
\begin{ClosedQuestion}
  Compared to the Transaction Script pattern, the Domain Logic pattern
  has a higher initial cost of adoption.  That is, it is harder to
  start with the Domain Logic pattern than with the Transaction Script
  pattern.  The reason for this is that the Domain Logic pattern

  \optionA{Requires a more skilled team, because the object-oriented
  paradigm is more complex than the procedural paradigm}
  \optionB{Is typically used with more complex data access code}
  \optionC{Requires that we write more code when we have only a
  couple of simple use cases}
  \optionD{All of the above}
 \putOptions
\end{ClosedQuestion}
}

\newcommand{\qActiveRecordRuby}{
\begin{ClosedQuestion}
  Ruby on Rails is a popular full-stack framework for building web
  applications.  One of the elements of this framework is the
  \textbf{model}, which is described in the Rails documentation in the
  following way:
  \begin{quote}
    A model represents the information (data) of the application and
    the rules to manipulate that data. In the case of Rails, models
    are primarily used for managing the rules of interaction with a
    corresponding database table. In most cases, one table in your
    database will correspond to one model in your application. The
    bulk of your application's business logic will be concentrated in
    the models.
  \end{quote}
  Given this description, the Rails' model is best described as an
  instance of
 
  \optionA{The Service Layer pattern}
  \optionB{The Active Record pattern}
  \optionC{The Transaction Script pattern}
  \optionD{The Data Mapper pattern}
 \putOptions
\end{ClosedQuestion}
}


% First Mini-test 


%1
\newcommand{\qFeaturitis}{
\begin{ClosedQuestion}
	Frank Buschmann states that:
		
	\begin{quote}
		Featuritis is the tendency to trade functional coverage for quality - the more functions the earlier they're delivered, the better.
	\end{quote}

    \optionA{Featuritis may result from a requirement of the technical context.}
    \optionB{Featuritis requires the performance quality because the end user needs to execute the features.}
    \optionC{Featuritis may be a result of a requirement of the business context.}
    \optionD{Featuritis requires the modifiability quality to allow a the system to be easily modified to support new features.}
 \putOptions 
\end{ClosedQuestion}
}

%2
\newcommand{\qExplicit}{
\begin{ClosedQuestion}
	Frank Buschmann states that:
	
	\begin{quote}
		There's only one escape from such situations: architects must actively break the cycle of mutual misunderstanding and mistrust!
	\end{quote}

    \optionA{Such misunderstanding and mistrust occurs because the stakeholders have their own agendas}
    \optionB{The cycle Frank Buschmann refers to is the Architectural Influence Cycle.}
    \optionC{The cycle Frank Buschmann refers to allows the clarification of requirements.}
    \optionD{To break such misunderstanding and mistrust the architecture has to make explicit the stakeholders needs.}
 \putOptions
\end{ClosedQuestion}
}

%3
\newcommand{\qFlexibilitis}{
\begin{ClosedQuestion}
	Frank Buschmann states that:
	
	\begin{quote}
		Overly flexible systems are hard to configure, and when they're finally configured, they lack qualities like performance or security.
	\end{quote}

    \optionA{Frank Buschmann is referring to some possible consequences of the modifiability quality.}
    \optionB{Frank Buschmann are considering performance and security as the most important qualities.}
    \optionC{Frank Buschmann is referring that the consequences of a flexible system is poor performance and bad security.}
    \optionD{Frank Buschmann is not considering modifiability as an important quality}
 \putOptions
\end{ClosedQuestion}
}

%4
\newcommand{\qPrioritize}{
\begin{ClosedQuestion}
	Frank Buschmann states that:
	
	\begin{quote}
		Architects use flexibility as a cover for uncertainty.
	\end{quote}

    \optionA{A flexible architecture occurs when it is not possible to identify all the requirements.}
    \optionB{A solution to this problem is to prioritize the system qualities.}
    \optionC{Performance uncertainty about the system should be dealt with more flexibility.}
    \optionD{A solution to this problem is to reduce the level of flexibility of a system.}
 \putOptions
\end{ClosedQuestion}
}

%5
\newcommand{\qPerformitis}{
\begin{ClosedQuestion}
	Frank Buschmann cites the characterization Marquardt does of Performitis:
		
	\begin{quote}
		Each part of the system is directly influenced by local performance tuning measures. There is no global performance strategy, or it ignores other qualities of the system as testability and maintainability.
	\end{quote}
	
	From this problem you can conclude that:

    \optionA{Performance is a quality that you have to address at the end of the development process.}
    \optionB{There is no system which can have good performance and be easily maintainable.}
    \optionC{We have to distinguish architectural performance from opportunistic performance.}
    \optionD{The system performance quality has impact on the performance of the execution of tests.}
 \putOptions
\end{ClosedQuestion}
}

%6
\newcommand{\qFeaturitisPerformitisFlexibilities}{
\begin{ClosedQuestion}
	In his article, \emph{Featuritis, Performitis, and Other Deseases}, Frank Buschmann claims that:

    \optionA{Performance should be the last quality to be addressed because it is a local property of an architecture.}
    \optionB{Modifiability, flexibility, should be the first quality to be addressed because it allows the delay of architectural decisions.}
    \optionC{The lack of functionality results in a system without business value, therefore a rich set of features should be implemented first.}
    \optionD{A solution for any quality in isolation may lead to a biased architecture.}
 \putOptions
\end{ClosedQuestion}
}

%7
\newcommand{\qWalkingSkeleton}{
\begin{ClosedQuestion}
	The \emph{Walking Skeleton} referred in Frank Buschmann's article, \emph{Featuritis, Performitis, and Other Deseases}:

    \optionA{Is a functional prototype, which tests the functionalities required by the business stakeholders.}
    \optionB{Is an architecture that demonstrates that the system will support the qualities raised by the stakeholders.}
    \optionC{Is a baseline architecture that allows to experiment with the most significant architectural requirements.}
    \optionD{Is an object-oriented framework, which integrates functional and non-functional requirements of the system.}
 \putOptions
\end{ClosedQuestion}
}

%8
\newcommand{\qHammersNails}{
\begin{ClosedQuestion}
	In his article \emph{On Hammers and Nails, and Falling in Love with Technology and Design} what is the main type of influence on the architecture?

    \optionA{Project and Technical Contexts.}
    \optionB{Project and Professional Contexts.}
    \optionC{Business and Project Contexts.}
    \optionD{Professional and Technical Contexts.}
 \putOptions
\end{ClosedQuestion}
}

%9
\newcommand{\qArchitectureDefinition}{
\begin{ClosedQuestion}
	On the course slides you can find the following definition of architecture:
	
	\begin{quote}
		The software architecture of a program or computing system is the structure or structures of the system, which comprise software elements, the externally visible properties of those elements, and the relationships among them.
	\end{quote}
	
	However, in the book you can find another definition:
	
	\begin{quote}
		The software architecture of a system is the set of structures needed to reason about the system, which comprise the software elements, relations among them, and the properties of both.
	\end{quote}

    \optionA{The book definition does not consider relevant the externally visible properties.}
    \optionB{The book definition also considers that the properties are externally visible because they are used for reasoning by the stakeholders.}
    \optionC{The book definition also considers that the properties are externally visible because by definition an architectural property is externally visible.}
    \optionD{The book definition is not correct, as pointed out in the errata.}
 \putOptions
\end{ClosedQuestion}
}

%10
\newcommand{\qComponentvsModule}{
\begin{ClosedQuestion}
	In wikipedia you can find the following fragment of a definition:
	
	\begin{quote}
		An individual software component is a software package, or a module that encapsulates a set of related functions.
	\end{quote}
	
	According to the definitions taught in the course the above \emph{individual software component} corresponds to:

    \optionA{A component.}
    \optionB{A module.}
    \optionC{Both, a component and a module, depending on the perspective.}
    \optionD{An external element.}
 \putOptions
\end{ClosedQuestion}
}

%11
\newcommand{\qComponentvsModuleTwo}{
\begin{ClosedQuestion}
	In the Java documentation you can find:
	
\begin{quote}
\texttt{public abstract class Component} \\*
\texttt{extends Object} \\*
\texttt{implements ImageObserver, MenuContainer, Serializable}
\end{quote}

	Class \texttt{Component} is:

    \optionA{A component.}
    \optionB{A module.}
    \optionC{Both, a component and a module, depending on the perspective.}
    \optionD{An external element.}
 \putOptions
\end{ClosedQuestion}
}

%12
\newcommand{\qFunctionalModule}{
\begin{ClosedQuestion}
	When designing an architecture requirements can be split into functional, quality attributes, and constraints. Functional requirements have impact on:
		
    \optionA{A module view.}
    \optionB{A component-and-connector view.}
    \optionC{An allocation view.}
    \optionD{They are not represented by a view.}
 \putOptions
\end{ClosedQuestion}
}

%13
\newcommand{\qModuleViewType}{
\begin{ClosedQuestion}
	The quality that is more relevant to views of the module viewtype is:
		
    \optionA{Modifiability.}
    \optionB{Usability.}
    \optionC{Security.}
    \optionD{Availability.}
 \putOptions
\end{ClosedQuestion}
}

%14
\newcommand{\qComponentViewType}{
\begin{ClosedQuestion}
	The quality(ies) that is(are) more relevant to views of the component-and-connector viewtype is(are):
		
    \optionA{Modifiability.}
    \optionB{Availability and Performance.}
    \optionC{Testability.}
    \optionD{Availability.}
 \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qEarlyDecisions}{
\begin{ClosedQuestion}
	In his article, \emph{Who Needs and Architect?}, Martin Fowler cites Ralph Johnson definition:
	
	\begin{quote}
		Architecture is the set of decisions that must be made early in a project.
	\end{quote}
	
	In his opinion:
		
    \optionA{This is right because if you don't the project fails.}
    \optionB{This is wrong because you can easily change these decisions during the project lifetime.}
    \optionC{This is right but you cannot be completely sure whether the decisions are the right ones.}
    \optionD{This is wrong because it is against agile way of thinking the software development process.}
 \putOptions
\end{ClosedQuestion}
}

%16
\newcommand{\qSharedUnderstanding}{
\begin{ClosedQuestion}
	Martin Fowler, \emph{Who Needs and Architect?}, cites Ralph Johnson sentence:
	
	\begin{quote}
		In most successful software projects, the expert developers working on that project have a shared understanding of the system design. This shared understanding is called architecture.
	\end{quote}
			
    \optionA{This shared understanding is what distinguishes architecture from design.}
    \optionB{This shared understanding is necessary to define precise requirements.}
    \optionC{This shared understanding does not allow to define the architecture trade-offs because some of the stakeholders have their own goals.}
    \optionD{This shared understanding does not allow to have a global perspective of the system, because stakeholders have different interests.}
 \putOptions
\end{ClosedQuestion}
}

%17
\newcommand{\qArchitectDwarves}{
\begin{ClosedQuestion}
	Frank Buschmann, \emph{Introducing the Pragmatic Architect}, defines the \emph{architecture dwarves}. These kind of architects
	
    \optionA{Are unable to understand the technology capabilities.}
    \optionB{Are focused on the project context of the architecture.}
    \optionC{Are unable to distinguish architecture from design.}
    \optionD{Are focused on the business context of the architecture.}
 \putOptions
\end{ClosedQuestion}
}

%18
\newcommand{\qArchitectAstronauts}{
\begin{ClosedQuestion}
	Frank Buschmann, \emph{Introducing the Pragmatic Architect}, defines the \emph{architecture astronauts}. This kind of architect
	
    \optionA{Is unable to define a domain model of the system.}
    \optionB{Is focused on the technology context of the architecture.}
    \optionC{Is focused on creating common generalizations of several systems.}
    \optionD{Is focused on the details of the architecture.}
 \putOptions
\end{ClosedQuestion}
}

%19
\newcommand{\qCreateArchitectureOne}{
\begin{ClosedQuestion}
	During the different steps on how to create an architecture, the precise specification of architecture quality attributes is initially relevant to
	
    \optionA{Make a business case for the system.}
    \optionB{Understand the architecturally significant requirements.}
    \optionC{The system design.}
    \optionD{Documenting and communicating the architecture.}
 \putOptions
\end{ClosedQuestion}
}

%20
\newcommand{\qCreateArchitectureTwo}{
\begin{ClosedQuestion}
	The \emph{Ensuring that the implementation conforms to the architecture} step of how to create an architecture
	
    \optionA{Tries to guarantee that the final system will have the qualities required by stakeholders.}
    \optionB{Tries to guarantee that the final system will have the qualities aimed by the architecture.}
    \optionC{Does not allow developers to define some of the design of the system}
    \optionD{It requires automatic generation of code from the architecture.}
 \putOptions
\end{ClosedQuestion}
}



% Second Mini-test


% Scenarios and Tactics

%1
\newcommand{\qAvailabilityScenario}{
\begin{ClosedQuestion}
	Consider the following scenario
	
	\begin{quote}
		When writing to the database the system receives an exception about a write failure. The system should stop interacting with data base and write a log message. 
	\end{quote}
	
	The quality addressed by this scenario is

    \optionA{Performance.}
    \optionB{Availability.}
    \optionC{Reliability.}
    \optionD{Fault-tolerance}
 \putOptions
\end{ClosedQuestion}
}

%2
\newcommand{\qScenario}{
\begin{ClosedQuestion}
	In a quality scenario

    \optionA{The stimulus is a system input.}
    \optionB{The response can be omitted.}
    \optionC{The artefact can be outside the system.}
    \optionD{The stimulus and the response should be always present.}
 \putOptions
\end{ClosedQuestion}
}


%3
\newcommand{\qTactics}{
\begin{ClosedQuestion}
	An architectural tactic

    \optionA{Is a mediator, an application of the mediator pattern, between the input stimulus and the output response.}
    \optionB{May be associated to other tactics to deal with a single stimulus.}
    \optionC{Is an architectural pattern.}
    \optionD{Is a system decomposition.}
 \putOptions
\end{ClosedQuestion}
}

%4
\newcommand{\qInteroperabilityScenario}{
\begin{ClosedQuestion}
	Consider the following scenario
	
	\begin{quote}
		Our vehicle information system send our current location to the traffic monitoring system. The traffic monitoring system combines our location with other information, overlays this information on a Google Map, and broadcasts it. Our location information is correctly included with a probability of 99.99\%.
	\end{quote}
	
	The quality addressed by this scenario is

    \optionA{Performance.}
    \optionB{Availability.}
    \optionC{Interoperability.}
    \optionD{Testability.}
 \putOptions
\end{ClosedQuestion}
}


% Availability

%5
\newcommand{\qPingEcho}{
\begin{ClosedQuestion}
	A heartbeat monitor

    \optionA{Implements a tactic to recover from faults.}
    \optionB{Implements a tactic to prevent faults.}
    \optionC{Can be used as the source of a stimulus in a scenario.}
    \optionD{Can be used in a non-concurrent system.}
 \putOptions
\end{ClosedQuestion}
}

%6
\newcommand{\qVoting}{
\begin{ClosedQuestion}
	A voting tactic can be used to

    \optionA{Prevent a fault in hardware.}
    \optionB{Prevent a fault in software.}
    \optionC{Prevent a fault in a process.}
    \optionD{Detect a fault.}
 \putOptions
\end{ClosedQuestion}
}

%7
\newcommand{\qDegradation}{
\begin{ClosedQuestion}
	Consider a enterprise web system, which provides services both on the company's intranet and to the company's clients on the internet, that when under a denial of service attack decides to stop providing internet services.

    \optionA{This situation corresponds to the use of the degradation availability tactic.}
    \optionB{This situation corresponds to the use of the removal from service availability tactic.}
    \optionC{This situation corresponds to the use of the limit access security tactic.}
    \optionD{This situation corresponds to the use of the limit exposure security tactic.}
 \putOptions
\end{ClosedQuestion}
}

%8
\newcommand{\qGarbageCollector}{
\begin{ClosedQuestion}
	In wikipedia you can find the following definition:
	
	\begin{quote}
		The garbage collector, or just collector, attempts to reclaim garbage, or memory occupied by objects that are no longer in use by the program.
	\end{quote}
	
	The garbage collector is a component that implements an availability tactic of

    \optionA{Ignore faulty behavior.}
    \optionB{Transactions.}
    \optionC{Rollback.}
    \optionD{Exception prevention.}
 \putOptions
\end{ClosedQuestion}
}


% Graphite scenarios and tactics

%9
\newcommand{\qGraphiteTechnicaAndNonTechnicalUsers}{
\begin{ClosedQuestion}
	Human-editable URL API for creating graphs is a usability design tactic used in the Graphite system. This tactic

    \optionA{Is an aggregate design tactic.}
    \optionB{Is a maintain user model design tactic.}
    \optionC{Is a design tactic for a scenario where the source of stimulus are technical users.}
    \optionD{Is a design tactic for a scenario where the source of stimulus is the graph owner user.}
 \putOptions
\end{ClosedQuestion}
}

%10
\newcommand{\qGraphiteReliability}{
\begin{ClosedQuestion}
	In the Graphite system description can be read:
	
	\begin{quote}
		We've got 600,000 metrics that update every minute and we're assuming our storage can only keep up with 60,000 write operations per minute. This means we will have approximately 10 minutes worth of data sitting in carbon's queues at any given time. To a user this means that the graphs they request from the Graphite webapp will be missing the most recent 10 minutes of data.
	\end{quote}

    \optionA{The quality addressed is availability.}
    \optionB{The quality addressed is performance.}
    \optionC{The quality addressed is availability and a voting design tactic is required to solve the problem.}
    \optionD{The quality addressed is performance and a maintain multiple copies of data design tactic is required to solve the problem.}
 \putOptions
\end{ClosedQuestion}
}


%11
\newcommand{\qGraphiteModifiability}{
\begin{ClosedQuestion}
	In the Graphite system description can be read:
	
	\begin{quote}
		Making multiple Graphite servers appear to be a single system from a user perspective isn't terribly difficult, at least for a naive implementation.
	\end{quote}

    \optionA{The quality addressed is availability.}
    \optionB{The quality addressed is modifiability.}
    \optionC{The quality addressed is availability and an active redundancy design tactic is required to solve the problem.}
    \optionD{The quality addressed is modifiability and an increase cohesion design tactic is required to solve the problem.}
 \putOptions
\end{ClosedQuestion}
}

%12
\newcommand{\qGraphiteBackend}{
\begin{ClosedQuestion}
	To reduce the backend load (writes) the Graphite system uses
	
    \optionA{A Maintain Multiple Copies of Computation design tactic in Carbon.}
    \optionB{A Maintain Multiple Copies of Computation design tactic in the WebApp such that reads do not compete with writes.}
    \optionC{A Maintain Multiple Copies of Data design tactic in Carbon.}
    \optionD{A Maintain Multiple Copies of Data design tactic in the WebApp such that reads do not compete with writes.}
 \putOptions
\end{ClosedQuestion}
}


% Security

%13
\newcommand{\qFirewall}{
\begin{ClosedQuestion}
	Having a single point of access to an intranet is a security tactic of
	
    \optionA{Detect intrusion.}
    \optionB{Limit access.}
    \optionC{Limit exposure.}
    \optionD{Separate entities.}
 \putOptions
\end{ClosedQuestion}
}

%14
\newcommand{\qVerifyMessageIntegrity}{
\begin{ClosedQuestion}
	In the Fenix system a checksum is associated to a set of grades. This is an application of the tactic
	
    \optionA{Detect intrusion.}
    \optionB{Detect service denial.}
    \optionC{Verify message integrity.}
    \optionD{Detect message delay.}
 \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qInternalAttack}{
\begin{ClosedQuestion}
	In a system where the source of attacks can be internal, from authorized users, the appropriate tactics to be used are
	
    \optionA{Detect and Resist.}
    \optionB{Detect and React.}
    \optionC{Detect and Recover.}
    \optionD{Resist and React.}
 \putOptions
\end{ClosedQuestion}
}

%16
\newcommand{\qSeparateEntities}{
\begin{ClosedQuestion}
	In a system where there are sensitive data an appropriate tactic to be used is
	
    \optionA{Limit access, to restrict the access to the database system.}
    \optionB{Limit exposure, locate the database system in the intranet.}
    \optionC{Separate entities, to allow the use of more strict tactics on the sensitive data.}
    \optionD{Change default settings, because default passwords are sensitive.}
 \putOptions
\end{ClosedQuestion}
}

%17
\newcommand{\qChromeTabSecurity}{
\begin{ClosedQuestion}
	In the Chrome system the use of a process per tab results form the application of a tactic of
	
    \optionA{Limit access.}
    \optionB{Increase resources.}
    \optionC{Increase resource efficiency.}
    \optionD{Maintain multiple copies of data.}
 \putOptions
\end{ClosedQuestion}
}

%18
\newcommand{\qChromePerformance}{
\begin{ClosedQuestion}
	In the Chrome system the following tactic is used to improve performance
	
    \optionA{Increase resources.}
    \optionB{Introduce concurrency.}
    \optionC{Reduce overhead.}
    \optionD{Manage sample rate.}
 \putOptions
\end{ClosedQuestion}
}

%19
\newcommand{\qChromePredictor}{
\begin{ClosedQuestion}
	In the description of the Chrome system can be read
	
	\begin{quote}
		The goal of the predictor is to evaluate the likelihood of its success, and then to trigger the activity if resources are available. 
	\end{quote}
	
	The above sentence refer to
	
    \optionA{Maintain multiple copies of data tactic.}
    \optionB{Introduce concurrence tactic.}
    \optionC{Increase resource efficiency tactic.}
    \optionD{Schedule resources tactic.}
 \putOptions
\end{ClosedQuestion}
}

%20
\newcommand{\qChromeUsability}{
\begin{ClosedQuestion}
	In the description of the Chrome system can be read
	
	\begin{quote}
		As the user types, the Omnibox automatically proposes an action, which is either a URL based on your navigation history, or a search query.
	\end{quote}
	
	The above sentence refers to
	
    \optionA{Maintain user model tactic.}
    \optionB{Introduce concurrence tactic.}
    \optionC{Increase resource efficiency tactic.}
    \optionD{Maintain task model tactic.}
 \putOptions
\end{ClosedQuestion}
}




% Third Mini-test

% Fnix-From-Problem-To-Tactics

%1
\newcommand{\qFenixBusinessCase}{
\begin{ClosedQuestion}
	In the context of the FenixEdu case study, the business case was to

    \optionA{Incorporate in the organization's core business the goals of a software house.}
    \optionB{Do in-house development.}
    \optionC{Integrate the development of the software system with the organization's business goals.}
    \optionD{Reimplement all the information systems of the organization}
 \putOptions
\end{ClosedQuestion}
}

%2
\newcommand{\qBusinessScenarioOne}{
\begin{ClosedQuestion}
	In the context of the FenixEdu case study the following scenario was identified.
	
	\begin{quote}
		The school management pretends that all the members of the school, students, administrative staff, faculty and management should be able to use the system to perform their activities efficiently without requiring the installation of any client software or a long learning process.
	\end{quote}
	
	This is a 

    \optionA{Business scenario.}
    \optionB{Availability scenario.}
    \optionC{Modifiability scenario.}
    \optionD{Usability scenario.}
 \putOptions
\end{ClosedQuestion}
}

%3
\newcommand{\qBusinessScenarioTwo}{
\begin{ClosedQuestion}
	In the context of the FenixEdu case study the following scenario was identified.
	
	\begin{quote}
		The management intends that the system should be available to all users, even after offices close and classes finish because students may need courses material to study 24X7 and faculty and administrative staff may want to work from home.
	\end{quote}
	
	This is a 

    \optionA{Business scenario.}
    \optionB{Availability scenario.}
    \optionC{Modifiability scenario.}
    \optionD{Usability scenario.}
 \putOptions
\end{ClosedQuestion}
}

%4
\newcommand{\qUtilityTree}{
\begin{ClosedQuestion}
	A utility tree

    \optionA{Only contains business qualities.}
    \optionB{Cannot be defined for the security quality.}
    \optionC{Contains the architectural tactics associated with architecturally significant requirements.}
    \optionD{Contains the business value and the architectural impact of architecturally significant requirements.}
 \putOptions
\end{ClosedQuestion}
}


% Designing-an-Architecture

%5
\newcommand{\qIterativeDesign}{
\begin{ClosedQuestion}
	Designing an architecture

    \optionA{Is driven by functional requirements.}
    \optionB{Is done in a single step, after all the tactics were identified.}
    \optionC{Is a top-down process where a initial decomposition is chosen and it is successively decomposed without changing the initial decisions.}
    \optionD{Is an iterative process where architectural designs are proposed as hypothesis and tested.}
 \putOptions
\end{ClosedQuestion}
}

%6
\newcommand{\qLowArchitecturalImpact}{
\begin{ClosedQuestion}
	Consider an architecturally significant requirement (ASR) that has a low impact on the architecture but a high business value

    \optionA{This ASR can easily be supported by the architecture because it has little effect in the architecture.}
    \optionB{This ASR requires a specific architectural design because it profoundly affects the architecture.}
    \optionC{The cost of meeting the ASR after development starts is too high.}
    \optionD{Any ASR that has a high business value cannot have a low architecture impact because it needs to be supported by the architecture.}
 \putOptions
\end{ClosedQuestion}
}

%7
\newcommand{\qHighBusinessValue}{
\begin{ClosedQuestion}
	Consider an architecturally significant requirement (ASR) that has a high impact on the architecture but a low business value

    \optionA{This ASR can easily be supported by the architecture.}
    \optionB{This ASR should be supported by the architecture because of its high impact.}
    \optionC{The architect have to decide on the cost/benefit of designing an architecture that supports this ASR.}
    \optionD{The architect should support this ASR after designing an architecture that supports all the ASRs with high business value.}
 \putOptions
\end{ClosedQuestion}
}

%8
\newcommand{\qFenixADD}{
\begin{ClosedQuestion}
	When applying Attribute-Driven Design (ADD) to the FenixEdu system the creation of a view where there are redundant web servers, load balancers and database servers 

    \optionA{Results from a utility tree for performance.}
    \optionB{Results from a single availability scenario.}
    \optionC{Results from the application of a single ADD iteration.}
    \optionD{Results from the application of several ADD iterations.}
 \putOptions
\end{ClosedQuestion}
}

% SocialCal

%9
\newcommand{\qSocialCalcMaintainTaskModel}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		Therefore, on browsers with support for CSS3, we use the box-shadow property to represent multiple peer cursors in the same cell.
	\end{quote} 
	
	This corresponds to the application of

    \optionA{Maintain system model tactic.}
    \optionB{Support user initiative tactic.}
    \optionC{Maintain multiple copies of data tactic.}
    \optionD{Conflict detection tactic.}
 \putOptions
\end{ClosedQuestion}
}

%10
\newcommand{\qSocialCalcUsability}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		Even with race conditions resolved, it is still suboptimal to accidentally overwrite the cell another user is currently editing. A simple improvement is for each client to broadcast its cursor position to other users, so everyone can see which cells are being worked on.
	\end{quote} 
	
	From this fragment can be identified a scenario for

    \optionA{Testability.}
    \optionB{Reliability.}
    \optionC{Availability.}
    \optionD{Usability.}
 \putOptions
\end{ClosedQuestion}
}

%11
\newcommand{\qSocialCalcAvailability}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		If users A and B simultaneously perform an operation affecting the same cells, then receive and execute commands broadcast from the other user, they will end up in different states.
	\end{quote} 
	
	From this fragment can be identified a scenario for

    \optionA{Performance.}
    \optionB{Reliability.}
    \optionC{Availability.}
    \optionD{Usability.}
 \putOptions
\end{ClosedQuestion}
}

%12
\newcommand{\qSocialCalcModifiability}{
\begin{ClosedQuestion}
	In the description of the SocialCalc case study can be read:
	
	\begin{quote}
		To make this work across browsers and operating systems, we use the Web::Hippie4 framework, a high-level abstraction of JSON-over-WebSocket with convenient jQuery bindings.
	\end{quote} 
	
	From this fragment can be identified a scenario for

    \optionA{Performance.}
    \optionB{Modifiability.}
    \optionC{Availability.}
    \optionD{Usability.}
 \putOptions
\end{ClosedQuestion}
}


% Thounsand Parsec

%13
\newcommand{\qThounsandParsecAvailability}{
\begin{ClosedQuestion}
	In the description of the Thousand Parsec case study can be read:
	
	\begin{quote}
		Turns also have a time limit imposed by the server, so that slow or unresponsive players cannot hold up a game.
	\end{quote} 
	
	From this fragment can be identified a scenario for

    \optionA{Performance.}
    \optionB{Interoperability.}
    \optionC{Availability.}
    \optionD{Usability.}
 \putOptions
\end{ClosedQuestion}
}

%14
\newcommand{\qThounsandParsecInteroperability}{
\begin{ClosedQuestion}
	In the description of the Thousand Parsec case study can be read:
	
	\begin{quote}
		Finding a public Thousand Parsec server to play on is much like locating a lone stealth scout in deep space - a daunting prospect if one doesn't know where to look. Fortunately, public servers can announce themselves to a metaserver, whose location, as a central hub, should ideally be well-known to players.
	\end{quote} 
	
	From this fragment can be identified a scenario for

    \optionA{Interoperability.}
    \optionB{Performance.}
    \optionC{Availability.}
    \optionD{Usability.}
 \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qThounsandParsecRollback}{
\begin{ClosedQuestion}
	In the description of the Thousand Parsec case study can be read:
	
	\begin{quote}
		Besides often running far longer than the circadian rhythms of the players' species, during this extended period the server process might be prematurely terminated for any number of reasons. To allow players to pick up a game where they left off, Thousand Parsec servers provide persistence by storing the entire state of the universe (or even multiple universes) in a database.
	\end{quote} 
	
	The tactic referred in the fragments is

    \optionA{Rollback.}
    \optionB{Persistence.}
    \optionC{Retry.}
    \optionD{Passive redundancy.}
 \putOptions
\end{ClosedQuestion}
}

%16
\newcommand{\qThounsandParsecSystemInitiative}{
\begin{ClosedQuestion}
	In the description of the Thousand Parsec case study can be read:
	
	\begin{quote}
		Next, the player is prompted to configure options for the ruleset and server, with sane defaults pulled from the metadata. Finally, if any compatible AI clients are installed, the player is prompted to configure one or more of them to play against.
	\end{quote} 
	
	The tactic referred in the fragments is

    \optionA{Change default settings.}
    \optionB{Limit access.}
    \optionC{Support user initiative.}
    \optionD{Support system initiative.}
 \putOptions
\end{ClosedQuestion}
}

% Module Viewtype

%17
\newcommand{\qDecomposition}{
\begin{ClosedQuestion}
	The Decomposition architectural style of the Module viewtype 
	
    \optionA{Is applied only once at the beginning of the architectural design process.}
    \optionB{Is applied at the begin of the architectural design process but may be necessary to redo it later.}
    \optionC{Is mostly driven by the security attribute quality.}
    \optionD{Follows a bottom-up decomposition process of the system.}
 \putOptions
\end{ClosedQuestion}
}

%18
\newcommand{\qDecompositionBuilvsBuy}{
\begin{ClosedQuestion}
	A criteria for the the application of the Decomposition architectural style of the Module viewtype is Build-vs-Buy decisions. The application of the criteria
	
    \optionA{Results in a similar decomposition as if the criteria was not applied but some modules are identified to be outsourced.}
    \optionB{Results in a decomposition where each module may be implemented by a single developer.}
    \optionC{Allows to increase the overall calendar development time of the project because there is a communication overhead with external teams.}
    \optionD{Allows to identify modules for which the development team does not have the required implementation competences.}
 \putOptions
\end{ClosedQuestion}
}



% Fourth Mini-Test


% Uses and Generalization architectural styles

%1
\newcommand{\qUsesFor}{
\begin{ClosedQuestion}
	The Uses architectural style of the Module viewtype 
	
    \optionA{Allows the analysis of the impact of changes because if a module uses another it will necessarily have to change whenever the used module changes.}
    \optionB{Improves testability because if a module uses another then it is only possible to test them together.}
    \optionC{Allows incremental development because the possible increments of functionally can be inferred from use dependencies.}
    \optionD{Improves testability because it informs the tester about which modules involved in circular use dependencies.}
 \putOptions
\end{ClosedQuestion}
}

%2
\newcommand{\qUsesCalls}{
\begin{ClosedQuestion}
	A function call is not necessarily a uses relation of the Uses architectural style of the Module viewtype because
	

    \optionA{The correctness of the caller module may not depend on the correct implementation of the invoked function in the called module.}
    \optionB{The invoked function may not have any input parameter.}
    \optionC{The invoked function may not have any output parameter.}
    \optionD{The invoked function may not have both any input parameter nor any output parameter.}
 \putOptions
\end{ClosedQuestion}
}

%3
\newcommand{\qUsesCycles}{
\begin{ClosedQuestion}
	Consider a view of the module viewtype where there is a uses loop, a cycle of uses dependences between several modules. It may be possible to break the dependence cycle by
	

    \optionA{Applying the generalization style to identify child modules of a module in the loop chain.}
    \optionB{Applying the decomposition style to some of the modules in the loop chain.}
    \optionC{Identifying which of the \emph{uses} dependencies are actually generalization dependencies.}
    \optionD{Decomposing a \emph{uses} relation into different interfaces.}
 \putOptions
\end{ClosedQuestion}
}

%4
\newcommand{\qGeneralizationEvolution}{
\begin{ClosedQuestion}
	The Generalization architectural style of the module viewtype can be use to support the evolution of a system 

    \optionA{By changing the commonalities that are in the children.}
    \optionB{Because the \emph{is-a} relation does not allow reuse of implementation.}
    \optionC{By adding, removing, or changing children.}
    \optionD{By changing a parent, which will automatically change all the children that inherit from it.}
 \putOptions
\end{ClosedQuestion}
}

% Layered, Aspects and Data Model

%5
\newcommand{\qLayeredVirtualMachine}{
\begin{ClosedQuestion}
	According to the definition of the Layered architectural style, each layer represents a grouping of modules that offers a cohesive set of services.
	
    \optionA{This means that the modules inside a layer cannot be loosely coupled.}
    \optionB{This means that this architectural style emphasizes the quality of performance.}
    \optionC{This means that each module cannot use other modules inside the same layer.}
    \optionD{This means that the modules inside a layer are likely to be ported to a new application together.}
 \putOptions
\end{ClosedQuestion}
}

%6
\newcommand{\qAspects}{
\begin{ClosedQuestion}
	An architect is decomposing a system into a set of responsibilities using a view of the Decomposition style. However, she had already to backtrack several times and try new decompositions because she end up with some responsibility that can not be within a single module.
	
    \optionA{She should try to use a view of the Aspects style, assign this responsibility to a module such that the other modules can crosscut this responsibility.}
    \optionB{She should try to use a view of the Aspects style, assign this responsibility to a module and bind it to the modules affected by it.}
    \optionC{She should define finer-grained modules where she splits the unassigned responsibility.}
    \optionD{This means that in this software system it is not possible to modularize each responsibility in a cohesive module.}
 \putOptions
\end{ClosedQuestion}
}

%7
\newcommand{\qDataModelFacebook}{
\begin{ClosedQuestion}
	In Facebook it is not possible to have the information about more that one bilion users in a single disk. Therefore, a sharding technique is applied, where the persistent information is split between several database servers, and applications are routed to the right servers for queries and updates. To describe this architecture
	
    \optionA{It is necessary design a CRUD matrix to show the dependencies between the persistent information.}
    \optionB{It is enough to design a view of the Data Model architectural style at the conceptual level because Facebook information has a very simple structure.}
    \optionC{It is not necessary to have any view of the Data Model architectural style because Facebook information has a very simple structure.}
    \optionD{It is necessary to design a view of the Data Model architectural style at the physical level to deal with performance issues of the access to data.}
 \putOptions
\end{ClosedQuestion}
}


%8
\newcommand{\qUsesDataModel}{
\begin{ClosedQuestion}
	A CRUD matrix, which indicates whether each module creates, reads, updates, or deletes data (CRUD, for short) from each data entity. The CRUD matrix
	
    \optionA{Relates a view of the Uses style with a view of the Data Model style.}
    \optionB{Is an extension of a view of the Data Model style.}
    \optionC{Allows to avoid redundancy and inconsistency.}
    \optionD{Describes the structure of the data used by the system.}
 \putOptions
\end{ClosedQuestion}
}


% Git and GitHub

%9
\newcommand{\qGitHubSecurity}{
\begin{ClosedQuestion}
	In the description of the GitHub case study can be read:
	
	\begin{quote}
		Of course, allowing arbitrary execution of commands is unsafe, so SSH includes the ability to restrict what commands can be executed. In a very simple case, you can restrict execution to git-shell which is included with Git. All this script does is check the command that you're trying to execute and ensure that it's one of git upload-pack, git receive-pack, or git upload-archive.
	\end{quote}
	
	The tactic addressed in this fragments is:
	
    \optionA{Limit exposure.}
    \optionB{Limit access.}
    \optionC{Authorize actors.}
    \optionD{Separate entities.}
 \putOptions
\end{ClosedQuestion}
}

%10
\newcommand{\qGitConditionMonitoring}{
\begin{ClosedQuestion}
	In the description of the Git case study can be read how to deal with the corruption of pack files in the context of the availability quality:
	
	\begin{quote}
		If an object was only copied partially or another form of data corruption occurred, recalculating the SHA of the current object will identify such corruption.
	\end{quote}
	
	The tactic addressed in this fragments is:
	
    \optionA{Sanity checking.}
    \optionB{Exception detection.}
    \optionC{Detect intrusion.}
    \optionD{Condition monitoring.}
 \putOptions
\end{ClosedQuestion}
}

%11
\newcommand{\qGitIncreaseResourceEfficiency}{
\begin{ClosedQuestion}
	In the description of the Git case study can be read how it efficiently compares content:
	
	\begin{quote}
		When a content (i.e., file or directory) node in the graph has the same reference identity (the SHA in Git) as that in a different commit, the two nodes are guaranteed to contain the same content, allowing Git to short-circuit content diffing efficiently.
	\end{quote}
	
	The performance tactic addressed in this fragments is:
	
    \optionA{Schedule resources.}
    \optionB{Maintain multiple copies of data.}
    \optionC{Increase resource efficiency.}
    \optionD{Reduce overhead.}
 \putOptions
\end{ClosedQuestion}
}

%12
\newcommand{\qGitHubComputationRedundancy}{
\begin{ClosedQuestion}
	In the description of the GitHub case study can be read:
	
	\begin{quote}
		Once the Smoke proxy has determined the user's route, it establishes a transparent proxy to the proper file server. We have four pairs of file servers. Their names are fs1a, fs1b, ..., fs4a, fs4b. These are 8 core, 16GB RAM bare metal servers, each with six 300GB 15K RPM SAS drives arranged in RAID 10. At any given time one server in each pair is active and the other is waiting to take over should there be a fatal failure in the master. All repository data is constantly replicated from the master to the slave via DRBD.
	\end{quote}
	
	The four pairs of file servers implement:
	
    \optionA{Multiple copies of computation and Passive redundancy tactics.}
    \optionB{Multiple copies of computation tactic.}
    \optionC{Passive redundancy tactic.}
    \optionD{Multiple copies of computation and Active redundancy tactics.}
 \putOptions
\end{ClosedQuestion}
}

% Component and Connector

%13
\newcommand{\qComponentPorts}{
\begin{ClosedQuestion}
	Consider the concepts of module interface and component port. 
		
    \optionA{A module interface has to be attached to a single component port.}
    \optionB{A module interface can be replicated but component ports cannot.}
    \optionC{A module interface cannot be replicated but component ports can.}
    \optionD{A module interface may be attached to several component ports.}
 \putOptions
\end{ClosedQuestion}
}

%14
\newcommand{\qConnectorAttach}{
\begin{ClosedQuestion}
	A connector may be attached to components of different types because
		
    \optionA{The type of a connector does not depend on the type of its roles.}
    \optionB{The type of a component does not depend on the type of its ports.}
    \optionC{The attachment is a runtime relation which dynamically manages type compliance.}
    \optionD{The attachment between components and connectors only depends on their ports and roles types.}
 \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qModuleComponent}{
\begin{ClosedQuestion}
	Consider the kind of relations between components and modules.
		
    \optionA{A module contains the code that executes in a single component and a component executes the code of a single module.}
    \optionB{A module contains the code that can execute in several components and a component executes the code of a single module.}
    \optionC{A module contains the code that executes in a single component and a component can execute the code of several modules.}
    \optionD{A module contains the code that can execute in several components and a component can execute the code of several modules.}
 \putOptions
\end{ClosedQuestion}
}

%16
\newcommand{\qConnectorDecomposition}{
\begin{ClosedQuestion}
	Consider an architect that is designing a component-and-connector view. In some point the architect decides that she does not need to decompose a connector with a demanding quality level. This may occur because
		
    \optionA{She encapsulates the connector qualities inside a higher level component.}
    \optionB{She delays the complete specification of the connector for development time to have human resources to prototype and measure different implementations.}
    \optionC{She does not want to clutter the view with details and trusts the development team to implement the connector according to the required quality level.}
    \optionD{The required quality associated with the connector is supported by existing and well-know technology.}
 \putOptions
\end{ClosedQuestion}
}

% Repository and Client-Server

%17
\newcommand{\qRepositoryModifiability}{
\begin{ClosedQuestion}
	The repository architectural style provides modifiability because

    \optionA{It is possible to integrate a new data accessor without changing the other data accessors.}
    \optionB{It is possible to change the repository schema without changing the data accessors.}
    \optionC{The integration of a new data accessor only implies changes in the data accessors that access the same type of data.}
    \optionD{The communication between data accessors does not occur through the repository.}
 \putOptions
\end{ClosedQuestion}
}

%18
\newcommand{\qRepositoryPerformance}{
\begin{ClosedQuestion}
	The repository architectural style provides performance because

    \optionA{It implements a maintain multiple copies of computation tactic.}
    \optionB{It supports the concurrent access of data accessors.}
    \optionC{It supports the access to persistent information.}
    \optionD{It implements a maintain multiple copies of data tactic.}
 \putOptions
\end{ClosedQuestion}
}

%19
\newcommand{\qClientServerAvailability}{
\begin{ClosedQuestion}
	The client-server architectural style provides availability because
	
    \optionA{It allows an undefined number of clients.}
    \optionB{It is possible to have redundant servers.}
    \optionC{Servers can also be clients.}
    \optionD{Servers can send a heartbeat to clients.}
 \putOptions
\end{ClosedQuestion}
}

%20
\newcommand{\qClientServerSynchronous}{
\begin{ClosedQuestion}
	In the client-server architectural style the request/reply connector is synchronous. Consider an architect that wants to describe an asynchronous interaction between clients and servers. 
	
    \optionA{She can define a variant of this style with asynchronous communication by allowing the client to register callbacks that the server calls at specific times.}
    \optionB{She has to use another architectural style to describe asynchronous communication.}
    \optionC{She can use the request/reply connector but the server should not return results to the client.}
    \optionD{She can define a variant of this style with asynchronous communication by allowing the server to have the initiative to initiate the interaction.}
 \putOptions
\end{ClosedQuestion}
}


% Fifth Mini-test


% Tiers, Dynamic reconfiguration, Peer-to-peer, Publish-subscribe

%1
\newcommand{\qPeerToPeerSpace}{
\begin{ClosedQuestion}
	The Peer-to-Peer architectural style provides high scalability and availability. In the context of a file sharing system  
	
    \optionA{The file transfers follows the same path of nodes used to identify where the file was located.}
    \optionB{The peer initiating the request for a file needs to know where the file is located.}
    \optionC{If a peer providing a file crashes it is necessary to restart to download the file from the begin.}
    \optionD{The price for high scalability and availability is the need to have several replicas of the files to be shared.}
 \putOptions
\end{ClosedQuestion}
}

%2
\newcommand{\qPeerToPeerDynamicReconfiguration}{
\begin{ClosedQuestion}
	In the description of the Gnutella system can be read:
	
	\begin{quote}
		The topology of the system changes at runtime as peer components connect and disconnect to the network.
	\end{quote}
	
    \optionA{When a peer connects to the network it establishes connections with all other peers in the network.}
    \optionB{The behavior described in the sentence can be represented in a view where the dynamic reconfiguration architectural style is used.}
    \optionC{When a peer receives a connection it sends all its files to the peer connecting it.}
    \optionD{The behavior described in the sentence can be represented in a view where the tier architectural style is used.}
 \putOptions
\end{ClosedQuestion}
}

%3
\newcommand{\qTiers}{
\begin{ClosedQuestion}
	The Tiers architectural style
	
    \optionA{It applies layers to tiers.}
    \optionB{Restrict the communication between components because, for instance, a group of components should be located in the same hardware.}
    \optionC{Is an extension of the Client-Server architectural style.}
    \optionD{Defines tiers as components.}
 \putOptions
\end{ClosedQuestion}
}

%4
\newcommand{\qPublishSubscribe}{
\begin{ClosedQuestion}
	In the Publish-Subscribe architectural style 
	
    \optionA{A component can subscribe to events.}
    \optionB{All the published events are received by their subscribing components.}
    \optionC{The events should be delivered by the same order they are sent.}
    \optionD{The set of events types are predefined at initialization time.}
 \putOptions
\end{ClosedQuestion}
}


% SOA, Pipes-and-Filters

%5 
\newcommand{\qSOAInteroperability}{
\begin{ClosedQuestion}
	The Service-Oriented Architecture style improves interoperability because
	
    \optionA{It enforces the use of a single implementation language among all applications.}
    \optionB{The orchestration is in charge of improving the transparent location of service providers.}
    \optionC{The enterprise service bus coordinates the execution of several services.}
    \optionD{It decouples applications developed for different organizations.}
 \putOptions
\end{ClosedQuestion}
}

%6 
\newcommand{\qSOAQualities}{
\begin{ClosedQuestion}
	The Service-Oriented Architecture style improves modifiability because
	
    \optionA{It encapsulates applications through well-defined interfaces.}
    \optionB{It decouples the coordination of the interaction among applications from the applications themselves.}
    \optionC{It improves transparency of location of service providers.}
    \optionD{It encapsulates applications through well-defined interfaces, decouples the coordination of the interaction among applications from the applications themselves, and improves transparency of location of service providers.}
 \putOptions
\end{ClosedQuestion}
}

%7
\newcommand{\qSOAClientServerPeertoPeer}{
\begin{ClosedQuestion}
	The Service-Oriented Architecture style
	

    \optionA{Is a Client-Server style because consumers are clients and providers are servers.}
    \optionB{Is a Peer-to-Peer style because consumers and providers are peers.}
    \optionC{Can use a Service Registry to improve transparency of location of service providers.}
    \optionD{Is a Publish-subscriber style because consumers use an enterprise service bus.}
 \putOptions
\end{ClosedQuestion}
}

%8
\newcommand{\qPipeFilterComposition}{
\begin{ClosedQuestion}
	The Pipe-and-Filter style allows composition of filters 

    \optionA{But when the filters are executed sequentially the composition power is reduced.}
    \optionB{Which improves modifiability, because filters are decoupled through pipes.}
    \optionC{But the size of buffers may reduce the composition power.}
    \optionD{And filters do not have to agree on the data formats.}
 \putOptions
\end{ClosedQuestion}
}

% Graphite views

%9
\newcommand{\qGraphiteDecompositionMemcached}{
\begin{ClosedQuestion}
	Consider the following decomposition view of the Graphite system where module \textsc{Store Graphs} is responsible for managing the storage of datapoints and graphs and module \textsc{Present Graphs} for graphs generation and presentation. Memcache is a library that maintains datapoints in memory to reduce the overhead of obtaining them from the file system.
	
	\centering
	\includegraphics[width=10cm]{x-top-decomposition}

    \optionA{Memcached can be considered a sub-module of the Store Graphs module.}
    \optionB{Memcached can be considered a sub-module of the Present Graphs module.}
    \optionC{Memcached can be considered a direct sub-module of the top Graphite module.}
    \optionD{Memcached is not a module.}
 \putOptions
\end{ClosedQuestion}
}

%10
\newcommand{\qGraphiteDecompositionBuffering}{
\begin{ClosedQuestion}
	Consider the following decomposition view of the Graphite system where module \textsc{Store Graphs} is responsible for managing the storage of datapoints and graphs and module \textsc{Present Graphs} for graphs generation and presentation. Buffering is a library used to temporarily store incoming data point.
	
	\centering
	\includegraphics[width=10cm]{x-top-decomposition}

    \optionA{Buffering can be considered a sub-module of the Store Graphs module.}
    \optionB{Buffering can be considered a sub-module of the Present Graphs module.}
    \optionC{Buffering can be considered a direct sub-module of the top Graphite module.}
    \optionD{Buffering is not a module.}
 \putOptions
\end{ClosedQuestion}
}

%11
\newcommand{\qGraphiteCarbon}{
\begin{ClosedQuestion}
	Consider the following application-specific types that were defined for a component-and-connector view that depicts the components within \texttt{Carbon} component. 
	
	\centering
	\includegraphics[width=10cm]{x-carbon-buffering}

    \optionA{In the view there are multiple instances of the \texttt{Queue} component.}
    \optionB{In the view there are multiple instances of the \texttt{Writer} component.}
    \optionC{In the view \texttt{Receiver} component's \texttt{client} port is not associated with an external port.}
    \optionD{In the view the \texttt{produce} port of a \texttt{Receiver} component is attached to the \texttt{consume} port of a \texttt{Writer} component.}
 \putOptions
\end{ClosedQuestion}
}


%12
\newcommand{\qGraphiteDataPointSocket}{
\begin{ClosedQuestion}
	Consider the following application-specific types. Note that \texttt{Queue} components are within the \texttt{Carbon} components. In a view that contains components of these three types 
	
	\centering
	\includegraphics[width=12cm]{x-datapoint-access}

    \optionA{There is a message passing connector between the \texttt{read} port of \texttt{Queue} and the \texttt{data points access} port of \texttt{WebApp}.}
    \optionB{There is a interface delegation relation between the \texttt{read} port of \texttt{Queue} and the \texttt{query} port of \texttt{Carbon}.}
    \optionC{There is a connector between the \texttt{producer} port of a \texttt{Queue} component and the \texttt{client} port of its \texttt{Carbon} component.}
    \optionD{The \texttt{client} ports of \texttt{Carbon} and \texttt{WebApp} are connected to a \texttt{Client} component through the same connector instance.}
 \putOptions
\end{ClosedQuestion}
}


% Allocation viewtype

%13
\newcommand{\qAllocationStylesCost}{
\begin{ClosedQuestion}
	Consider a stakeholder that is particularly concerned about the total cost of the project. When it comes to describing the system using allocation viewtypes is interested in

    \optionA{A deployment view.}
    \optionB{A work assignment view.}
    \optionC{A deployment and a work assignment view.}
    \optionD{A install view.}
 \putOptions
\end{ClosedQuestion}
}

%14
\newcommand{\qImplementationStyle}{
\begin{ClosedQuestion}
	An architecture can also be represented by the set of files which contains its modules code. A suitable architectural style to represent this set of files is

    \optionA{Deployment style.}
    \optionB{Implementation style.}
    \optionC{Install style.}
    \optionD{Work assignment style.}
 \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qInstallStyle}{
\begin{ClosedQuestion}
	An important stage of the development of any system is its build into the set of executable files. A suitable architectural style which helps on the definition of the build process is

    \optionA{Deployment style.}
    \optionB{Implementation style.}
    \optionC{Install style.}
    \optionD{Work assignment style.}
 \putOptions
\end{ClosedQuestion}
}

%16
\newcommand{\qDeploymentStyleLimitExposure}{
\begin{ClosedQuestion}
	An architect needs to show that a security tactic of limit exposure will be effectively provided by the executing system. Therefore, she decides to design
	
    \optionA{A work assignment view.}
    \optionB{A deployment view.}
    \optionC{An install view.}
    \optionD{An implementation view.}
 \putOptions
\end{ClosedQuestion}
}


% DVD Catalog

%17
\newcommand{\qDVDCatalogMeta}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		The application should support other kinds of catalogs (CDs, games, books, ...). 
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The layered view to support a new specific layer for the customization of the catalog.}
    \optionB{The layered view to accommodate a new layer for which kind of catalog, which other layers may use.}
    \optionC{The data model view in order to define entities for each kind of catalog.}
    \optionD{The data model view in order to define generic entities that can be customized for different kinds of catalogs.}
 \putOptions
\end{ClosedQuestion}
}

%18
\newcommand{\qDVDCatalogAspects}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To allow the share of catalogs with family and friends, including some access control. 
	\end{quote}
	
	This requirement requires 
	
    \optionA{A change to the uses view to represent that friends can use each other catalog.}
    \optionB{A change of the layered view to support different presentations, one for each friend.}
    \optionC{A change of the decomposition view to include the responsibilities associated with the access control.}
    \optionD{A new aspect view to include the responsibilities associated with the access control.}
 \putOptions
\end{ClosedQuestion}
}

%19
\newcommand{\qDVDCatalogMobile}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To support iPhone/iPad/Android version with sync, which allows offline use of the application in the mobile device and data synchronization to occur when a connection is available
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The decomposition view to include a module for the synchronization responsibilities.}
    \optionB{The uses view to represent how the mobile device uses the Catalog application.}
    \optionC{The layered view to include a layer for each type of device.}
    \optionD{The domain layer of the layered style to represent the types of devices.}
 \putOptions
\end{ClosedQuestion}
}

%20
\newcommand{\qDVDCatalogMultiPlatform}{
\begin{ClosedQuestion}
	Consider the module viewtype views of the DVDCatalog application. The architect knows about a new requirement 
	
	\begin{quote}
		To support multi-platform (Mac, Windows, Linux)
	\end{quote}
	
	This requirement requires a change of
	
    \optionA{The layered view to deal with the aspects of portability.}
    \optionB{The uses view to show the coupling between the different platforms.}
    \optionC{The uses view to show the uses relationships between the different platforms.}
    \optionD{The data model view to represent each one of the platforms.}
 \putOptions
\end{ClosedQuestion}
}


% Sixth Mini-test


% Amazon Silk vs Google Chrome

%1
\newcommand{\qSilkMobileDevices}{
\begin{ClosedQuestion}
	When comparing Amazon Silk with Google Chrome in the context of mobile devices

    \optionA{Amazon Silk is more convenient for mobile devices because it does most of the computation in the cloud.}
    \optionB{Google Chrome is more convenient for mobile devices because it has an optimized network stack that runs in any kind device.}
    \optionC{Amazon Silk is more convenient for mobile devices because it customizes the number of threads that run in the device.}
    \optionD{Google Chrome is more convenient for mobile devices because content delivery is optimized.}
 \putOptions
\end{ClosedQuestion}
}

%2
\newcommand{\qSilkPredictor}{
\begin{ClosedQuestion}
	When comparing Amazon Silk with Google Chrome in the context of the prediction of pages the user is going to access
	
    \optionA{Amazon Silk predicts accesses based on the information gathered for all Silk users.}
    \optionB{Google Chrome uses a usability maintain system model tactic.}
    \optionC{Amazon Silk predictions are constrained by the amount of information it can store about each user access.}
    \optionD{Google Chrome predictions do not require storage in the client-side.}
 \putOptions
\end{ClosedQuestion}
}

%3
\newcommand{\qSilkCaching}{
\begin{ClosedQuestion}
	When comparing Amazon Silk with Google Chrome  

    \optionA{Amazon Silk explicitly caches pages on the browser to optimize accesses.}
    \optionB{Google Chrome predictor takes into consideration the amount of available cache.}
    \optionC{Amazon Silk cache is not shared between different users of the service to support confidentiality.}
    \optionD{Google Chrome cache is shared among the different users of a desktop machine.}
 \putOptions
\end{ClosedQuestion}
}

%4
\newcommand{\qSilkConnections}{
\begin{ClosedQuestion}
	When comparing Amazon Silk with Google Chrome  
	
    \optionA{In Amazon Silk a request for a web page corresponds to a peer-to-peer interaction between all the web components containing the resources.}
    \optionB{In Google Chrome a request for a web page is accomplished by a single access to the internet.}
    \optionC{In Amazon Silk a request for a web page corresponds to requesting a service from the amazon cloud.}
    \optionD{In Google Chrome a request for a web page aggregates the page on the background before it is sent to the client.}
 \putOptions
\end{ClosedQuestion}
}


% ThousandParsec views

%5 
\newcommand{\qThousandParsecAI}{
\begin{ClosedQuestion}
	Consider the architectural views for the ThousandParsec system. The following diagram depicts a fragment of a proposal for the decomposition view of the system. The AI players should be described
	
	\centering
	\includegraphics[width=10cm]{x-ThousandParsec-ruleset}

    \optionA{As a specialization of the RulesSet module.}
    \optionB{As a submodule of the RulesSet module.}
    \optionC{As a module but not included in the RulesSet subtree.}
    \optionD{As a specialization of the Design module.}
 \putOptions
\end{ClosedQuestion}
}

%6 
\newcommand{\qThousandParsecModule}{
\begin{ClosedQuestion}
	Consider the architectural views for the ThousandParsec system. The following diagram depicts a fragment of a proposal for the decomposition view of the system. The ThousandParsec protocol
	
	\centering
	\includegraphics[width=10cm]{x-ThousandParsec-ruleset}

    \optionA{Should be described as a submodule of the RulesSet module.}
    \optionB{Should be described as a submodule of but not included in the RulesSet subtree.}
    \optionC{Should be described as a submodule of the Design module.}
    \optionD{Should not be described as a module because it is a component.}
 \putOptions
\end{ClosedQuestion}
}

%7 
\newcommand{\qThousandParsecTPConnector}{
\begin{ClosedQuestion}
	Consider the architectural views for the ThousandParsec system. The following diagram depicts a proposal of application-specific types for the architectural components, where the names of the ports are missing. Between the GameClient and GameServer components
	
	\centering
	\includegraphics[width=8cm]{x-ThousandParsec-cc}

    \optionA{There is a ThousandParsec connector.}
    \optionB{There is a Request/Reply connector.}
    \optionC{There is a ThousandParsec connector which can be decomposed into a set of components and Request/Reply connectors.}
    \optionD{There is an EventBus connector.}
 \putOptions
\end{ClosedQuestion}
}

%8 
\newcommand{\qThousandParsecReadWriteConnector}{
\begin{ClosedQuestion}
	Consider the architectural views for the ThousandParsec system. The following diagram depicts a proposal of application-specific types for the architectural components, where the names of the ports are missing. Between the GameServer and Repository component
	
	\centering
	\includegraphics[width=8cm]{x-ThousandParsec-cc}

    \optionA{There is a ThousandParsec connector.}
    \optionB{There is a Read/Write connector which encapsulates a redundant Repository.}
    \optionC{There is a Read/Write connector which guarantees that players turns are not lost.}
    \optionD{There is a Read/Write connector which guarantees that only the turns of the last two players may be lost.}
 \putOptions
\end{ClosedQuestion}
}


% The architecture of OrderPad

%9
\newcommand{\qOrderPadPortability}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. The decision between the use of a Native application or HTML5 on the implementation of the client in the Pad
	
    \optionA{Was taken because HTML5 provides better portability qualities.}
    \optionB{Was taken because Native applications provide better modifiability qualities.}
    \optionC{Was taken because HTML5 provides better usability qualities.}
    \optionD{Was taken because Native application provide better support for working offline.}
 \putOptions
\end{ClosedQuestion}
}

%10
\newcommand{\qOrderPadReliability}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. The connector between the client component, executing in the Pad, and the server component, executing in the OrderPadDatabase
	
    \optionA{Supports asynchronous communication to deal with disconnected mode.}
    \optionB{Implements an event bus that allows the server to inform the client about new order recommendations.}
    \optionC{May loose some of the changes done on the client component.}
    \optionD{Has reduced reliability qualities.}
 \putOptions
\end{ClosedQuestion}
}

%11
\newcommand{\qOrderPadMainframeConnector}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. The final interaction between the OrderPadDatabase component and Mainframe component is supported by 
	
    \optionA{Two distinct unidirectional connectors.}
    \optionB{A single bidirectional connector.}
    \optionC{Three distinct unidirectional connectors.}
    \optionD{A single unidirectional connector.}
 \putOptions
\end{ClosedQuestion}
}

%12
\newcommand{\qOrderPadIterative}{
\begin{ClosedQuestion}
	Consider the architecture of the Morrison's OrderPad. In the description of the system can be read:
	
	\begin{quote}
		One of these was using a file-transfer to send data to the mainframe rather than MQ, which wouldn't perform well once many stores were active.
	\end{quote}
	
	This approach means that
	
    \optionA{Performance was traded for easy of development.}
    \optionB{An iterative development was followed, which allowed more time to develop a connector with good performance in the latter stages of the project.}
    \optionC{Performance was traded for the modifiability quality.}
    \optionD{An incremental development was followed, which allowed to have the system in production without being necessary to export all the information to the mainframe.}
 \putOptions
\end{ClosedQuestion}
}


% SocialCalc Views

%13
\newcommand{\qSocialCalcRemoteCursor}{
\begin{ClosedQuestion}
	Consider the architectural views for the SocialCalc system. The following diagram depicts a proposal for a component-and-connector view of the client Spreadsheet. It can be read in the case description: \emph{A simple improvement is for each client to broadcast its cursor position to other users, so everyone can see which cells are being worked on.}
	
	\centering
	\includegraphics[width=8cm]{x-SocialCalc-cc-client}

    \optionA{The \textsc{: TableEditor} broadcasts the cursor position through the \textsc{: Sheet}.}
    \optionB{An interface delegation is missing in the picture to represent the \textsc{: TableEditor} broadcasting the cursor position through the \textsc{Pub} port.}
    \optionC{The \textsc{: Sheet} broadcasts the cursor position through the \textsc{Pub} port.}
    \optionD{The \textsc{: TableEditor} broadcasts the cursor position through its \textsc{: StatusCallback} port.}
 \putOptions
\end{ClosedQuestion}
}

%14
\newcommand{\qSocialCalcServer}{
\begin{ClosedQuestion}
	Consider the architectural views for the SocialCalc system. The following diagram depicts a proposal for a component-and-connector view of the system. According to this representation
	
	\centering
	\includegraphics[width=8cm]{x-SocialCalc-cc}

    \optionA{The server implements the \textsc{: Repository} component and the \textsc{: Broadcast} connector.}
    \optionB{The server implements the \textsc{: Repository} component.}
    \optionC{The server implements the \textsc{: Broadcast} connector.}
    \optionD{The server implements the \textsc{SpreadSheet} components}
 \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qSocialCalcParser}{
\begin{ClosedQuestion}
	Consider the architectural views for the SocialCalc system. The following diagram depicts a proposal for a component-and-connector view of the client Spreadsheet. A \textsc{Parser} module is used when loading a file
	
	\centering
	\includegraphics[width=8cm]{x-SocialCalc-cc-client}

    \optionA{The \textsc{Parser} module is part of the code executed by the \textsc{: TableEditor} component.}
    \optionB{The \textsc{Parser} module is part of the code executed by the \textsc{: Sheet} component.}
    \optionC{The code of the \textsc{Parser} module is executed by a repository component, which is not represented in the view.}
    \optionD{The code of the \textsc{Parser} module is executed by both, the \textsc{: Sheet} and the repository components (the latter is not visible in the view).}
 \putOptions
\end{ClosedQuestion}
}

%16
\newcommand{\qSocialCalcConflictResolution}{
\begin{ClosedQuestion}
	Consider the architectural views for the SocialCalc system. The following diagram depicts a proposal for a component-and-connector view of the client Spreadsheet. A \textsc{ConflictResolution} module is used when local commands conflict with remote commands.
	
	\centering
	\includegraphics[width=8cm]{x-SocialCalc-cc-client}

    \optionA{The \textsc{ConflictResolution} module is part of the code executed by the \textsc{: TableEditor} component.}
    \optionB{The \textsc{ConflictResolution} module is part of the code executed by the \textsc{: Sheet} component.}
    \optionC{The code of the \textsc{ConflictResolution} module is executed by a broadcast connector that implements an eventbus between the \textsc{SpreadSheet} components.}
    \optionD{The code of the \textsc{ConflictResolution} module is executed in a server component because it needs to be centralized.}
 \putOptions
\end{ClosedQuestion}
}


% Domain Logic and Access Patterns

%17
\newcommand{\qLogicAccessDomainModel}{
\begin{ClosedQuestion}
	When the domain logic is organized using a Domain Model pattern the most suitable data source patterns are

    \optionA{Table Data Gateway and Row Data Gateway.}
    \optionB{Row Data Gateway and Active Record.}
    \optionC{Row Data Gateway and Data Mapper.}
    \optionD{Active Record and Data Mapper.}
 \putOptions
\end{ClosedQuestion}
}

%18
\newcommand{\qLogicAccessTransactionScript}{
\begin{ClosedQuestion}
	When the domain logic is organized using a Transaction Script pattern the most suitable data source patterns are

    \optionA{Table Data Gateway and Row Data Gateway.}
    \optionB{Row Data Gateway and Active Record.}
    \optionC{Row Data Gateway and Data Mapper.}
    \optionD{Active Record and Data Mapper.}
 \putOptions
\end{ClosedQuestion}
}

%19
\newcommand{\qLogicAccessTransactionScriptDomainObjects}{
\begin{ClosedQuestion}
	When the domain logic is organized using a Transaction Script pattern the domain objects

    \optionA{Are responsible for loading the objects they refer to.}
    \optionB{Are responsible for the management of transactions, begin and end of transactions.}
    \optionC{Contain the business logic.}
    \optionD{May not even exist, only record sets are used.}
 \putOptions
\end{ClosedQuestion}
}

%20
\newcommand{\qLogicAccessTableModule}{
\begin{ClosedQuestion}
	When the domain logic is organized using a Table Module pattern 

    \optionA{An object oriented style is followed.}
    \optionB{The business logic is organized around record sets.}
    \optionC{Row Data Gateway is the most suitable data source pattern.}
    \optionD{A Service Layer should be used to provide an interface for the presentation layer.}
 \putOptions
\end{ClosedQuestion}
}






%% =========================================================================
%% exams 2013/2014
%% =========================================================================

\newcommand{\gp}{Graphite}
\newcommand{\mw}{MediaWiki}
\newcommand{\ch}{Chrome}
\newcommand{\gm}{GNU Mailman}

%1-1
\newcommand{\qGPReceiverWriterStyle}{
 \begin{ClosedQuestion}
    No sistema \gp{} as \emph{receiver} e as \emph{writer threads} suportam a escrita assncrona de mtricas de forma a otimizar os acessos a disco. A interao entre estes dois componentes segue o estilo arquitetural

    \optionA{Cliente-servidor}
    \optionB{Processos-comunicantes}
    \optionC{Repositrio}
    \optionD{Canais-e-filtros} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qGPReceiverWriterStyleINGLES}{
 \begin{ClosedQuestion}
    In \gp{} system  the \emph{receiver} and the \emph{writer threads} support asynchronous writing of metrics to optimize disk accesses. The interaction between these two components follow the architectural style

    \optionA{Client-server}
    \optionB{Communicating Processes}
    \optionC{Repository}
    \optionD{Pipes-and-Filters} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%2-2
\newcommand{\qGPCarbonBufferInterface}{
  \begin{ClosedQuestion}
    No sistema \gp{} o componente \emph{carbon} fornece aos componentes \emph{webapp} uma interface de acesso aos \emph{buffers} com o objetivo de melhorar a(s) qualidade(s) de

    \optionA{Desempenho}
    \optionB{Fiabilidade e Desempenho}
    \optionC{Fiabilidade}
    \optionD{Segurana} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGPCarbonBufferInterfaceEN}{
  \begin{ClosedQuestion}
    In the \gp{} system the component \emph{carbon} provides to \emph{webapp} components an access interface to the \emph{buffers} in order to improve the quality(ies) of

    \optionA{Performance}
    \optionB{Reliability and Performance}
    \optionC{Reliability}
    \optionD{Security} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%3-1
\newcommand{\qGPCarbonRelay}{
  \begin{ClosedQuestion}
    No sistema \gp{} o componente \emph{carbon-relay} implementa uma ttica de

    \optionA{Manter Mltiplas Cpias de Computao}
    \optionB{Manter Mltiplas Cpias de Dados}
    \optionC{Redundncia Passiva}
    \optionD{Redundncia Ativa} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGPCarbonRelayINGLES}{
  \begin{ClosedQuestion}
    In the \gp{} system the component \emph{carbon-relay} implements a tactic

    \optionA{Maintain Multiple Copies of Computation}
    \optionB{Maintain Multiple Copies of Data}
    \optionC{Passive Redundancy}
    \optionD{Active Redundancy} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%4-2
\newcommand{\qGPCCView}{
  \begin{ClosedQuestion}
    Uma vista arquitetural de mais alto nvel do tipo Componente-e-Conetor do sistema \gp{} pode ser desenhada usando apenas o(s) estilo(s) arquitetural(ais)

    \optionA{Repositrio e Processos-Comunicantes}
    \optionB{Processos-Comunicantes}
    \optionC{\emph{Tiers}}
    \optionD{Cliente-Servidor e Repositrio} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qGPCCViewEN}{
  \begin{ClosedQuestion}
	  An higher-level component-and-connect view of \gp{} system can be designed using only the architectural style(s)

    \optionA{Repository and Communicating-Processes}
    \optionB{Communicating-Processes}
    \optionC{Tiers}
    \optionD{Client-Server and Repository} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%5-1
\newcommand{\qGPComposerUIQuality}{
  \begin{ClosedQuestion}
    Que qualidade, ou qualidades, do sistema \gp{} (so) expressa(s) na frase: \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL.}

    \optionA{Usabilidade e desempenho}
    \optionB{Usabilidade}
    \optionC{Desempenho}
    \optionD{Facilidade de teste} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qGPComposerUIQualityINGLES}{
  \begin{ClosedQuestion}
	  Which quality, or qualities, of the \gp{} system are described by the sentence: \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL.}

    \optionA{Usability and Performance}
    \optionB{Usability}
    \optionC{Performance}
    \optionD{Testability} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%6-2
\newcommand{\qGPComposerUIPerformance}{
  \begin{ClosedQuestion}
    O componente \emph{Composer UI} do sistema \gp{}, descrito como - \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL} - para ser eficaz necessita de mostrar ao utilizador as alteraes que efetua ao grfico de modo a que este obtenha retorno imediato sobre o resultado de cada uma das alteraes que acaba de fazer. Para isso o sistema deve implementar tticas de

    \optionA{Modelo de Tarefa}
    \optionB{Modelo do Sistema}
    \optionC{Desempenho}
    \optionD{Modelo de Utilizador} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGPComposerUIPerformanceEN}{
  \begin{ClosedQuestion}
	  The \emph{Composer UI} component of \gp{} system, described as - \emph{Graphite's Composer UI provides a point-and-click method to create a graph from which you can simply copy and paste the URL} - to be effective needs to show to the user the changes she performs in the graph such that she has immediate feedback about the result of the changes. To do so, the system needs to implement the tactics of

    \optionA{Task Model}
    \optionB{System Model}
    \optionC{Performance}
    \optionD{User Model} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%7-1
\newcommand{\qMWQualities}{
  \begin{ClosedQuestion}
	  Quais so as principais qualidades do sistema \mw{}?
    
    \optionA{Desempenho, disponibilidade e usabilidade}
    \optionB{Desempenho, disponibilidade e facilidade de teste}
    \optionC{Fiabilidade, desempenho e usabilidade}
    \optionD{Desempenho e usabilidade} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qMWQualitiesINGLES}{
  \begin{ClosedQuestion}
	  Which are the most significant qualities of the \mw{} system?
    
    \optionA{Performance, availability, and usability}
    \optionB{Performance, availability, and testability}
    \optionC{Reliability, performance, and usability}
    \optionD{Performance and usability} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%8-2
\newcommand{\qMWLowCost}{
  \begin{ClosedQuestion}
	  O desenho da arquitetura do sistema \mw{} foi condicionado por uma restrio associada  necessidade de ter uma soluo de baixo custo. Para isso foi tomada a deciso arquitetural de
    
    \optionA{Ter apenas um servidor para escrita}
    \optionB{Guardar toda a informao de forma esttica}
    \optionC{Dar prioridade ao desempenho e disponibilidade em detrimento da funcionalidade}
    \optionD{Usar vrios nveis de \emph{cache}} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qMWLowCostEN}{
  \begin{ClosedQuestion}
	  The design of the \mw{} architecture was constrained the requirement that the solution should have relatively low cost. Due to this restriction it was taken the architectural decision of
    
    \optionA{Only have a server for write requests}
    \optionB{Store all the information statically}
    \optionC{Prioritize performance and availability over functionality}
    \optionD{Use several levels of cache} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%9-1
\newcommand{\qMWArchitecuralStyle}{
  \begin{ClosedQuestion}
	  Os estilos arquiteturais que melhor descrevem o sistema \mw{} do ponto de vista do utilizador final so
    
    \optionA{Cliente-Servidor e Repositrio}
    \optionB{Repositrio e Arquitetura Orientada aos Servios}
    \optionC{Cliente-Servidor, Repositrio, Processos-Comunicantes e Arquitetura Orientada aos Servios}
    \optionD{Cliente-Servidor, Repositrio e Processos-Comunicantes} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qMWArchitecuralStyleINGLES}{
  \begin{ClosedQuestion}
	  The architectural styles which are more suitable to describe the \mw{} system from the end user viewpoint are
    
    \optionA{Client-Server e Repository}
    \optionB{Repository e Service Oriented Architecture}
    \optionC{Client-Server, Repository, Communicating-Processes e Service Oriented Architecture}
    \optionD{Client-Server, Repository e Communicating-Processes} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%10-2
\newcommand{\qMWTactics}{
  \begin{ClosedQuestion}
	  Considere uma vista arquitetural do tipo Componente-e-Conetor do sistema \mw{} em que todos os clientes esto ligados a um servidor atravs de um conetor de pedido-resposta que suporta as qualidades de disponibilidade e desempenho. Este conetor implementa uma ttica de 
    
    \optionA{Redundncia Passiva e Aumento da Eficincia dos Recursos}
    \optionB{Redundncia Ativa e Aumento da Eficincia dos Recursos}
    \optionC{Redundncia Ativa e Manter Mltiplas Cpias de Computao}
    \optionD{Redundncia Passiva e Manter Mltiplas Cpias de Computao} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qMWTacticsEN}{
  \begin{ClosedQuestion}
	  Consider a Component-and-Connector architectural view of the \mw{} system where all the clients are connected to a server through a request-reply connector. This connector implements the tactics
    
    \optionA{Passive Redundancy and Increase Resources Efficiency}
    \optionB{Active Redundancy and Increase Resources Efficiency}
    \optionC{Active Redundancy and Maintain Multiple Copies of Computation}
    \optionD{Passive Redundancy and Maintain Multiple Copies of Computation} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%11-1
\newcommand{\qMWReliabilityTactics}{
  \begin{ClosedQuestion}
	  O sistema \mw{} procura manter um critrio de fiabilidade segundo o qual as alteraes efetuadas por um escritor so consistentemente visualizadas nas suas subsequentes leituras
    
    \optionA{Atravs de uma ttica de Marca de Tempo (\emph{timestamp})}
    \optionB{Atravs de uma ttica de Reinvocao (\emph{retry})}
    \optionC{Guardando a informao junto do cliente usando \emph{cookies}}
    \optionD{Atravs de uma ttica de Transaes} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qMWReliabilityTacticsINGLES}{
  \begin{ClosedQuestion}
	  The \mw{} system tries to enforce a reliability criteria that all the changes done by a writer are consistently visualized in her subsequent reads
    
    \optionA{By using a Timestamp tactic}
    \optionB{By using a Retry tactic}
    \optionC{Storing the information in the client using cookies}
    \optionD{By using a Transactions tactic} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%12-2
\newcommand{\qMWReliabilityImplementation}{
  \begin{ClosedQuestion}
	  O critrio de fiabilidade do sistema \mw{}, segundo o qual as alteraes efetuadas por um escritor so consistentemente preservadas nas suas subsequentes leituras,  implementado 
    
    \optionA{No servidor}
    \optionB{Pelo distribuidor de carga (\emph{load balancer})}
    \optionC{Pelo repositrio}
    \optionD{No cliente} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qMWReliabilityImplementationEN}{
  \begin{ClosedQuestion}
	  The \mw{} system tries to enforce a reliability criteria that all the changes done by a writer are consistently visualized in her subsequent reads. This criteria is implemented
    
    \optionA{In the server}
    \optionB{By the load balancer}
    \optionC{In the repository}
    \optionD{In the client} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%13-2
\newcommand{\qMWReliabilityReadsTactic}{
  \begin{ClosedQuestion}
	  O sistema \mw{} procura assegurar um critrio de fiabilidade segundo o qual a informao escrita h mais de 30 segundos dever estar disponvel para leitura para todos os leitores. Para se alcanar este critrio  implementada uma ttica de  
    
    \optionA{Reincio Escalonado}
    \optionB{Votao}
    \optionC{Funcionamento Degradado}
    \optionD{Tratamento de Excees} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qMWReliabilityReadsTacticEN}{
  \begin{ClosedQuestion}
	  The \mw{} system tries to guarantee a reliability criteria where all information is available to be read by any reader in less than 30 seconds after being written. To achieve this criteria it is implemented a tactic of
    
    \optionA{Escalating Restart}
    \optionB{Voting}
    \optionC{Degradation}
    \optionD{Exception Handling} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%14-1
\newcommand{\qMWReliabilityReadsImplementation}{
  \begin{ClosedQuestion}
	  O sistema \mw{} procura assegurar um critrio de fiabilidade segundo o qual a informao escrita h mais de 30 segundos est disponvel para leitura para todos os leitores, para se alcanar este critrio o distribuidor de carga  
    
    \optionA{Pode deixar de aceitar leituras}
    \optionB{Pode deixar de aceitar escritas}
    \optionC{Pode deixar de aceitar leituras e escritas}
    \optionD{Pode ter de adicionar mais servidores ao \emph{cluster}} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qMWReliabilityReadsImplementationINGLES}{
  \begin{ClosedQuestion}
	  The \mw{} system tries to guarantee a reliability criteria where all information is available to be read by any reader in less than 30 seconds after being written. To achieve this criteria the load balancer 
    
    \optionA{May stop accepting reads}
    \optionB{May stop accepting writes}
    \optionC{May stop accepting reads and writes}
    \optionD{May need to add more servers to the cluster} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%15-1
\newcommand{\qMWResourceLoaderTactic}{
  \begin{ClosedQuestion}
	  Na descrio do sistema \mw{} indica-se que:
	  \newline
	  
	  \emph{To optimize the delivery of JavaScript and CSS assets, the ResourceLoader module was developed to optimize delivery of JS and CSS. Started in 2009, it was completed in 2011 and has been a core feature of MediaWiki since version 1.17. ResourceLoader works by loading JS and CSS assets on demand, thus reducing loading and parsing time when features are unused, for example by older browsers. It also minifies the code, groups resources to save requests, and can embed images as data URIs.}
	  \newline
	  
	  O \emph{ResourceLoader} implementa uma ttica de 
    
    \optionA{Aumentar a Eficincia dos Recursos}
    \optionB{Aumentar os Recursos}
    \optionC{Priorizar Eventos}
    \optionD{Manter Mltiplas Cpias de Dados} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qMWResourceLoaderTacticINGLES}{
  \begin{ClosedQuestion}
	  Consider the following fragment of the \mw{} system description:
	  \newline
	  
	  \emph{To optimize the delivery of JavaScript and CSS assets, the ResourceLoader module was developed to optimize delivery of JS and CSS. Started in 2009, it was completed in 2011 and has been a core feature of MediaWiki since version 1.17. ResourceLoader works by loading JS and CSS assets on demand, thus reducing loading and parsing time when features are unused, for example by older browsers. It also minifies the code, groups resources to save requests, and can embed images as data URIs.}
	  \newline
	  
	  The \emph{ResourceLoader} implements a tactic 
    
    \optionA{Increase Resource Efficiency}
    \optionB{Increase Resources}
    \optionC{Prioritize Events}
    \optionD{Maintain Multiple Copies of Data} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%16-2
\newcommand{\qMWVerBlobTactic}{
  \begin{ClosedQuestion}
	  Na descrio do sistema \mw{} indica-se que:
	  \newline
	  
	  \emph{The first revision of the blob is stored in full, and following revisions to the same page are stored as diffs relative to the previous revision; the blobs are then gzipped. Because the revisions are grouped per page, they tend to be similar, so the diffs are relatively small and gzip works well. The compression ratio achieved on Wikimedia sites nears 98\%.}
	  \newline
	  
	  A transcrio refere uma ttica de 
    
    \optionA{Priorizar Eventos}
    \optionB{Aumentar os Recursos}
    \optionC{Aumentar a Eficincia dos Recursos}
    \optionD{Manter Mltiplas Cpias de Dados} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qMWVerBlobTacticEN}{
  \begin{ClosedQuestion}
	  In the description of \mw{} system we can read:
	  \newline
	  
	  \emph{The first revision of the blob is stored in full, and following revisions to the same page are stored as diffs relative to the previous revision; the blobs are then gzipped. Because the revisions are grouped per page, they tend to be similar, so the diffs are relatively small and gzip works well. The compression ratio achieved on Wikimedia sites nears 98\%.}
	  \newline
	  
	  This description refers to a tactic of 
    
    \optionA{Prioritize Events}
    \optionB{Increase Resources}
    \optionC{Increase Resources Efficiency}
    \optionD{Maintain Multiple Copies of Data} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%17-2
\newcommand{\qCHQualities}{
  \begin{ClosedQuestion}
	  O \ch{}, tal como descrito no caso estudado durante o semestre, foi desenhado para suportar as seguintes qualidades arquiteturais:
    
    \optionA{Segurana e Mobilidade}
    \optionB{Desempenho, Segurana e Interoperabilidade}
    \optionC{Segurana, Desempenho, Usabilidade, Interoperabilidade e Mobilidade}
    \optionD{Segurana, Desempenho, Usabilidade e Mobilidade} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qCHQualitiesEN}{
  \begin{ClosedQuestion}
	 \ch{}, as described in the case study, was designed to support the accomplish the following architectural qualities:
    
    \optionA{Security and Mobility}
    \optionB{Performance, Security and Interoperability}
    \optionC{Security, Performance, Usability, Interoperability and Mobility}
    \optionD{Security, Performance, Usability and Mobility} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%18-1
\newcommand{\qCHSecurityQuality}{
  \begin{ClosedQuestion}
	  No \ch{}, para se atingir a qualidade da segurana, o processo \emph{Browser} implementa uma ttica de
    
    \optionA{Encriptao dos Dados}
    \optionB{Deteo de Intruso}
    \optionC{Limitar Acesso}
    \optionD{Autorizar Atores} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qCHSecurityQualityINGLES}{
  \begin{ClosedQuestion}
	  In \ch{}, to accomplish the security quality, the Browser Process implements a tactic
   
    \optionA{Data Encryption}
    \optionB{Intrusion Detection}
    \optionC{Limit Access}
    \optionD{Authorize Actors} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%19-1
\newcommand{\qCHPerformanceQuality}{
  \begin{ClosedQuestion}
	  No \ch{} pode-se associar um processo \emph{Renderer} a cada \emph{Tab}, o que resulta no aumento do desempenho atravs de uma ttica de 
    
    \optionA{Introduzir Concorrncia}
    \optionB{Manter Mltiplas Cpias de Computao}
    \optionC{Limitar a Exposio}
    \optionD{Redundncia Ativa} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHPerformanceQualityINGLES}{
  \begin{ClosedQuestion}
	  In \ch{} it is possible to associate a Renderer Process to each Tab, which results in the increase of performance due to a tactic of
    
    \optionA{Introduce Concurrency}
    \optionB{Maintain Multiple Copies of Computation}
    \optionC{Limit Exposition}
    \optionD{Active Redundancy} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%20-2
\newcommand{\qCHPerformanceQualityTwo}{
  \begin{ClosedQuestion}
	  Na descrio do caso \ch{} pode-se ler:
	  \newline
	  
	  \emph{Chrome maintains a single instance of the resource dispatcher, which is shared across all render processes, and runs within the browser kernel process.}
	  \newline
	  
	  O \emph{Resource Dispatcher} contribui para aumentar a qualidade do desempenho pois implementa uma ttica de
	      
    \optionA{Escalonamento de Recursos}
    \optionB{Aumento de Recursos}
    \optionC{Introduo de Concorrncia}
    \optionD{Manter Mltiplas Cpias de Computao} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHPerformanceQualityTwoEN}{
  \begin{ClosedQuestion}
	  In the description of \ch{} case study we can read:
	  \newline
	  
	  \emph{Chrome maintains a single instance of the resource dispatcher, which is shared across all render processes, and runs within the browser kernel process.}
	  \newline
	  
	  The \emph{Resource Dispatcher} contributes to the performance quality because it implements a tactic of
	      
    \optionA{Schedule Resources}
    \optionB{Increase Resources}
    \optionC{Introduce Concurrency}
    \optionD{Maintain Multiple Copies of Computation} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%21-1
\newcommand{\qCHMobilityArchitecturalStyle}{
  \begin{ClosedQuestion}
	  
	  Na descrio do caso \ch{} pode-se ler:
	  \newline
	  
	  \emph{On Android devices, Chrome leverages the same multi-process architecture as the desktop version - there is a browser process, and one or more renderer processes. The one difference is that due to memory constraints of the mobile device, Chrome may not be able to run a dedicated renderer for each open tab. Instead, Chrome determines the optimal number of renderer processes based on available memory, and other constraints of the device, and shares the renderer process between the multiple tabs.} 
	  \newline
	  
	  A descrio acima pode ser representada numa vista do tipo Componente-e-Conetor utilizando o estilo arquitetural	  
	  
    \optionA{Publicao-subscrio}
    \optionB{Canais-e-filtros}
    \optionC{Criao e destruio dinmica}
    \optionD{Cliente-servidor} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qCHMobilityArchitecturalStyleINGLES}{
  \begin{ClosedQuestion}
	  In the description of the \ch{} case you can read:
	  \newline
	  
	  \emph{On Android devices, Chrome leverages the same multi-process architecture as the desktop version - there is a browser process, and one or more renderer processes. The one difference is that due to memory constraints of the mobile device, Chrome may not be able to run a dedicated renderer for each open tab. Instead, Chrome determines the optimal number of renderer processes based on available memory, and other constraints of the device, and shares the renderer process between the multiple tabs.} 
	  \newline
	  
	  This description can be represented by a view of viewtype Component-and-Connector using the architectural style
	  
    \optionA{Publication-Subscription}
    \optionB{Pipes-and-Filters}
    \optionC{Dynamic Creation and Destruction}
    \optionD{Client-server} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%22-2
\newcommand{\qCHAmazonSilk}{
  \begin{ClosedQuestion}
	  Uma vantagem do Amazon Silk relativamente ao \ch{} est relacionada com 
	      
    \optionA{Separar o processo de \emph{Renderer} dos restantes processos}
    \optionB{O \emph{browser} efetuar menos pedidos ao servidor}
    \optionC{Utilizar tcnicas de aprendizagem}
    \optionD{Fazer \emph{prefetching}} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHAmazonSilkEN}{
  \begin{ClosedQuestion}
	  An advantage of Amazon Silk when compared with \ch{} is 
	      
    \optionA{Separates the Renderer process from the other processes}
    \optionB{The \emph{browser} needs to make less requests to the server}
    \optionC{Applies machine learning techniques}
    \optionD{Uses prefetching} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%23-1
\newcommand{\qCHAmazonSilkTwo}{
  \begin{ClosedQuestion}
	  Uma vantagem do \ch{} relativamente ao Amazon Silk est relacionada com 
	      
    \optionA{Poder tirar partido da concorrncia}
    \optionB{O \emph{browser} ter que efetuar mais pedidos ao servidor}
    \optionC{Utilizar tcnicas de aprendizagem}
    \optionD{No depender de um servio proprietrio} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qCHAmazonSilkTwoEN}{
  \begin{ClosedQuestion}
	  An advantage of \ch{} when compared with Amazon Silk is 
	      
    \optionA{It can take advantage of concurrency}
    \optionB{The \emph{browser} needs to make more requests to the server}
    \optionC{It uses machine learning techniques}
    \optionD{It does not depend on a proprietary service} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%24-2
\newcommand{\qCHRenderStyle}{
  \begin{ClosedQuestion}
	  Uma vista arquitetural do tipo Componente-e-Conetor que descreva as interaes dentro do componente \emph{Renderer Process} do \ch{} utiliza um estilo arquitetural
	      
    \optionA{Repositrio}
    \optionB{Processos-comunicantes}
    \optionC{Arquitetura orientada aos servios}
    \optionD{Cliente-servidor} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qCHRenderStyleEN}{
  \begin{ClosedQuestion}
	  An architectural view of the Component-and-Connector viewtype that describes the interactions within the Renderer Process component of \ch{}, uses the architectural style
	      
    \optionA{Repository}
    \optionB{Communicating-Processes}
    \optionC{Service-Oriented Architecture}
    \optionD{Client-Server} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%25-1
\newcommand{\qCHSecurityLevel}{
  \begin{ClosedQuestion}
	  Uma das qualidades do \ch{}  executar o cdigo JavaScript dentro de um processo, permitindo isolar possveis interferncias entre a execuo de JavaScripts com diferentes origens. O grau de isolamento
	      
    \optionA{ sempre o mesmo para todas as instncias do \ch{}}
    \optionB{ definido em tempo de compilao do cdigo do \ch{}}
    \optionC{ definido em tempo de inicializao de uma instncia do \ch{}}
    \optionD{Pode variar durante a execuo de cada instncia do \ch{}} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qCHSecurityLevelEN}{
  \begin{ClosedQuestion}
	  One of the qualities of \ch{} is the execution of the JavaScript code inside a process, which allows the isolation against possible interferences between the execution of JavaScript programs that are loaded from different sites. The isolation level
	      
    \optionA{It is always the same for all instances of \ch{}}
    \optionB{It is defined compile-time of \ch{} code}
    \optionC{It is defined during the initialization of each instance of \ch{}}
    \optionD{It can change during the execution of each instance of \ch{}} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%26-2
\newcommand{\qCHOmniboxQualities}{
  \begin{ClosedQuestion}
	  Na descrio do caso \ch{} pode-se ler:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	  
	  A descrio acima refere qualidades de
	      
    \optionA{Usabilidade e Facilidade de Modificao}
    \optionB{Desempenho e Usabilidade}
    \optionC{Disponibilidade e Usabilidade}
    \optionD{Disponibilidade e Desempenho} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qCHOmniboxQualitiesEN}{
  \begin{ClosedQuestion}
	  In the description of the \ch{} case study you can read:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	  
	  This description refers to the qualities of
	      	      
    \optionA{Usability e Modifiability}
    \optionB{Performance e Usability}
    \optionC{Availability e Usability}
    \optionD{Availability e Performance} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%27-1
\newcommand{\qCHOmniboxTactics}{
  \begin{ClosedQuestion}
	  Na descrio do caso \ch{} pode-se ler:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	  
	  A descrio acima refere
	      
    \optionA{A ttica de Manter Modelo de Utilizador}
    \optionB{A ttica de Manter Modelo de Tarefa}
    \optionC{A ttica de Manter Modelo de Sistema}
    \optionD{Tticas de Suportar a Iniciativa do Utilizador} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHOmniboxTacticsEN}{
  \begin{ClosedQuestion}
	  In the description of the \ch{} case study you can read:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	  
	  This description refers to
	      
    \optionA{Maintain User Model tactic}
    \optionB{Maintain Task Model tactic}
    \optionC{Maintain System Model tactic}
    \optionD{Support User Initiative tactics} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%28-2
\newcommand{\qCHPrerenderTactics}{
  \begin{ClosedQuestion}
	  O \ch{} faz em algumas situaes \emph{prerender} de pginas. Para isso tira partido da
	      
    \optionA{Ttica de Introduzir Concorrncia}
    \optionB{Pgina estar em \emph{cache}}
    \optionC{Ttica de Manter Mltiplas Cpias de Computao}
    \optionD{Ttica de Manter Mltiplas Cpias de Dados} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHPrerenderTacticsEN}{
  \begin{ClosedQuestion}
	  In some situations \ch{} prerenders a page. To do it
	      
    \optionA{Uses the Introduce Concurrency tactic}
    \optionB{The page is in cache}
    \optionC{Uses the Maintain Multiple Copies of Computation tactic}
    \optionD{Uses the Maintain Multiple Copies of Data tactic} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%29-1
\newcommand{\qGMPicklePerformance}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{In Mailman 2, the MailList object's state is stored in a file called config.pck, which is just the pickled representation of the MailList object's dictionary. Every Python object has an attribute dictionary called \_\_dict\_\_. So saving a mailing list object then is simply a matter of pickling its \_\_dict\_\_ to a file, and loading it just involves reading the pickle from the file and reconstituting its \_\_dict\_\_.}
  \newline
	  
	  Esta soluo, no obstante simples, trouxe diversos problemas pois a qualidade do desempenho  penalizada devido:
	  
	      
    \optionA{A ser necessrio descomprimir todo o ficheiro, mesmo que para obter apenas parte da sua informao}
    \optionB{A deficincias do algoritmo de compresso e descompresso do \emph{pickle}}
    \optionC{A ser uma soluo especfica de Python}
    \optionD{s limitaes de acesso concorrente a ficheiros } 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qGMPicklePerformanceEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} 
  \newline
  
  \emph{In Mailman 2, the MailList object's state is stored in a file called config.pck, which is just the pickled representation of the MailList object's dictionary. Every Python object has an attribute dictionary called \_\_dict\_\_. So saving a mailing list object then is simply a matter of pickling its \_\_dict\_\_ to a file, and loading it just involves reading the pickle from the file and reconstituting its \_\_dict\_\_.}
  \newline
	  
	  Although simple, this solution resulted in several problems which had a negative impact on performance. This is due to:	  
	      
    \optionA{It is necessary to decompress the complete file, even though if only a small part of the information is needed}
    \optionB{Pickle algorithm is not efficient}
    \optionC{It is a Python specific solution}
    \optionD{Limitations of the concurrent access to files} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%30-2
\newcommand{\qGMRestInteroperability}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{Mailman 3 has adopted the Representational State Transfer (REST) model for external administrative control. REST is based on HTTP, and Mailman's default object representation is JSON. These protocols are ubiquitous and well-supported in a large variety of programming languages and environments, making it fairly easy to integrate Mailman with third party systems. REST was the perfect fit for Mailman 3, and now much of its functionality is exposed through a REST API.}
  \newline
	  
	  Esta soluo permitiu aumentar a qualidade da interoperabilidade pois 
	      
    \optionA{A nova interface utilizador passou a usar a interface REST}
    \optionB{Aplicaes externas podem passar a fazer administrao de listas de correio eletrnico residentes no GNU Mailman}
    \optionC{Aplicaes externas podem passar a ler e enviar mensagens para o \gm{}}
    \optionD{A interface do \gm{} ficou pblica} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qGMRestInteroperabilityEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} case study:
  \newline
  
  \emph{Mailman 3 has adopted the Representational State Transfer (REST) model for external administrative control. REST is based on HTTP, and Mailman's default object representation is JSON. These protocols are ubiquitous and well-supported in a large variety of programming languages and environments, making it fairly easy to integrate Mailman with third party systems. REST was the perfect fit for Mailman 3, and now much of its functionality is exposed through a REST API.}
  \newline
	  
	  This solution allowed increased interoperability because
	      
    \optionA{The new user interface started using the REST interface}
    \optionB{External applications can administrate the GNU Mailman mailing lists}
    \optionC{External applications can read and send messages to \gm{}}
    \optionD{The \gm{} interface became public} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%31-1
\newcommand{\qGMRestModularity}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{Mailman 3 has adopted the Representational State Transfer (REST) model for external administrative control. REST is based on HTTP, and Mailman's default object representation is JSON. These protocols are ubiquitous and well-supported in a large variety of programming languages and environments, making it fairly easy to integrate Mailman with third party systems. REST was the perfect fit for Mailman 3, and now much of its functionality is exposed through a REST API.}
  \newline
	  
	  Esta soluo permitiu:
	      
    \optionA{Aumentar a qualidade da facilidade de modificao pois a nova interface utilizador passou a usar a interface REST}
    \optionB{Aumentar a qualidade da facilidade de modificao pois as aplicaes externas deixaram de usar as funcionalidade de administrao}
    \optionC{Aumentar a qualidade da interoperabilidade pois aplicaes externas podem passar a ler e enviar mensagens para o \gm{}}
    \optionD{Nenhuma das anteriores} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGMRestModularityEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} case study:
  \newline
  
  \emph{Mailman 3 has adopted the Representational State Transfer (REST) model for external administrative control. REST is based on HTTP, and Mailman's default object representation is JSON. These protocols are ubiquitous and well-supported in a large variety of programming languages and environments, making it fairly easy to integrate Mailman with third party systems. REST was the perfect fit for Mailman 3, and now much of its functionality is exposed through a REST API.}
  \newline
	  
	  This solution allowed:
	      
    \optionA{Increase the modifiability quality, because the new user interface was implemented using the REST interface}
    \optionB{Increase the modifiability quality, because external applications stopped using the administrative functionalities}
    \optionC{Increase the interoperability quality, because external applications can read and send messages to \gm{}}
    \optionD{None of the previous options} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%32-2
\newcommand{\qGMPipesFilters}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{Once a message has made its way through the chains and rules and is accepted for posting, the message must be further processed before it can be delivered to the final recipients. For example, some headers may get added or deleted, and some messages may get some extra decorations that provide important disclaimers or information, such as how to leave the mailing list.}
  \newline
	  
	  O estilo arquitetural que se adequa a um processamento flexvel das mensagens 
	      
    \optionA{Processos-Comunicantes}
    \optionB{Cliente-Servidor}
    \optionC{Canais-e-Filtros}
    \optionD{Publicao-Subscrio} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGMPipesFiltersEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} case study:
  \newline
  
  \emph{Once a message has made its way through the chains and rules and is accepted for posting, the message must be further processed before it can be delivered to the final recipients. For example, some headers may get added or deleted, and some messages may get some extra decorations that provide important disclaimers or information, such as how to leave the mailing list.}
  \newline
	  
	  The architectural style that is more accurate to describe the flexible processing of messages is
	      
    \optionA{Communicating-Processes}
    \optionB{Client-Server}
    \optionC{Pipes-and-Filters}
    \optionD{Publish-Subscribe} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%33-1
\newcommand{\qGMPipesFiltersData}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{Once a message has made its way through the chains and rules and is accepted for posting, the message must be further processed before it can be delivered to the final recipients. For example, some headers may get added or deleted, and some messages may get some extra decorations that provide important disclaimers or information, such as how to leave the mailing list.}
  \newline
	  
	  Em que o estilo arquitetural Canais-e-Filtros  usado no tratamento das mensagens. Neste contexto o tipo de dados que  passado entre os filtros 
	      
    \optionA{Uma sequncia de bytes para permitir independncia entre os filtros}
    \optionB{Um objeto estruturado em rvore para possibilitar a execuo simultnea de diversos filtros}
    \optionC{Uma sequncia de bytes para permitir que a ordem de aplicao dos filtros no seja relevante}
    \optionD{Um objeto estruturado em rvore para facilitar o processamento de cada um dos filtros} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qGMPipesFiltersDataEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} case study:
  \newline
  
  \emph{Once a message has made its way through the chains and rules and is accepted for posting, the message must be further processed before it can be delivered to the final recipients. For example, some headers may get added or deleted, and some messages may get some extra decorations that provide important disclaimers or information, such as how to leave the mailing list.}
  \newline
	  
	  The Pipes-and-Filters architectural style is used in the handling of messages. In this context the data type which is sent among the filters is
	      
    \optionA{A sequence of bytes to allow independence between filters}
    \optionB{An object tree to allow the simultaneous execution of several filters}
    \optionC{A sequence of bytes to allow that the order of filters execution is not relevant}
    \optionD{An object tree to simplify the processing of each filter} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%34-2
\newcommand{\qGMDataModel}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{Email messages can act as containers for other types of data, as defined in the various MIME standards. A container message part can encode an image, some audio, or just about any type of binary or text data, including other container parts.}
  \newline
	  
	  O estilo arquitetural que mais se adequa  representao da transcrio acima 
	      
    \optionA{Modelo de Dados}
    \optionB{Decomposio}
    \optionC{Aspetos}
    \optionD{Canais-e-Filtros} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGMDataModelEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} case study:
  \newline
  
  \emph{Email messages can act as containers for other types of data, as defined in the various MIME standards. A container message part can encode an image, some audio, or just about any type of binary or text data, including other container parts.}
  \newline
	  
	  The architectural style that is more accurate to describe this transcription is
	      
    \optionA{Data Model}
    \optionB{Decomposition}
    \optionC{Aspects}
    \optionD{Pipes-and-Filters} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%35-1
\newcommand{\qGMReliabilityFIFO}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} prope-se uma soluo para garantir que nas situaes em que vrios \emph{queue runners} executam sobre a mesma \emph{queue} a entrega de mensagens  feita por ordem de chegada.
  \newline
  
  \emph{There's another side effect of this algorithm that did cause problems during the early design of this system. Despite the unpredictability of email delivery in general, the best user experience is provided by processing the queue files in FIFO order, so that replies to a mailing list get sent out in roughly chronological order.}
	      
    \optionA{A soluo proposta assegura efetivamente a entrega FIFO de mensagens e os vrios processos no necessitam de se sincronizar}
    \optionB{A soluo proposta assegura a entrega FIFO de mensagens mas os vrios processos necessitam de se sincronizar}
    \optionC{A soluo proposta no assegura a entrega FIFO de mensagens, podendo algumas mensagens ser entregues por outra ordem}
    \optionD{A soluo proposta assegura a entrega FIFO de mensagens pois em cada \emph{queue} apenas so colocadas mensagens com intervalos de tempo suficientemente espaados} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGMReliabilityFIFOEN}{
  \begin{ClosedQuestion}
	  In the description of the \gm{} case study it is proposed a solution that, when there are several queue runners executing on the same queue, the delivery of messages is done according to arrival order (FIFO).
  \newline
  
  \emph{There's another side effect of this algorithm that did cause problems during the early design of this system. Despite the unpredictability of email delivery in general, the best user experience is provided by processing the queue files in FIFO order, so that replies to a mailing list get sent out in roughly chronological order.}
  \newline
  
  The proposed solution
	      
    \optionA{Effectively guarantees the FIFO delivery of messages and the queue runners do not need to synchronize}
    \optionB{Guarantees the FIFO delivery of messages but the queue runners need to synchronize}
    \optionC{Does not guarantee the FIFO delivery of messages, some messages may be delivery by a different order}
    \optionD{Guarantees the FIFO delivery of messages because in each \emph{queue} only are stored messages which arrived with a difference of more than one minute} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%36-2
\newcommand{\qGMPerformance}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{...Mailman supports running more than one runner process per queue directory...}
  \newline
  
  Com o objetivo de assegurar
	      
    \optionA{A qualidade do desempenho}
    \optionB{A qualidade da disponibilidade}
    \optionC{A qualidade da fiabilidade}
    \optionD{A entrega FIFO de mensagens} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGMPerformanceEN}{
  \begin{ClosedQuestion}
	  Consider the following transcription of the \gm{} system:
  \newline
  
  \emph{...Mailman supports running more than one runner process per queue directory...}
  \newline
  
  It has the goal to support
	      
    \optionA{The quality of Performance}
    \optionB{The quality of Availability}
    \optionC{The quality of Reliability}
    \optionD{The FIFO delivery of messages} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%37-1
\newcommand{\qGMMasterRunner}{
  \begin{ClosedQuestion}
	  A funo do componente \emph{Master Runner} do \gm{} pode ser representada usando o estilo arquitetural
	      
    \optionA{Cliente-Servidor}
    \optionB{Par-a-Par}
    \optionC{Criao e Destruio Dinmica}
    \optionD{\emph{Tiers}} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGMMasterRunnerEN}{
  \begin{ClosedQuestion}
	  The function of Master Runner component of \gm{} can be represented using an architecture style of
	      
    \optionA{Client-Server}
    \optionB{Peer-to-Peer}
    \optionC{Dynamic Creation and Destruction}
    \optionD{Tiers} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%38
\newcommand{\qGMReliabilityBounce}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{VERP stands for Variable Envelope Return Path, and it is a well-known technique that mailing lists use to unambiguously determine bouncing recipient addresses. When an address on a mailing list is no longer active, the recipient's mail server will send a notification back to the sender. In the case of a mailing list, you want this bounce to go back to the mailing list, not to the original author of the message; the author can't do anything about the bounce, and worse, sending the bounce back to the author can leak information about who is subscribed to the mailing list. When the mailing list gets the bounce, however, it can do something useful, such as disable the bouncing address or remove it from the list's membership.}
  \newline
  
  Esta transcrio descreve qualidade(s) de
	      
    \optionA{Segurana}
    \optionB{Segurana e Facilidade de Teste}
    \optionC{Fiabilidade e Facilidade de Modificao}
    \optionD{Fiabilidade e Facilidade de Teste} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGMReliabilityBounceEN}{
  \begin{ClosedQuestion}
	  Consider the following description of the \gm{} system:
  \newline
  
  \emph{VERP stands for Variable Envelope Return Path, and it is a well-known technique that mailing lists use to unambiguously determine bouncing recipient addresses. When an address on a mailing list is no longer active, the recipient's mail server will send a notification back to the sender. In the case of a mailing list, you want this bounce to go back to the mailing list, not to the original author of the message; the author can't do anything about the bounce, and worse, sending the bounce back to the author can leak information about who is subscribed to the mailing list. When the mailing list gets the bounce, however, it can do something useful, such as disable the bouncing address or remove it from the list's membership.}
  \newline
  
  This transcription describes the quality(ies) of
	      
    \optionA{Security}
    \optionB{Security and Testability}
    \optionC{Reliability and Modifiability}
    \optionD{Reliability and Testability} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%39-1
\newcommand{\qGMMessagesPersistence}{
  \begin{ClosedQuestion}
	  No Mailman 3 as mensagens continuam a ser guardadas persistentemente usando \emph{pickle} pois
	      
    \optionA{Pois cada mensagem no necessita de ser acedida simultaneamente por diversos processos}
    \optionB{Pois \emph{pickle}  eficiente a escrever e a ler mensagens}
    \optionC{Pois cada mensagem  guardada como um ficheiro num diretrio}
    \optionD{Todas as opes anteriores} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qGMMessagesPersistenceEN}{
  \begin{ClosedQuestion}
	  In Mailman 3 messages are still being persistently stored using pickle because
	      
    \optionA{Each messages does not need to be accessed concurrently by several processes}
    \optionB{Pickle can efficiently write and read messages}
    \optionC{Each message is stored as a file in a directory}
    \optionD{Al the previous options} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%40-2
\newcommand{\qGMSwitchboard}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{There is a core Mailman class called Switchboard which provides an interface for enqueuing (i.e., writing) and dequeuing (i.e., reading) the message object tree and metadata dictionary to files in a specific queue directory. Every queue directory has at least one switchboard instance, and every queue runner instance has exactly one switchboard.}
  \newline
  
  Esta transcrio contm informao til para vistas do tipo
	      
      \optionA{Mdulo}
      \optionB{Componente-e-Conetor}
      \optionC{Mdulo e Componente-e-Conetor}
      \optionD{Mdulo mas apenas para o estilo arquitetural Decomposio} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGMSwitchboardEN}{
  \begin{ClosedQuestion}
	  Consider the following description of the \gm{} system:
  \newline
  
  \emph{There is a core Mailman class called Switchboard which provides an interface for enqueuing (i.e., writing) and dequeuing (i.e., reading) the message object tree and metadata dictionary to files in a specific queue directory. Every queue directory has at least one switchboard instance, and every queue runner instance has exactly one switchboard.}
  \newline
  
  This transcription contains relevant information for viewtypes of
	      
      \optionA{Module}
      \optionB{Component-and-Connector}
      \optionC{Module and Component-and-Connector}
      \optionD{Module, but only for the Decomposition architectural style} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%41-1
\newcommand{\qInstallImplementationStyles}{
  \begin{ClosedQuestion}
	  Os estilos arquiteturais Instalao (\emph{Install}) e Implementao (\emph{Implementation})
	      
      \optionA{Afetam mdulos ao sistema de ficheiros}
      \optionB{Diferem no nfase dado  fase de produo e  fase de desenvolvimento do processo de software}
      \optionC{Aplicam-se a conjuntos completamente distintos de ficheiros}
      \optionD{Aplicam-se ao mesmo conjunto de ficheiros} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qInstallImplementationStylesEN}{
  \begin{ClosedQuestion}
	  The Install and Implementation architectural styles
	      
      \optionA{Allocate modules to the file system}
      \optionB{Differ on the emphasis on production and development phases of the software process}
      \optionC{Are applied to completely distinct sets of files}
      \optionD{Are applied to the same set of files} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%42-2
\newcommand{\qFenixThree}{
  \begin{ClosedQuestion}
	  Os requisitos arquiteturalmente significativos da terceira arquitetura do sistema Fnix so
	      
      \optionA{Facilidade de Modificao e Interoperabilidade}
      \optionB{Desempenho e Interoperabilidade}
      \optionC{Facilidade de Desenvolvimento e Desempenho}
      \optionD{Interoperabilidade} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qFenixThreeEN}{
  \begin{ClosedQuestion}
	  The architecturally significant requirements of the third architecture of Fnix are
	      
      \optionA{Modifiability and Interoperability}
      \optionB{Performance and Interoperability}
      \optionC{Easiness of Development and Performance}
      \optionD{Interoperability} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%43-1
\newcommand{\qFenixTwo}{
  \begin{ClosedQuestion}
	  As qualidades arquiteturalmente significativas da segunda arquitetura do sistema Fnix so
	      
      \optionA{Interoperabilidade e Desempenho}
      \optionB{Desempenho e Disponibilidade}
      \optionC{Facilidade de Desenvolvimento e Desempenho}
      \optionD{Facilidade de Modificao e Desempenho} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qFenixTwoEN}{
  \begin{ClosedQuestion}
	  The architecturally significant qualities of the second Fnix architecture are:
	  	      
      \optionA{Interoperability e Performance}
      \optionB{Performance and Availability}
      \optionC{Easy Development and Performance}
      \optionD{Modifiability and Performance} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%44-2
\newcommand{\qFenixOne}{
  \begin{ClosedQuestion}
	  Na primeira arquitetura do sistema Fnix era frequente os programadores esquecerem-se de reservar (\emph{lock}) um objeto no contexto de uma transao. Uma soluo para esta situao pode ser arquiteturalmente descrita usando uma vista com o estilo arquitetural
	      
      \optionA{Decomposio}
      \optionB{Aspetos}
      \optionC{Utilizao}
      \optionD{Modelo de Dados} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qFenixOneEN}{
  \begin{ClosedQuestion}
	  In the Fnix first architecture it was common programmers forget to lock objects in the context of transactions. A solution for this problem can be architecturally described using a view of the architectural style
	      
      \optionA{Decomposition}
      \optionB{Aspects}
      \optionC{Uses}
      \optionD{Data Model} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%45-1
\newcommand{\qElasticityDeferBinding}{
  \begin{ClosedQuestion}
	  A elasticidade de um sistema, entendida como a capacidade do sistema se adaptar com facilidade a alteraes de carga,  muitas vezes apresentada como uma caracterstica necessria para a qualidade da escalabilidade. Para o grau dessa facilidade de adaptao contribuem solues arquiteturais associadas
	      
      \optionA{ ttica de Ligao Diferida (\emph{Defer Binding})}
      \optionB{ ttica de Redundncia Passiva}
      \optionC{ ttica de Redundncia Ativa}
      \optionD{s tticas de Redundncia Passiva e Redundncia Ativa} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qElasticityDeferBindingEN}{
  \begin{ClosedQuestion}
	  The elasticity of a system, defined as its capability to easily adapt to load changes, is often represented as a required property of the scalability quality. For this level of easiness contribute the architectural solutions associated with the following tactic(s)
	      
      \optionA{Defer Binding}
      \optionB{Passive Redundancy}
      \optionC{Active Redundancy}
      \optionD{Passive Redundancy and Active Redundancy} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%46-2
\newcommand{\qInternationalizationTactics}{
  \begin{ClosedQuestion}
	  A internacionalizao da interface utilizador  suportada pela(s) ttica(s)
	      
      \optionA{Modelo de Utilizador e \emph{Undo}}
      \optionB{Modelo de Utilizador}
      \optionC{Modelo de Utilizador e Modelo de Sistema}
      \optionD{Modelo de Sistema} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qInternationalizationTacticsEN}{
  \begin{ClosedQuestion}
	  The internationalization of the user interface is supported by the tactic(s)
	      
      \optionA{User Model and Undo}
      \optionB{User Model}
      \optionC{User Model and System Model}
      \optionD{System Model} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%47-1
\newcommand{\qUnitOfWork}{
  \begin{ClosedQuestion}
	  O padro Unidade de Trabalho (\emph{Unit of Work}) pode ser implementado no servidor aplicacional, enquanto que no repositrio continua a ser necessrio usar transaes para aceder aos dados. Neste caso
	      
      \optionA{Apenas pode ser usada uma poltica otimista de controlo de concorrncia pois as transaes no podem estar abertas durante muito tempo}
      \optionB{Apenas pode ser usada uma poltica pessimista de controlo de concorrncia para evitar os frequentes conflitos nas transaes}
      \optionC{Podem ser usadas polticas pessimistas ou otimistas de controlo de concorrncia}
      \optionD{A gesto transacional  da inteira responsabilidade do repositrio} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qUnitOfWorkEN}{
  \begin{ClosedQuestion}
	  The Unit of Work pattern can be implemented in an application server, while it is still necessary to use transactions in the repository to access to the data. In this situation
	      
      \optionA{It is necessary to use a optimistic concurrency control policy because the transactions cannot be open for a long period}
      \optionB{It is necessary to use a pessimistic concurrency control policy to avoid frequent conflicts in the transactions}
      \optionC{Both, pessimistic and optimistic, concurrency control policies can be used}
      \optionD{Transactional management is the complete responsibility of the repsoitory} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%48-2
\newcommand{\qIdentityMap}{
  \begin{ClosedQuestion}
	  Para se poder implementar o padro Mapa de Identidades (\emph{Identity Map}) 
	      
      \optionA{No  possvel suportar pesquisas SQL no servidor aplicacional}
      \optionB{ necessrio fazer sempre uma pesquisa na base de dados antes de aceder a um objeto}
      \optionC{Todos os acessos aos objetos tm que ser feitos atravs das suas inter-referncias}
      \optionD{ necessrio que cada objeto da base de dados possua um identificador nico} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qIdentityMapEN}{
  \begin{ClosedQuestion}
	  To implement the Identity Map pattern
	      
      \optionA{It is not possible to support SQL searches in the application server}
      \optionB{It is always necessary to search in the database before accessing an object}
      \optionC{All accesses to objects should occur through their inter-references}
      \optionD{It is necessary that each object has a unique identifier} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%49-1
\newcommand{\qAvailabilityVoting}{
  \begin{ClosedQuestion}
	  A qualidade da disponibilidade pode ser suportada pela ttica de votao de forma a identificar faltas de 
	      
      \optionA{Codificao, se os componentes executarem mdulos desenvolvidos por diferentes equipas de desenvolvimento}
      \optionB{Hardware, se houver redundncia de hardware}
      \optionC{Sistema Operativo, se componentes executarem em diferentes sistemas operativos}
      \optionD{Todas as opes anteriores} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qAvailabilityVotingEN}{
  \begin{ClosedQuestion}
	  The availability quality can be supported by a voting tactic in order to identify faults of

      \optionA{Programming, if the components execute modules developed by different teams}
      \optionB{Hardware, if there is hardware redundancy}
      \optionC{Operating Systems, if redundant components execute on top of different operating systems}
      \optionD{All the previous options} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%50-2
\newcommand{\qAvailabilityDefensive}{
  \begin{ClosedQuestion}
	  Na programao defensiva o programador verifica se todos as condies em que os mdulos so invocados esto de acordo com a sua especificao, devendo, caso contrrio, lanar uma exceo por forma a evitar a propagao da falta. Quando a programao defensiva  aplicada no contexto da qualidade da disponibilidade est-se a usar uma ttica de
	      
      \optionA{Tratamento de Excees}
      \optionB{Aumentar o Conjunto de Competncias (\emph{Increase Competence Set})}
      \optionC{Preveno de Excees}
      \optionD{Deteo de Excees} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qAvailabilityDefensiveEN}{
  \begin{ClosedQuestion}
	  In defensive programming the programmer checks that the conditions under which modules are invoked comply with their specification, and if they don't an exception is raised to avoid failure propagation. When defensive programming is followed, in the context of availability quality, we are using a tactic of
	      
      \optionA{Exception Handling}
      \optionB{Increase Competence Set}
      \optionC{Exception Prevention}
      \optionD{Exception Detection} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%51-1
\newcommand{\qSecurityInternalSource}{
  \begin{ClosedQuestion}
	  Nos casos em que a fonte dos ataques  interna  organizao as tticas mais eficazes so
	      
      \optionA{Detetar e Recuperar do Ataque}
      \optionB{Resistir ao Ataque}
      \optionC{Reagir ao Ataque}
      \optionD{Resistir e Reagir ao Ataque} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qSecurityInternalSourceEN}{
  \begin{ClosedQuestion}
	  When the source of an attack is internal to an organization the tactics which are more efective are
	      
      \optionA{Detect and Recover from the attack}
      \optionB{Resist to the attack}
      \optionC{React to the attack}
      \optionD{Resist and React to the attack} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%52-2
\newcommand{\qObserverUses}{
  \begin{ClosedQuestion}
	  No padro de desenho Observador, em que o modelo invoca um mtodo de notificao nos seus observadores sempre que sofre alteraes, pode-se afirmar em termos da relao de Usa do estilo arquitetural Utilizao que
	      
      \optionA{O mdulo Modelo usa o mdulo Observador}
      \optionB{O mdulo Modelo usa o mdulo Observador se forem passados dados na notificao} 
      \optionC{O mdulo Modelo usa o mdulo Observador se forem passados dados complexos na notificao}
      \optionD{No que diz respeito  notificao, o mdulo Modelo no usa o mdulo Observador}
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qObserverUsesEN}{
  \begin{ClosedQuestion}
	  In the Observer design pattern, where the model invokes a notification method on all its observers whenever it is changed, can be said, in what concerns the Uses relation of the Uses architectural style, that
	      
      \optionA{The Model module uses the Observer module}
      \optionB{The Model module uses the Observer module if data is sent in the notification} 
      \optionC{The Model module uses the Observer module if complex data is sent in the notification}
      \optionD{In what concerns the notification, the Model module does not use the Observer module}
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%53-1
\newcommand{\qDataModel}{
  \begin{ClosedQuestion}
	  O detalhe em que se aplica o estilo arquitetural Modelo de Dados pode ser ao nvel conceptual, lgico ou fsico.
	  
      \optionA{Se houver requisitos arquiteturais de desempenho relativos aos acessos aos dados ento deve ser feito at ao nvel fsico}
      \optionB{Deve ser sempre feito at ao nvel fsico}
      \optionC{S deve ser at ao nvel lgico nos casos em que o alvo da implementao for uma base de dados relacional}
      \optionD{Apenas o nvel conceptual  efetivamente necessrio, sendo os restantes opcionais} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qDataModelEN}{
  \begin{ClosedQuestion}
	  The detail that can be used in a view of the Data Model view type can be conceptual, logical or physical.
	  
      \optionA{If there are performance requirements concerning the access to data, then the level of detail should be physical}
      \optionB{It should always consider the physical detail level}
      \optionC{The logical detail level should only be used when the target of implementation is a relational database}
      \optionD{Only the conceptual level is required, the other two levels of detail are optional} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

%54-2
\newcommand{\qUsesLayers}{
  \begin{ClosedQuestion}
	  Considere os estilos arquiteturais Utilizao e Camadas.
	  
      \optionA{Primeiro devem ser desenhadas vistas de Utilizao e de seguida de Camadas}
      \optionB{Primeiro devem ser desenhadas vistas de Camadas e depois de Utilizao}
      \optionC{As vistas de Camadas e de Utilizao no necessitam de ser desenhadas por uma ordem pr-definida}
      \optionD{Sempre que h vistas de Utilizao tem que haver pelo menos uma vista de camadas} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qUsesLayersEN}{
  \begin{ClosedQuestion}
	  Consider the Uses and Layered architectural styles.
	  
      \optionA{The Uses views are designed first}
      \optionB{The Layered view are designed first}
      \optionC{There isn't any predefined order to design Uses and Layered views}
      \optionD{Whenever there is at least one Uses view then a Layered view needs to be designed as well} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%55-1
\newcommand{\qPublishSubscribe}{
  \begin{ClosedQuestion}
	  No estilo arquitetural Publicao-Subscrio os componentes, do ponto de vista da facilidade de modificao dos mdulos que executam
	  
      \optionA{Dependem dos tipos de componentes publicadores}
      \optionB{Dependem apenas dos tipos de eventos}
      \optionC{So totalmente independentes entre si}
      \optionD{Necessitam que seja suportada Ligao Diferida (\emph{Defer Binding}) dinmica dos componentes, publicadores e subscritores, ao conetor para serem totalmente independentes entre si} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qPublishSubscribeEN}{
  \begin{ClosedQuestion}
	  In the Publish-Subscribe architectural style, the components, from the point of view of the modules they execute
	  
      \optionA{Depend on the types of the publishers components}
      \optionB{Only depend on the type of events}
      \optionC{Are completely independent}
      \optionD{It is necessary to support dynamic Defer Binding of components, publishers and subscribers, to the connector to be completely independent} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%56-2
\newcommand{\qSeveralStylesView}{
  \begin{ClosedQuestion}
	  Uma vista arquitetural
	  
      \optionA{Apenas pode possuir um nico estilo arquitetural}
      \optionB{Pode possuir vrios estilos arquiteturais, mas apenas se forem dos tipos vista Componente-e-Conetor e Afetao}
      \optionC{Pode possuir vrios estilos arquiteturais, mas apenas se forem do mesmo tipo vista}
      \optionD{Pode possuir vrios estilos arquiteturais, desde que essa seja a melhor forma de comunicar com um particular grupo de \emph{stakeholders}} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qSeveralStylesViewEN}{
  \begin{ClosedQuestion}
	  An architectural view
	  
      \optionA{Can only contain a single architectural style}
      \optionB{May contain several architectural styles, but only if the are of the Component-and-Connector and Allocation viewtypes}
      \optionC{May contain several architectural styles, but only if they are of the same viewtype}
      \optionD{May contain several architectural styles, if that is the best way to convey the information to a group of stakeholders} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%57-1
\newcommand{\qUsabilityNonArchitectural}{
  \begin{ClosedQuestion}
	  Algumas qualidades de usabilidade no so arquiteturais pois
	  
      \optionA{Apenas dizem respeito aos \emph{web designers}}
      \optionB{Dependem de tticas de desempenho}
      \optionC{Dependem de tticas de disponibilidade}
      \optionD{No so implementadas por nenhuma ttica de usabilidade} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qUsabilityNonArchitecturalEN}{
  \begin{ClosedQuestion}
	  Some usability qualities are not architectural because 
	  
      \optionA{They only concern the web designers}
      \optionB{They are dependent on performance tactics}
      \optionC{They are dependent on availability tactics}
      \optionD{They are not implemented by a usability tactic} 
	  

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

%58-2
\newcommand{\qApplyUses}{
  \begin{ClosedQuestion}
	  O estilo arquitetural Utilizao
	  
      \optionA{Deve ser aplicado apenas aps a vista de decomposio estar terminada}
      \optionB{Pode ser aplicado antes de haver uma vista de decomposio}
      \optionC{Uma vez aplicado numa vista pode levar  reviso da vista de decomposio}
      \optionD{Deve ser sempre aplicado em pelo menos numa vista do sistema} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qApplyUsesEN}{
  \begin{ClosedQuestion}
	  The Uses architectural style
	  
      \optionA{Can only be applied after the Decomposition view is finished}
      \optionB{Can be applied before a Decomposition view is designed}
      \optionC{Once applied in a view may be necessary to change the Decomposition view}
      \optionD{Should be applied in at least a view of the system} 
	  

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%59-1
\newcommand{\qWorldWide}{
  \begin{ClosedQuestion}
	  Num sistema \emph{world-wide}, como o Facebook ou o Amazon
	  
      \optionA{Todas as funcionalidades podem ser transacionais}
      \optionB{Apenas um conjunto restrito de funcionalidades  transacional}
      \optionC{No  necessrio ter propriedades transacionais pois todos os dados esto em memria}
      \optionD{Apenas a propriedade transacional do isolamento  assegurada} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qWorldWideEN}{
  \begin{ClosedQuestion}
	  In world-wide systems like Facebook or Amazon,
	  
      \optionA{All functionalities can be transactional}
      \optionB{Only a small set of functionalities are transactional}
      \optionC{It is not necessary to have transactional properties because all data is in memory}
      \optionD{Only the isolation property of transactions is supported} 
	  

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

%60
\newcommand{\qEnterpriseWide}{
  \begin{ClosedQuestion}
	  Num sistema \emph{enterprise-wide}, como o sistema Fnix,
	  
      \optionA{O comportamento transacional suportado de uma forma transparente  uma vantagem para os programadores}
      \optionB{No  necessrio ter comportamento transacional associado  lgica de negcio}
      \optionC{A arquitetura componente-e-conetor tem que ter trs \emph{Tiers}}
      \optionD{A arquitetura mdulo tem que ter trs Camadas} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}
   
\newcommand{\qEnterpriseWideEN}{
  \begin{ClosedQuestion}
	  In a enterprise-wide system, like Fnix system,
	  
      \optionA{It is an advantage for programmers that the transactional behavior is transparently provided}
      \optionB{It is not necessary to have transactional behavior in the business logic}
      \optionC{The Component-and-Connector architecture needs to have three Tiers}
      \optionD{The Module architecture needs to have three Layers} 
	  

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

% poca Especial

%ee-1
\newcommand{\qGPCarbonBufferInterfaceEE}{
  \begin{ClosedQuestion}
    No sistema \gp{}, com vista a se melhorar o desempenho, o componente \emph{carbon} no escreve imediatamente em disco, usando um \emph{buffer}:

    \optionA{mas penaliza a fiabilidade pois os componentes \emph{webapp} no tm acesso aos dados mais recentes}
    \optionB{mas ainda assim penaliza o desempenho pois os \emph{buffer} facilmente enche}
    \optionC{e melhora a fiabilidade pois  fornecida uma interface para os componentes \emph{webapp} acederem aos dados mais recentes}
    \optionD{e melhora a segurana pois o \emph{buffer} est protegido de ataques} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGPCarbonBufferInterfaceEEEN}{
  \begin{ClosedQuestion}
    In the \gp{} system, in order to improve performance the component \emph{carbon} do not write directly on disk, it uses a buffer instead: 

    \optionA{but this reduces reliability because de webapp components do not access the most recent date}
    \optionB{but it reduces performance, anyway, because the buffer components easily overflow}
    \optionC{and it improves reliability because it also provides an interface that the webapp components can use to access the most recent data}
    \optionD{and it improves security because the buffer is protected agains attacks} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-2
\newcommand{\qGPCarbonRelayEE}{
  \begin{ClosedQuestion}
    No sistema \gp{} o componente \emph{carbon-relay} implementa uma ttica de manter mltiplas cpias de computao, com vista a melhorar a qualidade de

    \optionA{desempenho}
    \optionB{segurana}
    \optionC{facilidade de modificao}
    \optionD{facilidade de utilizao} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGPCarbonRelayEEEN}{
  \begin{ClosedQuestion}
    In the \gp{} system the component \emph{carbon-relay} implements a tactic of maintain multiple copies of computation, in order to improve the quality

    \optionA{performance}
    \optionB{security}
    \optionC{modifiability}
    \optionD{usability} 

    \putOptions
   \end{ClosedQuestion}
}

%ee-3
\newcommand{\qGPWhisperViewTypeEE}{
  \begin{ClosedQuestion}
    Para descrever a estrutura de um ficheiro \emph{whisper} do sistema \gp{} deve-se usar uma vista do tipo vista 

    \optionA{decomposio}
    \optionB{generalizao}
    \optionC{modelo de dados}
    \optionD{utilizao} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGPWhisperViewTypeEEEN}{
  \begin{ClosedQuestion}
	  To describe the structure of a whisper file of the \gp{} system it is necessary to use a view of the viewtype

    \optionA{Decomposition}
    \optionB{Generalization}
    \optionC{Data Model}
    \optionD{Uses} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-4
\newcommand{\qMWLowCostEE}{
  \begin{ClosedQuestion}
	  No desenho da arquitetura do sistema \mw{} foi decidido ter apenas um servidor de escrita
    
    \optionA{pois o desempenho no  muito relevante}
    \optionB{para guardar toda a informao de forma esttica}
    \optionC{devido a se pretender ter uma soluo de baixo custo e reduzida complexidade}
    \optionD{pois no h requisitos de disponibilidade} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qMWLowCostEEEN}{
  \begin{ClosedQuestion}
	  The design of the \mw{} architecture was decided to have a single write server
    
    \optionA{Because performance is not relevant}
    \optionB{To statically store all the information}
    \optionC{To have a low cost solution and with reduced complexity}
    \optionD{Because there are no requirements for availability} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-5
\newcommand{\qMWReliabilityImplementationEE}{
  \begin{ClosedQuestion}
	  O critrio de fiabilidade do sistema \mw{}, segundo o qual as alteraes efetuadas por um escritor so consistentemente preservadas nas suas subsequentes leituras, 
    
    \optionA{pode levar a que escritor receba uma exceo indicando que a informao ainda no est disponvel}
    \optionB{obriga a associar uma marca de tempo a cada escrita}
    \optionC{resulta em que os pedidos do escritor tm prioridade sobre os pedidos dos restantes leitores}
    \optionD{resulta em que o escritor no possa fazer muitas escritas simultneas} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qMWReliabilityImplementationEEEN}{
  \begin{ClosedQuestion}
	  The reliability criteria of the \mw{} system  that all the changes done by a writer are consistently visualized in her subsequent reads,
    
    \optionA{May result in a writer receiving an exception when the information when is not available yet}
    \optionB{Requires that a timestamp is associated with every write}
    \optionC{Results in that the writer requests have priority over all the other all other request}
    \optionD{Results in that the writer cannot do many simultaneous writes} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-6
\newcommand{\qMWQualitiesEE}{
  \begin{ClosedQuestion}
	  Qual das seguintes qualidades no  relevante para o sistema \mw{}?
    
    \optionA{Desempenho}
    \optionB{Facilidade de teste}
    \optionC{Disponibilidade}
    \optionD{Usabilidade} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qMWQualitiesEEEN}{
  \begin{ClosedQuestion}
	  Which of the following qualities are not relevant for the \mw{} system?
    
    \optionA{Performance}
    \optionB{Testability}
    \optionC{Availability}
    \optionD{Usability} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-7
\newcommand{\qMWReliabilityReadsImplementationEE}{
  \begin{ClosedQuestion}
	  O sistema \mw{} procura assegurar um critrio de fiabilidade segundo o qual a informao escrita h mais de 30 segundos est disponvel, para leitura, para todos os leitores. Para se alcanar este critrio o distribuidor de carga pode deixar de aceitar escritas at que
    
    \optionA{Os servidores de leitura tenham respondido a todos os pedidos de leitura}
    \optionB{At que os servidores de leitura se tenham sincronizado com o servidor de escrita}
    \optionC{At que o servidor de escrita tenha processado todas as escritas pendentes}
    \optionD{Durante cerca de 30 segundos} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qMWReliabilityReadsImplementationEEEN}{
  \begin{ClosedQuestion}
	  The \mw{} system tries to guarantee a reliability criteria where all information is available to be read by any reader in less than 30 seconds after being written. To achieve this criteria the load balancer may stop accepting writes until
    
    \optionA{Read servers respond to all requests}
    \optionB{Read servers synchronize with the master server}
    \optionC{Write server had processed all pending writes}
    \optionD{After 30 seconds} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-8
\newcommand{\qMWResourceLoaderTacticEE}{
  \begin{ClosedQuestion}
	  Na descrio do sistema \mw{} indica-se que:
	  \newline
	  
	  \emph{To optimize the delivery of JavaScript and CSS assets, the ResourceLoader module was developed to optimize delivery of JS and CSS. Started in 2009, it was completed in 2011 and has been a core feature of MediaWiki since version 1.17. ResourceLoader works by loading JS and CSS assets on demand, thus reducing loading and parsing time when features are unused, for example by older browsers. It also minifies the code, groups resources to save requests, and can embed images as data URIs.}
	  \newline
	  
	  O \emph{ResourceLoader} suporta a qualidade de
    
    \optionA{Desempenho}
    \optionB{Facilidade de utilizao}
    \optionC{Disponibilidade}
    \optionD{Facilidade de manuteno} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qMWResourceLoaderTacticEEEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of the \mw{} system description:
	  \newline
	  
	  \emph{To optimize the delivery of JavaScript and CSS assets, the ResourceLoader module was developed to optimize delivery of JS and CSS. Started in 2009, it was completed in 2011 and has been a core feature of MediaWiki since version 1.17. ResourceLoader works by loading JS and CSS assets on demand, thus reducing loading and parsing time when features are unused, for example by older browsers. It also minifies the code, groups resources to save requests, and can embed images as data URIs.}
	  \newline
	  
	  The \emph{ResourceLoader} supports a quality
    
    \optionA{Performance}
    \optionB{Usability}
    \optionC{Availability}
    \optionD{Modifiability} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-9
\newcommand{\qCHQualitiesEE}{
  \begin{ClosedQuestion}
	  O \ch{}, tal como descrito no caso estudado durante o semestre, foi desenhado para suportar as seguintes qualidades arquiteturais:
    
    \optionA{Segurana e Mobilidade}
    \optionB{Desempenho, Segurana e Interoperabilidade}
    \optionC{Segurana, Desempenho, Usabilidade, Interoperabilidade e Mobilidade}
    \optionD{Segurana, Desempenho, Usabilidade e Mobilidade} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qCHQualitiesEEEN}{
  \begin{ClosedQuestion}
	 \ch{}, as described in the case study, was designed to support the accomplish the following architectural qualities:
    
    \optionA{Security and Mobility}
    \optionB{Performance, Security and Interoperability}
    \optionC{Security, Performance, Usability, Interoperability and Mobility}
    \optionD{Security, Performance, Usability and Mobility} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-10
\newcommand{\qCHPerformanceQualityEE}{
  \begin{ClosedQuestion}
	  No \ch{}, ao se associar um processo \emph{Renderer} a cada \emph{Tab}, alcanam-se as qualidades de
    
    \optionA{Desempenho e Segurana}
    \optionB{Desempenho}
    \optionC{Segurana}
    \optionD{Mobilidade e Desempenho} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHPerformanceQualityEEEN}{
  \begin{ClosedQuestion}
	  In \ch{} it is possible to associate a Renderer Process to each Tab, which results in the qualities
    
    \optionA{Performance and Security}
    \optionB{Performance}
    \optionC{Security}
    \optionD{Mobility and Performance} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-11
\newcommand{\qCHPrerenderTacticsEE}{
  \begin{ClosedQuestion}
	  O \ch{} faz em algumas situaes \emph{prerender} de pginas. Com isso consegue alcanar qualidades de
	      
    \optionA{Desempenho}
    \optionB{Desempenho e Disponibilidade}
    \optionC{Disponibilidade}
    \optionD{Segurana e Disponibilidade} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHPrerenderTacticsEEEN}{
  \begin{ClosedQuestion}
	  In some situations \ch{} prerenders a page. Therefore it achieves the qualities of
	      
    \optionA{Performance}
    \optionB{Performance and Availability}
    \optionC{Availability}
    \optionD{Security and Availabilty} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-12
\newcommand{\qCHOmniboxTacticsEE}{
  \begin{ClosedQuestion}
	  Na descrio do caso \ch{} pode-se ler:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	  
	  A descrio acima refere qualidade de 
	      
    \optionA{Desempenho e Facilidade de Utilizao}
    \optionB{Segurana e Facilidade de Utilizao}
    \optionC{Desempenho e Segurana}
    \optionD{Desempenho e Disponibilidade} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qCHOmniboxTacticsEEEN}{
  \begin{ClosedQuestion}
	  In the description of the \ch{} case study you can read:
	  \newline
	  
	  \emph{Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and even prerender the page in a hidden tab.} 
	  \newline
	   
	  This description refers to the qualities of
	      
    \optionA{Performance and Usability}
    \optionB{Security and Usability}
    \optionC{Performance and Security}
    \optionD{Performance and Availability} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-13
\newcommand{\qCHAmazonSilkTwoEE}{
  \begin{ClosedQuestion}
	  Arquiteturalmente o \ch{} e o Amazon Silk diferem pois
	      
    \optionA{Apenas um deles tira partido da concorrncia}
    \optionB{Apenas um deles utiliza tcnicas de aprendizagem}
    \optionC{Apenas um deles faz \emph{prefetch}}
    \optionD{Apenas um deles faz uso de um servio proprietrio} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qCHAmazonSilkTwoEEEN}{
  \begin{ClosedQuestion}
	  Architecturally \ch{} and Amazon Silk differ because 
	      
    \optionA{Only one of them take advantage of concurrency}
    \optionB{Only one of them uses machine learning techniques}
    \optionC{Only one of them does prefetch}
    \optionD{Only one of them uses a proprietary service} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-14
\newcommand{\qCHMobilityArchitecturalStyleEE}{
  \begin{ClosedQuestion}
	  
	  Na descrio do caso \ch{} pode-se ler:
	  \newline
	  
	  \emph{On Android devices, Chrome leverages the same multi-process architecture as the desktop version - there is a browser process, and one or more renderer processes. The one difference is that due to memory constraints of the mobile device, Chrome may not be able to run a dedicated renderer for each open tab. Instead, Chrome determines the optimal number of renderer processes based on available memory, and other constraints of the device, and shares the renderer process between the multiple tabs.} 
	  \newline
	  
	  A descrio acima refere uma qualidade, por vezes referida como mobilidade, devido  adaptao s caratersticas do dispositivo. Devido a esta qualidade que outras qualidades podem ser comprometidas.	  
	  
    \optionA{Disponibilidade}
    \optionB{Desempenho e Disponibilidade}
    \optionC{Segurana e Disponibilidade}
    \optionD{Facilidade de modificao} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qCHMobilityArchitecturalStyleEEEN}{
  \begin{ClosedQuestion}
	  In the description of the \ch{} case you can read:
	  \newline
	  
	  \emph{On Android devices, Chrome leverages the same multi-process architecture as the desktop version - there is a browser process, and one or more renderer processes. The one difference is that due to memory constraints of the mobile device, Chrome may not be able to run a dedicated renderer for each open tab. Instead, Chrome determines the optimal number of renderer processes based on available memory, and other constraints of the device, and shares the renderer process between the multiple tabs.} 
	  \newline
	  
	  This description refers to a quality, usually named mobility, due to adaptation to the condition of the device. Due to this quality other qualities can be compromissed
	  
    \optionA{Availability}
    \optionB{Performance and Availability}
    \optionC{Security and Availability}
    \optionD{Usability} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-15
\newcommand{\qGMPicklePerformanceEE}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{In Mailman 2, the MailList object's state is stored in a file called config.pck, which is just the pickled representation of the MailList object's dictionary. Every Python object has an attribute dictionary called \_\_dict\_\_. So saving a mailing list object then is simply a matter of pickling its \_\_dict\_\_ to a file, and loading it just involves reading the pickle from the file and reconstituting its \_\_dict\_\_.}
  \newline
	  
	  Para descrever a estrutura interna do ficheiro config.pck deve-se usar uma vista do estilo arquitetural:
	  
	      
    \optionA{Utilizao}
    \optionB{Aspetos}
    \optionC{Decomposio}
    \optionD{Modelo de dados} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qGMPicklePerformanceEEEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} 
  \newline
  
  \emph{In Mailman 2, the MailList object's state is stored in a file called config.pck, which is just the pickled representation of the MailList object's dictionary. Every Python object has an attribute dictionary called \_\_dict\_\_. So saving a mailing list object then is simply a matter of pickling its \_\_dict\_\_ to a file, and loading it just involves reading the pickle from the file and reconstituting its \_\_dict\_\_.}
  \newline
	  
	  To describe the internal structure of the config.pck file	it should be used a view of the viewtype
	      
    \optionA{Uses}
    \optionB{Aspects}
    \optionC{Decomposition}
    \optionD{Data Model} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-16
\newcommand{\qGMPerformanceEE}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{...Mailman supports running more than one runner process per queue directory...}
  \newline
  
  A qual corresponde a uma ttica de 
	      
    \optionA{Introduzir concorrncia}
    \optionB{Replicao ativa}
    \optionC{Aumentar recursos}
    \optionD{Aumentar a eficincia dos recursos} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGMPerformanceEEEN}{
  \begin{ClosedQuestion}
	  Consider the following transcription of the \gm{} system:
  \newline
  
  \emph{...Mailman supports running more than one runner process per queue directory...}
  \newline
  
  It refers to a tactic of
	      
    \optionA{Introduce concurrency}
    \optionB{Active replication}
    \optionC{Increase resources}
    \optionD{Increase resource efficiency} 

     \putOptions
   \end{ClosedQuestion}
}


%ee-17
\newcommand{\qGMRestModularityEE}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} indica-se que:
  \newline
  
  \emph{Mailman 3 has adopted the Representational State Transfer (REST) model for external administrative control. REST is based on HTTP, and Mailman's default object representation is JSON. These protocols are ubiquitous and well-supported in a large variety of programming languages and environments, making it fairly easy to integrate Mailman with third party systems. REST was the perfect fit for Mailman 3, and now much of its functionality is exposed through a REST API.}
  \newline
	  
	  Esta soluo permitiu:
	      
    \optionA{Melhorar a qualidade da facilidade de modificao pois a nova interface REST esconde a estrutura das mensagens}
    \optionB{Melhorar a qualidade de interoperabilidade pois as aplicaes externas passaram a poder usar as funcionalidade de administrao}
    \optionC{Melhorar a qualidade da interoperabilidade pois aplicaes externas podem passar a ler e enviar mensagens para o \gm{}}
    \optionD{Nenhuma das anteriores} 

     \putOptions
% Resposta: B
   \end{ClosedQuestion}
}

\newcommand{\qGMRestModularityEEEN}{
  \begin{ClosedQuestion}
	  Consider the following fragment of \gm{} case study:
  \newline
  
  \emph{Mailman 3 has adopted the Representational State Transfer (REST) model for external administrative control. REST is based on HTTP, and Mailman's default object representation is JSON. These protocols are ubiquitous and well-supported in a large variety of programming languages and environments, making it fairly easy to integrate Mailman with third party systems. REST was the perfect fit for Mailman 3, and now much of its functionality is exposed through a REST API.}
  \newline
	  
	  This solution allowed:
	      
    \optionA{Improve the modifiability quality, because the new REST interface hides the messages' structure}
    \optionB{Improve the interoperability quality, because external applications can use the administrative functionalities}
    \optionC{Improve the interoperability quality, because external applications can read and send messages to \gm{}}
    \optionD{None of the previous options} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-18
\newcommand{\qGMReliabilityFIFOEE}{
  \begin{ClosedQuestion}
	  Na descrio do \gm{} refere-se:
  \newline
  
  \emph{There's another side effect of this algorithm that did cause problems during the early design of this system. Despite the unpredictability of email delivery in general, the best user experience is provided by processing the queue files in FIFO order, so that replies to a mailing list get sent out in roughly chronological order.}
  \newline
  
  A qualidade que se pretende tratar :
	      
    \optionA{Segurana}
    \optionB{Desempenho}
    \optionC{Disponibilidade}
    \optionD{Facilidade de utilizao} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGMReliabilityFIFOEEEN}{
  \begin{ClosedQuestion}
	  In the description of the \gm{} case study:
  \newline
  
  \emph{There's another side effect of this algorithm that did cause problems during the early design of this system. Despite the unpredictability of email delivery in general, the best user experience is provided by processing the queue files in FIFO order, so that replies to a mailing list get sent out in roughly chronological order.}
  \newline
  
  The quality being addressed is:
	      
    \optionA{Security}
    \optionB{Performance}
    \optionC{Availability}
    \optionD{Usability} 

    \putOptions
   \end{ClosedQuestion}
}

%ee-19
\newcommand{\qGMMessagesPersistenceEE}{
  \begin{ClosedQuestion}
	  No Mailman 3 as mensagens continuam a ser guardadas persistentemente usando \emph{pickle}
	      
    \optionA{Pois cada mensagem no necessita de ser acedida simultaneamente por diversos processos}
    \optionB{Pois a estrutura de dados de uma mensagem  mais facilmente implementada num ficheiro}
    \optionC{Pois  menos eficiente guardar as mensagens numa base de dados relacional}
    \optionD{Todas as opes anteriores} 

     \putOptions
% Resposta: A
   \end{ClosedQuestion}
}

\newcommand{\qGMMessagesPersistenceEEEN}{
  \begin{ClosedQuestion}
	  In Mailman 3 messages are still being persistently stored using pickle because
	      
    \optionA{Each messages does not need to be accessed concurrently by several processes}
    \optionB{The message data structure is easily implemented in a file}
    \optionC{It is not efficient to store the messages in a relational database}
    \optionD{Al the previous options} 

     \putOptions
   \end{ClosedQuestion}
}

%ee-20
\newcommand{\qGMMasterRunnerEE}{
  \begin{ClosedQuestion}
	  A funo do componente \emph{Master Runner} do \gm{} pode ser representada usando o estilo arquitetural
	      
    \optionA{Cliente-Servidor}
    \optionB{Par-a-Par}
    \optionC{Criao e Destruio Dinmica}
    \optionD{\emph{Tiers}} 

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

\newcommand{\qGMMasterRunnerEEEN}{
  \begin{ClosedQuestion}
	  The function of Master Runner component of \gm{} can be represented using an architecture style of
	      
    \optionA{Client-Server}
    \optionB{Peer-to-Peer}
    \optionC{Dynamic Creation and Destruction}
    \optionD{Tiers} 

     \putOptions
   \end{ClosedQuestion}
}


%%ee-21
\newcommand{\qFirstEE}{
  \begin{ClosedQuestion}
    A arquitetura de software de um sistema

    \optionA{ uma vista de alto nvel do sistema com objetivo de perceber quais so os objetivos e as funcionalidades do sistema}
    \optionB{ composta de unidades de cdigo, elementos de execuo, hardware e pessoas, assim como os relacionamentos entre eles}
    \optionC{ um conjunto de regras que a equipa de desenvolvimento deve seguir para desenvolver o sistema}
    \optionD{ um conjunto de diagramas que mostram os elementos de execuo do sistema e os seus relacionamentos}
 
     \putOptions
% Resposta: B
  \end{ClosedQuestion}
}


\newcommand{\qFirstEEEN}{
  \begin{ClosedQuestion}
    The software architecture of a system

    \optionA{Is a high-level view of the system with the purpose of
    understanding what are the system's goals and features}
    \optionB{Is composed of things such as code units, runtime elements,
    hardware, and people, together with the relationships among them}
    \optionC{Is a set of guidelines that the developing team should
    follow in the development of the system}
    \optionD{Is a set of diagrams that show the runtime elements of the
    system and their relationships}
 
     \putOptions
  \end{ClosedQuestion}
}

%%ee-22
\newcommand{\qSecondEE}{
\begin{ClosedQuestion}
	A dcumentao da arquitetura de software de um sistema  frequentemente composta de diferentes vistas, pois

  \optionA{ necessria uma vista para cada \emph{stakeholder} do sistema}
  \optionB{Uma vista apenas pode ser muito simplista}
  \optionC{As vistas descrevem diferentes aspetos do sistema}
  \optionD{Todas as anteriores}
  \putOptions
% Resposta: c
  \end{ClosedQuestion}
}

\newcommand{\qSecondEEEN}{
\begin{ClosedQuestion}
  The documentation of the software architecture for a system is often
  composed of several views, because

  \optionA{We need one view for each system stakeholder}
  \optionB{A single view would be too simplistic}
  \optionC{The views describe different aspects of the system}
  \optionD{All of the above}
  \putOptions
  \end{ClosedQuestion}
}

%%ee-23
\newcommand{\qThirdEE}{
\begin{ClosedQuestion}
	Estabecer uma conveno de programao como 
  \begin{quote}
	  Todas as variveis globais do sistema devem comear pelo prefixo
    \textsc{g\_}, enquanto que as variveis no-globais no possuem \emph{underscores} no nome
  \end{quote}

  \optionA{Nunca  uma deciso arquitetural pois  de demasiado baixo nvel}
  \optionB{ sempre uma deciso arquitetural pois aplica-se a todo o programa}
  \optionC{Pode ser uma deciso arquitetural, dependendo dos requisitos do sistema}
  \optionD{Pode ser uma deciso arquitetural, dependendo da experincia do arquiteto}
  
  \putOptions
% Resposta: c
  \end{ClosedQuestion}
}

\newcommand{\qThirdEEEN}{
\begin{ClosedQuestion}
  Establishing a programming convention such as 
  \begin{quote}
    All of the global variables of the program should start with the
    prefix \textsc{g\_}, whereas all the non-global variables have
    no underscores in their name.
  \end{quote}

  \optionA{Is never an architectural decision because it is too low-level}
  \optionB{Is always an architectural decision because it applies to
  the entire program}
  \optionC{May be an architectural decision, depending on the
  requirements for the system}
  \optionD{May be an architectural decision, depending on the
  architect's experience}
  
  \putOptions
  \end{ClosedQuestion}
}

%%ee-24
\newcommand{\qFourthEEEN}{
\begin{ClosedQuestion}
  Assume that one of the requirements for a graphical chess game is
  that it should be able to run both in Microsoft's Windows and
  Apple's Mac OS X operating systems.  A good solution for this system
  would:

  \optionA{Create a decomposition where there is a module corresponding
  to the Windows OS and another one for the Mac OS X, each one
  encapsulating the behavior of the corresponding OS}
  \optionB{Use a classic 3-layer architecture with the following
  layers, from top to bottom: Presentation, Domain Logic, and Data
  Access}
  \optionC{Use a layered architecture, where the bottommost layer
  provides an interface for creating a graphical interface}
  \optionD{Use two deployment views, each one allocating different
  components to different machines with different operating systems}

  \putOptions
% Resposta: a
\end{ClosedQuestion}
}

\newcommand{\qFourthEE}{
\begin{ClosedQuestion}
	Considere que um dos requisitos de um jogo de xadrez com um interface grfica  que seja possvel executar nos sistemas operativos Microsoft Windows e 
  Apple Mac OS X. Uma boa soluo para este sistema deveria:

  \optionA{Criar uma decomposio em que h um mdulo correspondente ao Windows OS e outro ao Mac OS X, em que cada um destes mdulos encapsula o comportamento dos respetivos sistemas operativos}
  \optionB{Utilizar uma arquitetura de 3 camadas com as seguintes camadas, de cima para baixo: Apresentao, Lgica de Domnio, Acesso a Dados}
  \optionC{Utilizar uma arquitetura de camadas em que o nvel mais baixo fornece uma interface para criar uma interface grfica}
  \optionD{Utilizar duas vistas de implantao, em que cada uma delas atribui diferentes componentes a diferentes mquinas com diferentes sistemas operativos}

  \putOptions
% Resposta: a
\end{ClosedQuestion}
}

%%ee-25
\newcommand{\qFifthEE}{
\begin{ClosedQuestion}
	Um outro requisito do jogo de xadrez da pergunta anterior  que mantem uma tabela com as melhores pontuaes do jogo. Naturalmente, esta informao deve ser mantida entre duas diferentes execues do sistema. Assumindo que o jogo  uma aplicao de \emph{desktop}

  \optionA{Devemos usar um estilo Utilizao}
  \optionB{Devemos usar uma arquitetura de camadas com uma camada de acesso a dados}
  \optionC{Devemos identificar um mdulo para escrever as pontuaes num estilo Decomposio}
  \optionD{Devemos atribuir a responsabilidade de escrever as pontuaes para um outro mdulo que j tenha essas responsabilidades}

  \putOptions
  % Resposta b
\end{ClosedQuestion}
}

\newcommand{\qFifthEEEN}{
\begin{ClosedQuestion}
  Another requirement for the chess game from the previous questions
  is that it keeps a table with the best scores obtained in the game.
  Naturally, this information should be kept between two different
  executions of the system.  Assuming that the game is a desktop
  application, then

  \optionA{We must use a Uses style}
  \optionB{We must use a layered architecture with a ``Data Access''
  layer}
  \optionC{We must identify a module for writing the scores in a
  Decomposition style}
  \optionD{We may assign the responsibility of writing the scores to
  another module that already has other responsibilities}

  \putOptions
\end{ClosedQuestion}
}

%%ee-26
\newcommand{\qSixthEE}{
\begin{ClosedQuestion}
	Para se obter um rpido \emph{time-to-market}, as companhias de software esto a usar cada vez mais estratgias de entregas incrementais, em que cada nova entrega contm novas funcionalidades. Que estilo arquitetural  melhor para analisar se a arquitetura de software do sistema se adequa  entrega incremental de verses do sistema?
 
  \optionA{O estilo Decomposio}
  \optionB{O estilo Implantao}
  \optionC{O estilo Utilizao}
  \optionD{O estilo Atribuio de trabalho}
  
  \putOptions
% Resposta: c
\end{ClosedQuestion}
}

\newcommand{\qSixthEEEN}{
\begin{ClosedQuestion}
  To achieve a faster time-to-market, software companies are
  increasingly using a strategy of incremental releases of their
  software, where each new release has a set of new features.  Which
  architectural style is better to analyse whether the system's
  software architecture is adequate for the planned incremental
  releases?
 
  \optionA{The Decomposition style}
  \optionB{The Deployment style}
  \optionC{The Uses style}
  \optionD{The Work-assignment style}
  
  \putOptions
\end{ClosedQuestion}
}

%%ee-27
\newcommand{\qSeventhEE}{
\begin{ClosedQuestion}
	Qual das seguintes frases melhor descreve o relao entre mdulos e componentes?

  \optionA{Um mdulo pode conter cdigo de diversos componentes}
  \optionB{Um componente pode executar cdigo de diversos mdulos}
  \optionC{Um mdulo pode executar cdigo de diversos componentes}
  \optionD{Um componente pode conter cdigo de diversos mdulos}
  
  \putOptions
% Resposta: b
\end{ClosedQuestion}
}

\newcommand{\qSeventhEEEN}{
\begin{ClosedQuestion}
  Which of the following phrases best describe the relationship
  between modules and components?

  \optionA{A module may contain code from different components}
  \optionB{A component may execute code from different modules}
  \optionC{A module may execute code from different components}
  \optionD{A component may contain code from different modules}
  
  \putOptions
\end{ClosedQuestion}
}

%%ee-28
\newcommand{\qEighthEE}{
\begin{ClosedQuestion}
	O padro \emph{Transaction Script}

  \optionA{Necessita de uma equipa mais capaz, pois  difcil de desenvolver}
  \optionB{Permite desenvolvimento independente com reduzida comunicao entre os membros da equipa}
  \optionC{ melhor para domnios complexos, por causa de ser fcil de manter}
  \optionD{Nenhum dos anteriores}

  \putOptions
% Resposta: b
\end{ClosedQuestion}
}

\newcommand{\qEighthEEEN}{
\begin{ClosedQuestion}
  The Transaction Script pattern

  \optionA{Requires a more skilled team, because it is harder to develop}
  \optionB{Allows independent development with little communication
  between the team members}
  \optionC{Is better for more complex domains, because it becomes
  easier to maintain}
  \optionD{None of the above}

  \putOptions
\end{ClosedQuestion}
}


%%ee-29
\newcommand{\qNinethEE}{
\begin{ClosedQuestion}
	O padro \emph{Service Layer}  frequentemente usado em conjuntamente com
 
  \optionA{O padro \emph{Transaction Script} para ajudar a demarcar as transaes de negcio}
  \optionB{O padro Modelo de Domnio para reduzir a interface da camada de lgica de negcio para um conjunto controlado de funcionalidades}
  \optionC{A camada de acesso a dados para poder aceder aos dados que necessita em cada servio}
  \optionD{Nenhum dos anteriores}

  \putOptions
% Resposta: b
\end{ClosedQuestion}
}

\newcommand{\qNinethEEEN}{
\begin{ClosedQuestion}
  The Service Layer pattern is often used in conjunction with
 
  \optionA{The Transaction Script pattern to help demarcate the
  business transactions}
  \optionB{The Domain Model pattern to reduce the interface of the
  Domain Logic layer to a controlled set}
  \optionC{The Data Access layer to be able to access the data that it
  needs in each service}
  \optionD{None of de above}

  \putOptions
\end{ClosedQuestion}
}

%%ee-30
\newcommand{\qTenthEE}{
\begin{ClosedQuestion}
	O padro \emph{Identity Map}  usado
 
  \optionA{Para impedir os dados de ficarem incoerentes quando h mltiplos acessos dentro da mesma transao de negcio  mesma entidade}
  \optionB{Para aumentar o desempenho da aplicao, porque faz cache dos valores previamente carregados em memria, desta forma reduzindo o nmero de acessos  base de dados}
  \optionC{Para evitar carregar muitos dados da base de dados quando uma dada entidade que tem muitas relaes com outras entidades  carregada}
  \optionD{Nenhuma das anteriores}

  \putOptions
% Resposta: a
\end{ClosedQuestion}
}

\newcommand{\qTenthEEEN}{
\begin{ClosedQuestion}
  The Identity Map pattern is used
 
  \optionA{To prevent that data becomes incoherent when there are
  multiple accesses within the same business operation to the same
  entity}
  \optionB{To increase the performance of the application, because it
  caches previously loaded values in memory, thereby reducing the
  number of round-trips to the database}
  \optionC{To avoid loading many data from the database when a given
  entity that has many relationships with other entities is loaded}
  \optionD{None of the above}

  \putOptions
\end{ClosedQuestion}
}




%% =========================================================================
%% exam2 2012/2013
%% =========================================================================

\newcommand{\ghc}{Glasgow Haskell Compiler}

%1
\newcommand{\qGHCBlockLayer}{
  \begin{ClosedQuestion}
    O documento que descreve o \ghc{} apresenta duas decises de
    desenho relativamente ao desenvolvimento do \emph{Runtime System}.
    A primeira dessas decises  descrita da seguinte forma:
    \begin{quote}
      The garbage collector is built on top of a block layer that
      manages memory in units of blocks, where a block is a multiple
      of 4 KB in size. The block layer has a very simple API: [...].
      This is the only API used by the garbage collector for
      allocating and deallocating memory.  Blocks of memory are
      allocated with \texttt{allocGroup} and freed with
      \texttt{freeGroup}.
    \end{quote}
    Que estilo arquitectural lhe parece mais adequado para representar
    esta deciso de desenho?

    \optionA{O estilo Decomposio (\emph{Decomposition})}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo Camadas (\emph{Layers})}
    \optionD{O estilo Processos Comunicantes (\emph{Communicating Processes})}

    \putOptions
% Resposta: C
   \end{ClosedQuestion}
}


\newcommand{\qGHCBlockLayerINGLES}{
  \begin{ClosedQuestion}
    The document describing the \ghc{} presents two design decisions
    about the development of the \emph{Runtime System}.  The first of
    those decisions is described like this:
    \begin{quote}
      The garbage collector is built on top of a block layer that
      manages memory in units of blocks, where a block is a multiple
      of 4 KB in size. The block layer has a very simple API: [...].
      This is the only API used by the garbage collector for
      allocating and deallocating memory.  Blocks of memory are
      allocated with \texttt{allocGroup} and freed with
      \texttt{freeGroup}.
    \end{quote}
    Which architectural style is more adequate to represent this
    design decision?

    \optionA{The \emph{Decomposition} style}
    \optionB{The \emph{Client-Server} style}
    \optionC{The \emph{Layers} style}
    \optionD{The \emph{Communicating Processes} style}

    \putOptions
% Resposta: C
   \end{ClosedQuestion}
}



%2
\newcommand{\qGHCBlockLayerQualities}{
  \begin{ClosedQuestion}
    Qual foi o principal objectivo dos autores do GHC ao tomar a
    deciso de desenho descrita na pergunta anterior?
    
    \optionA{Aumentar o desempenho do RTS}
    \optionB{Permitir mudar o algoritmo de GC sem afectar o resto do sistema}
    \optionC{Aumentar o desempenho dos programas que so compilados
      pelo GHC}
    \optionD{Tornar o RTS mais facilmente portvel para outros
      sistemas operativos}
    
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qGHCBlockLayerQualitiesINGLES}{
  \begin{ClosedQuestion}
    What was the main goal of the GHC's authors that led them to the
    design decision described in the previous question?
    
    \optionA{To increase the performance of RTS}
    \optionB{To allow changing the GC algorithm without affecting the
      rest of the system}
    \optionC{To increase the performance of the programs compiled by
      the GHC}
    \optionD{To make the RTS more portable to other operating systems}
    
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}


%3
\newcommand{\qGHCRewriteRules}{
  \begin{ClosedQuestion}
    Alguns dos \emph{architectural drivers} do \ghc{} esto
    relacionados com a extensibilidade do sistema, e uma das solues
    adoptadas pelos autores do GHC para providenciar essa
    extensibilidade foi a introduo de \emph{user-defined rewrite
      rules}, descrita no documento da seguinte forma:
    \begin{quote}
      The core of GHC is a long sequence of optimisation passes, each
      of which performs some semantics-preserving transformation,
      \texttt{Core} into \texttt{Core}.  But the author of a library
      defines functions that often have some non-trivial,
      domain-specific transformations of their own, ones that cannot
      possibly be predicted by GHC.  So GHC allows library authors to
      define rewrite rules that are used to rewrite the program during
      optimisation.  In this way, programmers can, in effect, extend
      GHC with domain-specific optimisations.
    \end{quote}
    Como  que esta soluo se manifesta ao nvel da arquitectura do
    sistema?

    \optionA{No se manifesta, visto que isso corresponde apenas a
      mais uma extenso  linguagem Haskell que o compilador tem que
      processar}
    \optionB{Na existncia de um componente do compilador que 
      responsvel por interpretar e aplicar as \emph{rewrite rules}
      durante a compilao de um programa}
    \optionC{Numa vista do estilo Generalizao que inclui um mdulo
      que define a interface abstracta que todas as \emph{rewrite
        rules} devem implementar e do qual os mdulos com as
      \emph{rewrite rules} so especializaes}
    \optionD{Numa vista do estilo Canais-e-filtros, correspondendo ao
      processo de compilao de um programa Haskell, em que se
      adiciona um novo filtro sempre que uma nova \emph{rewrite rule}
       definida}

    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qGHCRewriteRulesINGLES}{
  \begin{ClosedQuestion}
    Some of the \emph{architectural drivers} of the \ghc{} are related
    with the system's extensibility, and one of the solutions adopted
    by its authors to provide that extensibility was the introduction
    of \emph{user-defined rewrite rules}, described in the document as
    follows:
    \begin{quote}
      The core of GHC is a long sequence of optimisation passes, each
      of which performs some semantics-preserving transformation,
      \texttt{Core} into \texttt{Core}.  But the author of a library
      defines functions that often have some non-trivial,
      domain-specific transformations of their own, ones that cannot
      possibly be predicted by GHC.  So GHC allows library authors to
      define rewrite rules that are used to rewrite the program during
      optimisation.  In this way, programmers can, in effect, extend
      GHC with domain-specific optimisations.
    \end{quote}
    How does this solution manifests in the software architecture of
    the system?

    \optionA{It does not manifest, as it corresponds only to an
      extension to the Haskell language that must be processed by the
      compiler}
    \optionB{In the existence of a compiler component that is
      responsible for interpreting and applying the rewrite rules
      during the compilation of a program}
    \optionC{In a view of the Generalization style that includes a
      module defining an abstract interface that all \emph{rewrite
        rules} must implement and of which all modules with the 
      \emph{rewrite rules} are specializations}
    \optionD{In a view of the Pipes-and-Filters style, corresponding
      to the process of compiling an Haskell program, to which is
      added a new filter whenever a new \emph{rewrite rule} is
      defined}

    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}


%4
\newcommand{\qGHCCodeGeneration}{
  \begin{ClosedQuestion}
    No documento que descreve o \ghc{} pode ler-se o seguinte:
    \begin{quote}
      Once the \texttt{Core} program has been optimised, the process
      of code generation begins.  The code generator first converts
      the \texttt{Core} into a language called \texttt{STG}, which is
      essentially just \texttt{Core} annotated with more information
      required by the code generator.  Then, \texttt{STG} is
      translated to \texttt{Cmm}, a low-level imperative language with
      an explicit stack.  From here, the code takes one of three
      routes:
      \begin{itemize}
      \item Native code generation: [...]
      \item LLVM code generation: [...]
      \item C code generation: [...]
      \end{itemize}
    \end{quote}
    Ou seja, o GHC pode usar um de trs geradores de cdigo
    alternativos, que tm qualidades diferentes (omitidas no excerto
    apresentado acima).  Supondo que quer apresentar um diagrama
    arquitectural para representar a descrio apresentada acima, qual
    lhe parece mais adequado?

    \optionA{Um diagrama do tipo de vista componente-e-conector, onde
      se mostre o fluxo de dados entre os vrios componentes do
      compilador}
    \optionB{Um diagrama do tipo de vista mdulo, onde se mostre a
      decomposio do compilador nos vrios mdulos que so
      responsveis por cada uma das etapas do processo de compilao}
    \optionC{Um diagrama do tipo de vista mdulo, onde se mostre que
      mdulos usam que outros mdulos}
    \optionD{Um diagrama de camadas, onde exista uma camada
      responsvel pela gerao do cdigo}
    \putOptions
    
    % Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qGHCCodeGenerationINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes the \ghc{}:
    \begin{quote}
      Once the \texttt{Core} program has been optimised, the process
      of code generation begins.  The code generator first converts
      the \texttt{Core} into a language called \texttt{STG}, which is
      essentially just \texttt{Core} annotated with more information
      required by the code generator.  Then, \texttt{STG} is
      translated to \texttt{Cmm}, a low-level imperative language with
      an explicit stack.  From here, the code takes one of three
      routes:
      \begin{itemize}
      \item Native code generation: [...]
      \item LLVM code generation: [...]
      \item C code generation: [...]
      \end{itemize}
    \end{quote}
    That is, GHC may use one of three alternative code generators,
    which have different qualities (omitted in the excerpt presented
    above).  Supposing that you want to present an architectural
    diagram to represent the description presented above, which one
    seems more adequate?

    \optionA{A diagram of the component-and-connector viewtype,
      showing the data flow between the various compiler components}
    \optionB{A diagram of the module viewtype, showing a decomposition
      of the compiler in the various modules that are responsible by
      each of the compilation process steps}
    \optionC{A diagram of the module viewtype, showing which modules
      use other modules}
    \optionD{A layered diagram, where there is a layer responsible for
      the code generation}
    \putOptions
    
    % Resposta: A
  \end{ClosedQuestion}
}


%5
\newcommand{\qGHCAsLibrary}{
  \begin{ClosedQuestion}
    No documento que descreve o \ghc{} pode ler-se o seguinte:
    \begin{quote}
      As the popularity of the Haskell language has grown, there has
      been an increasing need for tools and infrastructure that
      understand Haskell source code, and GHC of course contains a lot
      of the functionality necessary for building these tools: a
      Haskell parser, abstract syntax, type checker and so on.  With
      this in mind, we made a simple change to GHC: rather than
      building GHC as a monolithic program, we build GHC as a library,
      that is then linked with a small Main module to make the GHC
      executable itself, but also shipped in library form so that
      users can call it from their own programs.  At the same time we
      built an API to expose GHC's functionality to clients.
    \end{quote}
    Supondo que quer apresentar um diagrama arquitectural para
    representar a descrio apresentada acima, qual lhe parece mais
    adequado?
    
    \optionA{Um diagrama do tipo de vista componente-e-conector}
    \optionB{Um diagrama do tipo de vista mdulo}
    \optionC{Um diagrama do estilo Instalao (\emph{deployment})}
    \optionD{Um diagrama do estilo Implementao (\emph{Implementation})}

    % Resposta: B
    \putOptions
  \end{ClosedQuestion}
}

\newcommand{\qGHCAsLibraryINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes the \ghc{}:
    \begin{quote}
      As the popularity of the Haskell language has grown, there has
      been an increasing need for tools and infrastructure that
      understand Haskell source code, and GHC of course contains a lot
      of the functionality necessary for building these tools: a
      Haskell parser, abstract syntax, type checker and so on.  With
      this in mind, we made a simple change to GHC: rather than
      building GHC as a monolithic program, we build GHC as a library,
      that is then linked with a small Main module to make the GHC
      executable itself, but also shipped in library form so that
      users can call it from their own programs.  At the same time we
      built an API to expose GHC's functionality to clients.
    \end{quote}
    Which architectural diagram is more adequate to represent the
    information presented above?
    
    \optionA{A diagram of the component-and-connector viewtype}
    \optionB{A diagram of the module viewtype}
    \optionC{A diagram of the deployment style}
    \optionD{A diagram of the implementation style}

    % Resposta: B
    \putOptions
  \end{ClosedQuestion}
}




%6
\newcommand{\qnginxCTenKProblem}{
  \begin{ClosedQuestion}
    O principal \emph{architectural driver} para o sistema nginx foi
    conseguir resolver o \emph{problema C10K}: conseguir manter 10.000
    ligaes simultneas num nico servidor a executar em
    \emph{hardware} convencional.  Para isso acontecer, foi preciso
    que o nginx

    \optionA{Tivesse um \emph{throughput} maior do que o Apache}
    \optionB{Conseguisse processar cada pedido mais rapidamente do que
      o Apache}
    \optionC{Conseguisse lanar mais \emph{threads} simultneas do que
      o Apache}
    \optionD{Conseguisse reduzir a quantidade de memria necessria
      para cada ligao}
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qnginxCTenKProblemINGLES}{
  \begin{ClosedQuestion}
    The main \emph{architectural driver} for the nginx system was to
    solve the \emph{C10K problem}: being able to maintain 10.000
    simultaneous connections with a single server running on
    conventional hardware.  For this o happen, nginx must

    \optionA{Have a throughput higher than Apache}
    \optionB{Be able to process each request faster than Apache}
    \optionC{Be able to launch more simultaneous threads than Apache}
    \optionD{Be able to reduce the amount of memory needed for each connection}
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}


%7
\newcommand{\qnginxProcesses}{
  \begin{ClosedQuestion}
    No documento que descreve o nginx pode ler-se o seguinte:
    \begin{quote}
      nginx runs several processes in memory; there is a single master
      process and several worker processes.  There are also a couple
      of special purpose processes, specifically a cache loader and
      cache manager.  All processes are single-threaded in version 1.x
      of nginx.  All processes primarily use shared-memory mechanisms
      for inter-process communication.
    \end{quote}
    Supondo que pretende dar nfase  forma como os vrios processos
    do nginx comunicam entre si, que estilo arquitectural lhe parece
    mais adequado para representar a informao acima?

    \optionA{O estilo Publicao-Subscrio (\emph{Publish-Subscribe})}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo Par-a-par (\emph{Peer-to-Peer})}
    \optionD{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \putOptions
    % Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qnginxProcessesINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes nginx:
    \begin{quote}
      nginx runs several processes in memory; there is a single master
      process and several worker processes.  There are also a couple
      of special purpose processes, specifically a cache loader and
      cache manager.  All processes are single-threaded in version 1.x
      of nginx.  All processes primarily use shared-memory mechanisms
      for inter-process communication.
    \end{quote}
    Assuming that you want to highlight how the various nginx
    processes communicate among themselves, which architectural style
    is more adequate to represent the above information?

    \optionA{The Publish-Subscribe style}
    \optionB{The Client-Server style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Communicating Processes style}
    \putOptions
    % Resposta: D
  \end{ClosedQuestion}
}


%8
\newcommand{\qnginxCaching}{
  \begin{ClosedQuestion}
    Na continuao da descrio apresentada na pergunta anterior, mais
    abaixo no documento pode ler-se o seguinte:
    \begin{quote}
      Caching in nginx is implemented in the form of hierarchical data
      storage on a filesystem.  Cache keys are configurable, and
      different request-specific parameters can be used to control
      what gets into the cache.  Cache keys and cache metadata are
      stored in the shared memory segments, which the cache loader,
      cache manager and workers can access.
    \end{quote}
    Que estilo arquitectural lhe parece mais adequado para representar
    a utilizao da \emph{cache} no nginx?

    \optionA{O estilo Camadas (\emph{Layers})}
    \optionB{O estilo Utilizao (\emph{Uses})}
    \optionC{O estilo Dados Partilhados (\emph{Shared data})}
    \optionD{O estilo Processos Comunicantes (\emph{Communicating Processes})}

    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qnginxCachingINGLES}{
  \begin{ClosedQuestion}
    In the continuation of the description presented in the previous
    question, later in the document there is this passage:
    \begin{quote}
      Caching in nginx is implemented in the form of hierarchical data
      storage on a filesystem.  Cache keys are configurable, and
      different request-specific parameters can be used to control
      what gets into the cache.  Cache keys and cache metadata are
      stored in the shared memory segments, which the cache loader,
      cache manager and workers can access.
    \end{quote}
    Which architectural style is more adequate to represent the use of
    cache in nginx?

    \optionA{The Layers style}
    \optionB{The Uses style}
    \optionC{The Shared data style}
    \optionD{The Communicating Processes style}

    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}


%9
\newcommand{\qnginxWorkers}{
  \begin{ClosedQuestion}
    Tal como mencionado nas perguntas anteriores, a utilizao de
    \emph{workers}  um dos elementos cruciais na arquitectura de
    software do nginx.  Qual das seguintes afirmaes melhor descreve
    o funcionamento dos \emph{workers} no nginx?

    \optionA{ criado um \emph{worker} de cada vez que  estabelecida
      uma nova ligao ao servidor, e esse \emph{worker} processa
      todos os pedidos dessa ligao, sendo destrudo no fim da ligao}
    \optionB{Existe uma \emph{pool} de \emph{workers} que so
      reutilizados entre ligaes, mas cada \emph{worker} apenas
      processa pedidos de uma ligao de cada vez}
    \optionC{Cada \emph{worker}  responsvel por vrias ligaes,
      processando todos os pedidos dessas ligaes}
    \optionD{Cada \emph{worker} processa pedidos que obtm de uma
      \emph{pool de pedidos} partilhada por todos os \emph{workers}}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qnginxWorkersINGLES}{
  \begin{ClosedQuestion}
    As mentioned in the previous questions, the use of \emph{workers}
    is one of the crucial elements in the software architecture of
    nginx.  Which of the following sentences best describes how
    \emph{workers} work in nginx?

    \optionA{A new \emph{worker} is created whenever a new connection
      is established with the server, and that \emph{worker} processes
      all of the requests for that connection, being destroyed at the
      end of the connection}
    \optionB{There is a \emph{pool} of \emph{workers} that are reused
      between connections, but each \emph{worker} processes only
      requests of a connection at a time}
    \optionC{Each \emph{worker} is responsible for various connections,
      processing all requests from those connections}
    \optionD{Each \emph{worker} processes requests that it obtains
      from a \emph{pool of requests} that is shared among all workers}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}


%10
\newcommand{\qnginxWorkerParallel}{
  \begin{ClosedQuestion}
    Uma vez que um \emph{worker} processa vrios pedidos ao longo da
    sua vida, como  que o faz?
	
    \optionA{Intercalando as vrias fases do processamento de cada
      pedido num processo sequencial}
    \optionB{Executando em paralelo cada fase do pipeline do
      processamento de um pedido}
    \optionC{Executando em paralelo o processamento de vrios pedidos}
    \optionD{Processando completamente cada pedido antes de passar
      para o prximo, num processo sequencial}
    \putOptions
    % Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qnginxWorkerParallelINGLES}{
  \begin{ClosedQuestion}
    Given that a \emph{worker} processes various requests during its
    life, how does it do it?
	
    \optionA{By interleaving the various processing phases of each
      request in a sequential process}
    \optionB{By executing in parallel each of the phases of the
      pipeline corresponding to the processing of a request}
    \optionC{By executing in parallel the processing of the various requests}
    \optionD{By processing completely each request before moving to
      the next one, in a sequential process}
    \putOptions
    % Resposta: A
  \end{ClosedQuestion}
}



%11
\newcommand{\qZeroMQBroker}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      It took us several years working on AMQP protocol [...] to
      realise that there's something wrong with the classic
      client/server model of smart messaging server (broker) and dumb
      messaging clients.
    \end{quote}
    Qual  o principal problema, segundo os autores, do modelo baseado
    num \emph{broker}?
    
    \optionA{ menos robusto, porque uma falta no \emph{broker} causa
      uma falha no sistema}
    \optionB{ menos modificvel, porque todos os componentes dependem
      do \emph{broker}}
    \optionC{Tem menor desempenho, porque a existncia do
      \emph{broker} introduz maior latncia na comunicao}
    \optionD{ mais caro, porque obriga  existncia de
      \emph{hardware} adicional para executar o \emph{broker}}
  \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQBrokerINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      It took us several years working on AMQP protocol [...] to
      realise that there's something wrong with the classic
      client/server model of smart messaging server (broker) and dumb
      messaging clients.
    \end{quote}
    What is the main problem, according to the authors, of the
    \emph{broker}-based model?
    
    \optionA{It is less robust, because a fault in the \emph{broker}
      causes a failure in the system}
    \optionB{It is less modifiable, because all components depend on
      the \emph{broker}}
    \optionC{It has less performance, because the
      \emph{broker} introduces greater latency in the communication}
    \optionD{It is more expensive, because it forces the existence of
      additional hardware to execute the \emph{broker}}
  \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

%12
\newcommand{\qZeroMQAsLibrary}{
  \begin{ClosedQuestion}
    Sabendo que no documento que descreve o ZeroMQ se encontra a
    seguinte afirmao:
    \begin{quote}
      MQ is a library, not a messaging server.
    \end{quote}
    Que tipo de vistas so necessrias para descrever a arquitectura
    de software do ZeroMQ?

    \optionA{Apenas vistas do tipo mdulo}
    \optionB{Apenas vistas do tipo componente-e-conector}
    \optionC{Apenas vistas do tipo afectao}
    \optionD{Vistas do tipo mdulo e componente-e-conector}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQAsLibraryINGLES}{
  \begin{ClosedQuestion}
    Knowing that in the document describing ZeroMQ there is the
    following statement:
    \begin{quote}
      MQ is a library, not a messaging server.
    \end{quote}
    Which views are needed to describe the software architecture of
    ZeroMQ?

    \optionA{Only module views}
    \optionB{Only component-and-connector views}
    \optionC{Only allocation views}
    \optionD{Module and component-and-connector views}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%13
\newcommand{\qZeroMQExtensibleEngines}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      The objects that handle data transfer are composed of two parts:
      the session object is responsible for interacting with the MQ
      socket, and the engine object is responsible for communication
      with the network.  There's only one kind of the session object,
      but there's a different engine type for each underlying protocol
      MQ supports.  Thus, we have TCP engines, IPC engines, PGM
      engines, etc.  The set of engines is extensible---in the future
      we may choose to implement, say, a WebSocket engine or an SCTP
      engine.
    \end{quote}
    Supondo que o cdigo que implementa o \emph{session object} no
    precisa ser modificado quando um novo tipo de \emph{engine} 
    adicionado ao sistema, que vistas arquitecturais so mais
    indicadas para mostrar este aspecto de extensibilidade do sistema?

    \optionA{Vistas do estilo Generalizao (\emph{Generalization})}
    \optionB{Vistas do estilo Camadas (\emph{Layers})}
    \optionC{Vistas do estilo Decomposio (\emph{Decomposition})}
    \optionD{Vistas do estilo Utilizao (\emph{Uses})}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQExtensibleEnginesINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      The objects that handle data transfer are composed of two parts:
      the session object is responsible for interacting with the MQ
      socket, and the engine object is responsible for communication
      with the network.  There's only one kind of the session object,
      but there's a different engine type for each underlying protocol
      MQ supports.  Thus, we have TCP engines, IPC engines, PGM
      engines, etc.  The set of engines is extensible---in the future
      we may choose to implement, say, a WebSocket engine or an SCTP
      engine.
    \end{quote}
    Supposing that the code implementing the \emph{session object}
    does not need to be changed when a new type of \emph{engine} is
    added to the system, which architectural views are better to show
    this extensibility aspect of the system?

    \optionA{Views of the Generalization style}
    \optionB{Views of the Layers style}
    \optionC{Views of the Decomposition style}
    \optionD{Views of the Uses style}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}


%14
\newcommand{\qZeroMQScaleMulticore}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      One of the requirements for MQ was to take advantage of
      multi-core boxes; in other words, to scale the throughput
      linearly with the number of available CPU cores.
    \end{quote}
    Para satisfazer este requisito, a soluo adoptada pelo ZeroMQ foi

    \optionA{Processar todos os pedidos de envio de mensagens com uma
      nica \emph{thread}, para libertar os restantes cores para as
      \emph{user threads}}
    \optionB{Lanar uma \emph{worker thread} por cada \emph{user
        thread} para garantir que cada \emph{user thread} pode enviar
      mensagens independentemente do que as outras estejam a fazer}
    \optionC{Lanar uma \emph{worker thread} por cada core, para
      maximizar a utilizao dos cores e minimizar a necessidade de
      sincronizao entre \emph{threads}}
    \optionD{Lanar uma \emph{worker thread} para processar o envio de
      uma nova mensagem, para garantir o mximo de paralelismo no
      envio de mensagens}
   \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQScaleMulticoreINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      One of the requirements for MQ was to take advantage of
      multi-core boxes; in other words, to scale the throughput
      linearly with the number of available CPU cores.
    \end{quote}
    To satisfy this requirement, the solution adopted by ZeroMQ was

    \optionA{To process all of the requests to send messages with a
      single thread, to free the remaining cores for the 
      user threads}
    \optionB{To launch a worker thread for each user
        thread to guarantee that each user thread may send messages
        independently of what the others are doing}
    \optionC{To launch a worker thread for each core, to maximize the
      core usage and to minimize the need for synchronization among
      threads}
    \optionD{To launch a worker thread to process the sending of a
      new message, to guarantee maximal parallelism in message sending}
   \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%15
\newcommand{\qZeroMQBSDSockets}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      In early versions of MQ the API was based on AMQP's model of
      exchanges and queues.  I spent the end of 2009 rewriting it
      almost from scratch to use the BSD Socket API instead.
    \end{quote}
    Esta mudana no sistema teve como objectivo satisfazer que tipo de
    requisitos?

    \optionA{Usabilidade}
    \optionB{Modificabilidade}
    \optionC{Desempenho}
    \optionD{Segurana}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qZeroMQBSDSocketsINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      In early versions of MQ the API was based on AMQP's model of
      exchanges and queues.  I spent the end of 2009 rewriting it
      almost from scratch to use the BSD Socket API instead.
    \end{quote}
    Which requirements were targeted by this change in the system?

    \optionA{Usability}
    \optionB{Modifiability}
    \optionC{Performance}
    \optionD{Security}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


%16
\newcommand{\qWebCacheModule}{
  \begin{ClosedQuestion}
    Considere a figura 1.8 no documento que descreve a utilizao de
    caches em servios web (em anexo).  Nessa figura, aparece um
    rectngulo com a designao \emph{Cache} dentro de um rectngulo
    designado \emph{Request Node}.  Tendo em conta a descrio feita
    no texto e o objectivo dessa figura, esses rectngulos
    correspondem a que tipo de elementos de software na arquitectura
    de software apresentada?

    \optionA{So ambos mdulos}
    \optionB{So ambos componentes}
    \optionC{O \emph{Request Node}  um componente e a \emph{Cache} 
      um mdulo}
    \optionD{O \emph{Request Node}  um mdulo e a \emph{Cache}  um
      componente}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qWebCacheModuleINGLES}{
  \begin{ClosedQuestion}
    Consider the Figure~1.8 in the document that describes the use of
    caches in web services (see annex).  In that Figure, there is a
    rectangle with the name \emph{Cache} within another rectangle with
    the name \emph{Request Node}.  Taking into account the description
    made in the text and the goal of that Figure, those rectangles
    correspond to which type of software elements?

    \optionA{They are both modules}
    \optionB{They are both components}
    \optionC{The \emph{Request Node} is a component and the
      \emph{Cache} is a module}
    \optionD{The \emph{Request Node} is a module and the \emph{Cache}
      is a component}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

%17
\newcommand{\qWebCacheGlobal}{
  \begin{ClosedQuestion}
    Considere a alterao na arquitectura introduzida com a passagem
    da figura 1.9 para a figura 1.10 no documento que descreve a
    utilizao de caches em servios web (em anexo).  Essa alterao
    tem como objectivo e consequncia, respectivamente

    \optionA{Aumentar o desempenho e a disponibilidade}
    \optionB{Aumentar a disponibilidade e diminuir o desempenho}
    \optionC{Aumentar o desempenho e diminuir a disponibilidade}
    \optionD{Aumentar a escalabilidade e a disponibilidade}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qWebCacheGlobalINGLES}{
  \begin{ClosedQuestion}
    Consider the change in the architecture introduced from Figure~1.9
    to Figure~1.10 in the document that describes the use of caches in
    web services (see annex).  That change has the goal and the
    consequence of, respectively

    \optionA{Increasing performance and availability}
    \optionB{Increasing availability and decreasing performance}
    \optionC{Increasing performance and decreasing availability}
    \optionD{Increasing scalability and availability}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

%18
\newcommand{\qWebDistributedCache}{
  \begin{ClosedQuestion}
    Considere o pargrafo assinalado com o nmero 1 no documento que
    descreve a utilizao de caches em servios web (em anexo), onde
    se introduz o conceito de \emph{distributed cache}.  Que estilo
    arquitectural melhor representa o padro de interaco existente
    entre os vrios \emph{request nodes}?
    
    \optionA{O estilo Dados-Partilhados \emph{Shared-Data}}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo Par-a-par (\emph{Peer-to-Peer})}
    \optionD{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qWebDistributedCacheINGLES}{
  \begin{ClosedQuestion}
    Consider the paragraph marked with the number 1 in the document
    that describes the use of caches in web services (see annex),
    where the concept of \emph{distributed cache} is introduced.
    Which architectural style better represents the interaction
    pattern that exists among the various request nodes?
    
    \optionA{The Shared-Data style}
    \optionB{The Client-Server style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Communicating Processes style}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%19
\newcommand{\qWebMissingCacheNode}{
  \begin{ClosedQuestion}
    Considere o pargrafo assinalado com o nmero 2 no documento que
    descreve a utilizao de caches em servios web (em anexo), onde
    se fala sobre a falha de um dos ns da \emph{cache} distribuda.
    Quando isso acontece, que consequncias existem para o servio
    web?

    \optionA{O desempenho do sistema diminui} 
    \optionB{A disponibilidade dos dados do sistema diminui}
    \optionC{A disponibilidade dos servios do sistema diminui}
    \optionD{O sistema no  afectado de forma nenhuma}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qWebMissingCacheNodeINGLES}{
  \begin{ClosedQuestion}
    Consider the paragraph marked with the number 2 in the document
    that describes the use of caches in web services (see annex),
    where the failure of a node in the distributed cache is discussed.
    When that happens, what are the consequences for the system?

    \optionA{The performance decreases} 
    \optionB{The availability of the system's data decreases}
    \optionC{The availability of the system's services decreases}
    \optionD{The system is not affected in any way}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


%20
\newcommand{\qMemcachedModules}{
  \begin{ClosedQuestion}
    Considere a seguinte descrio do \emph{Memcached}, que  uma
    adaptao do que aparece no seu Wiki:
    \begin{quote}
      Memcached is an in-memory key-value store for small chunks of
      arbitrary data from results of database calls, API calls, or
      page rendering.  It is made up of:
      \begin{itemize}
      \item Client software, which is given a list of available memcached servers.
      \item A client-based hashing algorithm, which chooses a server
        based on the "key" input.
      \item Server software, which stores your values with their keys
        into an internal hash table.
      \item Server algorithms, which determine when to throw out old
        data (if out of memory), or reuse memory.
      \end{itemize}
    \end{quote}
    Suponha que pretendia apresentar uma vista arquitectural para o
    \emph{Memcached} que represente a informao acima.  Que vista 
    mais adequada?

    \optionA{Uma vista do estilo \emph{Data Model}}
    \optionB{Uma vista do estilo Camadas (\emph{Layers})}
    \optionC{Uma vista do estilo Decomposio (\emph{Decomposition})}
    \optionD{Uma vista do estilo Utilizao (\emph{Uses})}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qMemcachedModulesINGLES}{
  \begin{ClosedQuestion}
    Consider the following description of \emph{Memcached}, which is
    adapted from its Wiki:
    \begin{quote}
      Memcached is an in-memory key-value store for small chunks of
      arbitrary data from results of database calls, API calls, or
      page rendering.  It is made up of:
      \begin{itemize}
      \item Client software, which is given a list of available memcached servers.
      \item A client-based hashing algorithm, which chooses a server
        based on the "key" input.
      \item Server software, which stores your values with their keys
        into an internal hash table.
      \item Server algorithms, which determine when to throw out old
        data (if out of memory), or reuse memory.
      \end{itemize}
    \end{quote}
    Suppose that you want to present an architectural view for
    \emph{Memcached} that represents the above information.  Which
    view is more adequate?

    \optionA{A view of the Data Model style}
    \optionB{A view of the Layers style}
    \optionC{A view of the Decomposition style}
    \optionD{A view of the Uses style}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%21
\newcommand{\qDomainLogicFenix}{
  \begin{ClosedQuestion}
    Uma das principais mudanas introduzidas na arquitectura do
    sistema Fnix, relativamente  sua primeira arquitectura foi
    
    \optionA{Passar a usar o padro Transaction Script na camada de lgica de domnio}
    \optionB{Passar a usar o padro Service Layer numa nova camada}
    \optionC{Passar de um modelo de domnio anmico para um modelo de
      domnio rico}
    \optionD{Eliminar a camada de servios}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qDomainLogicFenixINGLES}{
  \begin{ClosedQuestion}
    One of the major changes introduced in the software architecture
    of the Fnix system, compared to its first architecture, was
    
    \optionA{To start using the Transaction Script pattern in the
      domain logic layer}
    \optionB{To start using the Service Layer pattern in a new layer}
    \optionC{To move from an anemic domain model to a rich domain model}
    \optionD{To eliminate the service layer}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}



%22
\newcommand{\qSubcontractors}{
  \begin{ClosedQuestion}
    Suponha que est a desenvolver uma arquitectura de software para
    um novo sistema de grandes dimenses e que no desenvolvimento se
    pretende recorrer extensivamente a empresas subcontratadas para o
    desenvolvimento de vrias partes do sistema.  Que estilos
    arquitecturais so mais teis para planear o desenvolvimento do
    sistema neste cenrio?

    \optionA{O estilo Decomposio (\emph{Decomposition}) e o estilo
      Atribuio de Trabalho (\emph{Work Assignment})}
    \optionB{O estilo Decomposio (\emph{Decomposition}) e o estilo
      Camadas (\emph{Layers})}
    \optionC{O estilo Decomposio (\emph{Decomposition}) e o estilo
      Utilizao (\emph{Uses})}
    \optionD{O estilo Decomposio (\emph{Decomposition}) e o estilo SOA}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qSubcontractorsINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are developing a software architecture for a new
    large scale system and that you intend to resort extensively to
    third party subcontractors for the development of various parts of
    the system.  Which architectural styles are most useful to plan
    the development of the system in this case?

    \optionA{The Decomposition and the Work Assignment styles}
    \optionB{The Decomposition and the Layers styles}
    \optionC{The Decomposition and the Uses styles}
    \optionD{The Decomposition and the SOA styles}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


%23
\newcommand{\qPerformance}{
  \begin{ClosedQuestion}
    Vrios dos casos estudados na cadeira tinham requisitos de
    desempenho.  Que vistas arquitecturais so normalmente necessrias
    para mostrar a satisfao desses requisitos?

    \optionA{Vistas do tipo mdulo}
    \optionB{Vistas do tipo componente-e-conector}
    \optionC{Vistas do tipo afectao (\emph{Allocation})}
    \optionD{Vistas do tipo componente-e-conector e afectao (\emph{Allocation})}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qPerformanceINGLES}{
  \begin{ClosedQuestion}
    Several of the cases studied in this course had performance
    requirements.  Which architectural views are typically needed to
    show that those requirements are satisfied?

    \optionA{Views of the Module viewtype}
    \optionB{Views of the Component-and-Connector viewtype}
    \optionC{Views of the Allocation viewtype}
    \optionD{Views of the Component-and-Connector and Allocation viewtypes}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%24
\newcommand{\qSOA}{
  \begin{ClosedQuestion}
    Suponha que est a desenvolver a arquitectura de software de um
    novo sistema para uma organizao que tem vrias unidades
    organizacionais, cada uma das quais com os seus sistemas de
    informao, que foram desenvolvidos independentemente uns dos
    outros ao longo de vrios anos e dependendo das necessidades
    particulares de cada unidade.  O seu sistema tem como objectivo
    integrar os vrios sistemas existentes, providenciando desta forma
    no s uma viso consolidada do funcionamento da organizao, mas
    tambm permitir a criao de novos processos dentro da organizao
    que envolvam mais do que uma unidade.  Que estilo arquitectural
    lhe parece mais adequado para desenhar o seu sistema?
    
    \optionA{O estilo Decomposio (\emph{Decomposition})}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo SOA (\emph{Service Oriented Architecture})}
    \optionD{O estilo Processos Comunicantes (\emph{Communicating Processes})}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qSOAINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are developing the software architecture of a new
    system for an organization composed of several organizational
    units, each one with its own information systems, which have been
    developed independently of each other over the course of several
    years and depending on the particular needs of each unit.  Your
    system has the goal of integrating the various existing systems,
    providing in this way not only a unified view of how the
    organization works, but also allowing the creation of new
    processes within the organization that involve more than one unit.
    Which architectural style is better suited to design such a
    system?
    
    \optionA{The Decomposition style}
    \optionB{The Client-Server style}
    \optionC{The Service Oriented Architecture style}
    \optionD{The Communicating Processes style}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%25
\newcommand{\qAvailability}{
  \begin{ClosedQuestion}
    Suponha que para satisfazer um requisito de disponibilidade
    relacionado com a existncia de faltas ao nvel da infraestrutura
    de rede usada pelo seu sistema, pretende utilizar a tctica
    designada por \emph{Ping/Echo}.  Como  que a utilizao dessa
    tctica se manifesta nas vistas da arquitectura do seu sistema?

    \optionA{Apenas na vista de Instalao (\emph{Deployment})}
    \optionB{Apenas na vista de Decomposio (\emph{Decomposition})}
    \optionC{Apenas numa vista de componente-e-conector}
    \optionD{Numa vista de componente-e-conector e numa vista de
      Instalao (\emph{Deployment})}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qAvailabilityINGLES}{
  \begin{ClosedQuestion}
    Suppose that, to satisfy an availability requirement related with
    the occurrence of faults at the network infrastructure used by
    your system, you want to use the tactic named \emph{Ping/Echo}.
    How does the use of that tactic manifests in the architectural
    views of your system?

    \optionA{Only in the Deployment view}
    \optionB{Only in the Decomposition view}
    \optionC{Only in a component-and-connector view}
    \optionD{Both in a component-and-connector and the Deployment
      views}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%26
\newcommand{\qSecurity}{
  \begin{ClosedQuestion}
    Suponha que est a desenvolver uma aplicao web que mantm numa
    base de dados alguma informao introduzida pelos utilizadores, e
    que um dos requisitos  que essa informao seja mantida
    confidencial, no podendo ser vista por ningum para alm do
    utilizador que a produziu (e que deve poder aceder a essa
    informao novamente sempre que quiser).  Como  que satisfazia
    este requisito?

    \optionA{Utilizava HTTPS na comunicao entre o \emph{browser} e o
      servidor web}
    \optionB{Utilizava mecanismos de autenticao robustos para
      identificar os utilizadores do sistema com confiana}
    \optionC{Cifrava a informao na base de dados com uma password
      conhecida apenas pelo servidor web}
    \optionD{Nenhuma das outras opes apresentada resolve o problema}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qSecurityINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are developing a web application that keeps in a
    database some information that is introduced by the users and that
    one of the requirements is that the information should be kept
    confidential, such that no one but the author of the information
    should be able to see it (but the author may access that
    information whenever he wants it).  How would you satisfy this
    requirement?

    \optionA{By using HTTPS in the communication between the browser
      and the web server}
    \optionB{By using robust authentication mechanisms to identify the
      users of the system with confidence}
    \optionC{By encrypting the information in the database with a
      password that is known only by the web server}
    \optionD{None of the other options solves the problem}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%27
\newcommand{\qWebEvolution}{
  \begin{ClosedQuestion}
    As aplicaes web tm sofrido vrias evolues ao longo dos
    ltimos anos.  Uma dessas evolues foi o enriquecimento da sua
    interface com o utilizador, que tira partida de novas tecnologias
    existentes nos \emph{browsers}, como, por exemplo, o Javascript,
    para providenciar uma experincia de utilizao mais rica.  Quais
    foram as consequncias mais visveis desta evoluo na tpica
    arquitectura de software de uma aplicao web?

    \optionA{Alterou-se a camada da lgica de apresentao e a forma
      como ela se relaciona com a camada de baixo}
    \optionB{Alterou-se o conector usado para representar a
      interaco entre o \emph{browser} e o \emph{web server}}
    \optionC{O \emph{browser} passou a ser um componente de um tipo
      diferente}
    \optionD{Esta evoluo no teve consequncias nenhumas na
      arquitectura de software de uma aplicao web}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qWebEvolutionINGLES}{
  \begin{ClosedQuestion}
    Web applications went through several evolutions over the last
    years.  One of those evolutions was to make their user interfaces
    more sophisticated, by leveraging on new technologies available in
    the browsers, such as, for example, Javascript, to provide a more
    satisfying user experience.  What were the most visible
    consequences of such an evolution on the typical software
    architecture of a web application?

    \optionA{The presentation logic layer and how it relates with the
      underlying layer changed}
    \optionB{The connector used to represent the interaction between
      the browser and the web server changed}
    \optionC{The browser is now a component of a different type}
    \optionD{That evolution did not have any consequences on the
      software architecture of a web application}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


%28
\newcommand{\qTiers}{
  \begin{ClosedQuestion}
    Um dos termos frequentemente utilizado para descrever a
    arquitectura de software de um sistema  o termo \emph{tier},
    sendo comum, por exemplo, falar-se em sistemas \emph{multi-tier}.
    Tendo em conta os vrios tipos de elementos de software que
    compem uma arquitectura de software, um \emph{tier}  

    \optionA{Um componente}
    \optionB{Um agrupamento de componentes}
    \optionC{Um mdulo}
    \optionD{Uma camada}

    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}

\newcommand{\qTiersINGLES}{
  \begin{ClosedQuestion}
    One of the terms often used to describe the software architecture
    of a system is the term \emph{tier}, being common, for instance,
    to talk about \emph{multi-tier} systems.  Taking into account the
    various types of software elements that compose a software
    architecture, a \emph{tier} is

    \optionA{A component}
    \optionB{A grouping of components}
    \optionC{A module}
    \optionD{A layer}

    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}


%29
\newcommand{\qArqEmailMUAMTA}{
  \begin{ClosedQuestion}
    O sistema de email  composto por vrios tipos de componentes que
    desempenham diferentes funes.  Por exemplo, para enviar um
    email, um utilizador usa um \emph{mail user agent} (MUA), para
    compor a sua mensagem e envi-la.  Para enviar a mensagem,
    tipicamente o MUA liga-se a um \emph{mail transfer agent} (MTA),
    que recebe a mensagem, analisa os cabealhos da mesma para
    determinar os vrios destinatrios e, aps consulta do sistema DNS
    para determinar quais os MTA responsveis por cada um dos
    destinatrios, liga-se aos MTAs responsveis pelos endereos de
    destino para entregar a mensagem.  Cada um desses MTAs recebe a
    mensagem e armazena-a localmente ou reenvia-a para outros MTAs at
    que a mensagem chegue ao MTA do destino.  O utilizador
    destinatrio da mensagem ir depois usar o seu MUA para ver as
    mensagens que lhe foram enviadas.  Para isso o MUA liga-se a um
    servidor IMAP ou POP para obter as mensagens que lhe foram
    destinadas.  Esses servidores IMAP e POP obtm as mensagens de um
    utilizador consultando as mensagens armazenadas pelo MTA.

    Tendo em conta esta descrio simplificada do funcionamento do
    sistema de email, qual dos estilos arquitecturais lhe parece mais
    adequada para representar o padro de interaco existente entre o
    MUA e o MTA?

    \optionA{O estilo arquitectural Par-a-Par (\emph{Peer-to-Peer})}
    \optionB{O estilo arquitectural Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo arquitectural Dados-Partilhados \emph{Shared-Data}}
    \optionD{O estilo arquitectural Publicao-Subscrio (\emph{Publish-subscribe})}

    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qArqEmailMUAMTAINGLES}{
  \begin{ClosedQuestion}
    The email system is composed of various types of components
    playing different roles.  For example, to send an email, a user
    uses a \emph{mail user agent} (MUA), to compose his message and
    send it.  To send the message, the MUA typically connects to a
    \emph{mail transfer agent} (MTA) that receives the message,
    analyzes the message's headers to determine the recipients and,
    after querying the DNS system to determine the MTA responsible for
    each recipient, it connects to the MTAs responsible for the
    destination addresses to deliver the message.  Each of these MTAs
    receives the message and stores it locally or forwards it to
    others MTAs until the message reaches its destination MTA.
    The recipient user of the message will then use his MUA to see the
    messages that were sent to him.  To do it, the MUA connects to an
    IMAP or POP server to obtain the user's messages.  Those IMAP and
    POP servers obtain the messages for a user by reading the messages
    stored by the MTA.

    Given this simplified description of the operation of the email
    system, which of the following architectural styles is more
    appropriate to represent the pattern of interaction between the
    MUA and the MTA?

    \optionA{The Peer-to-Peer style}
    \optionB{The Client-Server style}
    \optionC{The Shared-Data style}
    \optionD{The Publish-subscribe style}

    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}


%30
\newcommand{\qAspects}{
  \begin{ClosedQuestion}
    A utilizao do estilo arquitectural Aspectos (\emph{Aspects})
    promove a modificabilidade de um sistema porque

    \optionA{Estabelece restries s relaes de utilizao
      (\emph{uses}) que podem existir entre os mdulos do sistema}
    \optionB{Facilita a criao de relaes de generalizao
      (\emph{Generalization}) entre os mdulos do sistema}
    \optionC{Isola em novos mdulos responsabilidades que se
      encontravam espalhadas por vrios mdulos do sistema}
    \optionD{Permite decompor cada mdulo do sistema em mdulos de
      gro mais fino}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qAspectsINGLES}{
  \begin{ClosedQuestion}
    Using the Aspects architectural style promotes the modifiability
    of a system because
    
    \optionA{It imposes restrictions on which uses relationships may
      exist between the system's modules}
    \optionB{It makes it easier to create generalization relationships
      between the system's modules}
    \optionC{It separates in new modules responsibilities that were
      spread over various of the system's modules}
    \optionD{It allows the decomposition of each of the system's
      modules into finer grained modules}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%% =========================================================================
%% exam1 2012/2013
%% =========================================================================

\newcommand{\ghc}{Glasgow Haskell Compiler}

%1
\newcommand{\qGHCStakeholders}{
  \begin{ClosedQuestion}
    Dois dos \emph{stakeholders} identificados para o \ghc{} foram o
    governo do Reino Unido e os investigadores que pretendem fazer
    investigao em linguagens de programao funcionais.  Qual destes
    \emph{stakeholders} teve uma maior influncia na arquitectura de
    software do sistema?

    \optionA{O governo do Reino Unido, porque foi quem financiou o
      projecto}
    \optionB{Os investigadores, porque foram eles que inventaram a
      linguagem de programao Haskell}
    \optionC{O governo do Reino Unido, porque pretendia que o sistema
      pudesse ser usado para desenvolver a indstria de software Britnica}
    \optionD{Os investigadores, porque pretendiam usar o sistema para
      validar as suas invenes} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}

\newcommand{\qGHCStakeholdersINGLES}{
  \begin{ClosedQuestion}
    Two of the \emph{stakeholders} for the \ghc{} were the UK
    government and the researchers that want to do research on
    functional programming languages.  Which of these
    \emph{stakeholders} had a more significant influence in the
    software architecture of the system?

    \optionA{The UK government, because it funded the project}
    \optionB{The researchers, because they invented the Haskell
      programming language}
    \optionC{The UK government, because it intended that the system
      could be used to develop the British software industry}
    \optionD{The researchers, because they wanted to use the system to
      validate their research} 

     \putOptions
% Resposta: D
   \end{ClosedQuestion}
}


%2
\newcommand{\qGHCChunks}{
  \begin{ClosedQuestion}
    No documento que descreve o \ghc{} pode ler-se o seguinte:
    \begin{quote}
      At the highest level, GHC can be divided into three distinct
      chunks:
      \begin{itemize}
      \item The compiler itself.
      \item The Boot Libraries.
      \item The Runtime System (RTS). 
      \end{itemize}
    \end{quote}
    Qual a forma mais correcta de caracterizar arquitecturalmente os
    trs \emph{chunks} a que este texto se refere?

     \optionA{Como mdulos do sistema}
     \optionB{Como componentes do sistema}
     \optionC{O compilador e o RTS como componentes e as \emph{boot
         libraries} como mdulo}
     \optionD{O compilador como componente e os outros dois como mdulos}

     \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qGHCChunksINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes the \ghc{}:
    \begin{quote}
      At the highest level, GHC can be divided into three distinct
      chunks:
      \begin{itemize}
      \item The compiler itself.
      \item The Boot Libraries.
      \item The Runtime System (RTS). 
      \end{itemize}
    \end{quote}
    What is the most architecturally correct way of classifying the
    three \emph{chunks} that this text refers to?

     \optionA{As modules of the system}
     \optionB{As components of the system}
     \optionC{The compiler and the RTS as components and the boot
         libraries as a module}
     \optionD{The compiler as a component and the other two as modules}

     \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

%3
\newcommand{\qGHCDesugaring}{
  \begin{ClosedQuestion}
    Uma das decises importantes no desenvolvimento do \ghc{} foi a de
    se fazer a verificao de tipos antes da transformao de um
    programa em Haskell para um programa na linguagem Core
    (\emph{type-check-before-desugar}).  Esta deciso de desenho

    \optionA{Tornou a verificao de tipos muito mais simples}
    \optionB{Permitiu satisfazer requisitos de desempenho do sistema}
    \optionC{Tornou a transformao para a linguagem Core mais simples}
    \optionD{Permitiu satisfazer requisitos de usabilidade do sistema}
    \putOptions
% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qGHCDesugaringINGLES}{
  \begin{ClosedQuestion}
    One of the most important decisions during the development of the
    \ghc{} was to perform the type-checking before the desugaring of
    an Haskell program into a program in the Core language
    (\emph{type-check-before-desugar}).  This design decision

    \optionA{Made the type-checking much simpler}
    \optionB{Satisfied performance requirements of the system}
    \optionC{Made the desugaring simpler}
    \optionD{Satisfied usability requirements of the system}
    \putOptions
% Resposta: D
  \end{ClosedQuestion}
}

%4
\newcommand{\qGHCRTS}{
  \begin{ClosedQuestion}
    No documento que descreve o \ghc{} pode ler-se o seguinte:
    \begin{quote}
      The Runtime System is a library of mostly C code that is linked
      into every Haskell program. It provides the support
      infrastructure needed for running the compiled Haskell code,
      including the following main components:
      \begin{itemize}
      \item Memory management, including a parallel, generational, garbage collector;
      \item Thread management and scheduling;
      \item The primitive operations provided by GHC;
      \item A bytecode interpreter and dynamic linker for GHCi.
      \end{itemize}
    \end{quote}
    Que qualidades do sistema so melhoradas pela deciso de criar
    o \emph{Runtime System} indicado acima?

    \optionA{O desempenho do compilador, porque o RTS est escrito de
      forma muito eficiente em C}
    \optionB{O desempenho dos programas compilados, porque o RTS est
      escrito de forma muito eficiente em C}
    \optionC{A portabilidade, porque o RTS cria uma camada de
      abstraco que esconde alguns detalhes do sistema operativo}
    \optionD{A modificabilidade dos programas compilados, porque se
      pode alterar o seu comportamento alterando apenas o RTS}
    \putOptions
  \end{ClosedQuestion}
}

\newcommand{\qGHCRTSINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes the \ghc{}:
    \begin{quote}
      The Runtime System is a library of mostly C code that is linked
      into every Haskell program. It provides the support
      infrastructure needed for running the compiled Haskell code,
      including the following main components:
      \begin{itemize}
      \item Memory management, including a parallel, generational, garbage collector;
      \item Thread management and scheduling;
      \item The primitive operations provided by GHC;
      \item A bytecode interpreter and dynamic linker for GHCi.
      \end{itemize}
    \end{quote}
    Which system qualities are improved by the design decision of
    creating the Runtime System, described above?

    \optionA{The performance of the compiler, because the RTS is
      written as very efficient C code}
    \optionB{The performance of the compiled programs, because the RTS
      is written as very efficient C code}
    \optionC{The portability, because the RTS creates an abstraction
      layer that hides some of the details of the operating system}
    \optionD{The modifiability of the compiled programs, because we
      may change their behavior by changing only the RTS}
    \putOptions
  \end{ClosedQuestion}
}


%5
\newcommand{\qGHCPipeAndFilter}{
  \begin{ClosedQuestion}
    Tal como muitos outros compiladores, a compilao de um programa
    Haskell com o \ghc{} utiliza o estilo \emph{pipe-and-filter},
    criando um \emph{pipeline} composto por vrias fases de
    compilao.  A utilizao deste estilo arquitectural no GHC tem
    como objectivo

    \optionA{Permitir a execuo em paralelo das vrias fases de
      compilao, melhorando assim o desempenho do compilador}
    \optionB{Permitir a compilao de programas muito grandes, porque
      cada fase pode executar de forma incremental sem ser necessrio
      ter o programa todo em memria ao mesmo tempo}
    \optionC{Permitir a fcil alterao das fases de compilao que se
      usam no processo de compilao, tornando assim o compilador mais
      modificvel}
    \optionD{Todas as outras opes}
    \putOptions
  \end{ClosedQuestion}
}

\newcommand{\qGHCPipeAndFilterINGLES}{
  \begin{ClosedQuestion}
    Like many other compilers, the compilation of an Haskell program
    with the \ghc{} uses the Pipe-and-Filter style, creating a
    \emph{pipeline} composed of several compilation phases.  The goal
    of using this architectural style in GHC is

    \optionA{To allow the parallel execution of the several
      compilation phases, thereby improving the compiler performance}
    \optionB{To allow the compilation of very large programs, because
      wach phase may execute incrementally without loading the entire
      program into memory at once}
    \optionC{To facilitate changing the phases used in the compilation
      process, thereby making the compiler more modifiable}
    \optionD{All other options}
    \putOptions
  \end{ClosedQuestion}
}





%6
\newcommand{\qnginxFirstAD}{
  \begin{ClosedQuestion}
    O principal \emph{architectural driver} para o sistema nginx foi

    \optionA{Ter um \emph{throughput} maior do que o Apache}
    \optionB{Ter uma latncia no processamento de um pedido
      inferior  do Apache}
    \optionC{Ser mais facilmente modificvel do que o Apache}
    \optionD{Permitir um nmero simultneo de ligaes maior do que o
      Apache}
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qnginxFirstADINGLES}{
  \begin{ClosedQuestion}
    The main architectural driver for the nginx system was

    \optionA{To have better throughput than Apache}
    \optionB{To have a lower latency in the processing of a request
      than Apache} 
    \optionC{To be more modifiable than Apache}
    \optionD{To allow more simultaneous connections than Apache}
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}

%7
\newcommand{\qnginxModuleTypes}{
  \begin{ClosedQuestion}
    No documento que descreve o nginx pode ler-se o seguinte:
    \begin{quote}
      nginx's modular architecture generally allows developers to
      extend the set of web server features without modifying the
      nginx core.  nginx modules come in slightly different
      incarnations, namely core modules, event modules, phase
      handlers, protocols, variable handlers, filters, upstreams and
      load balancers.  [...]  Event modules provide a particular
      OS-dependent event notification mechanism like kqueue or epoll.
      Protocol modules allow nginx to communicate through HTTPS,
      TLS/SSL, SMTP, POP3 and IMAP.
    \end{quote}
    Que estilo arquitectural  mais adequado para representar a
    informao acima?

    \optionA{O estilo Generalizao}
    \optionB{O estilo Utilizao}
    \optionC{O estilo Camadas}
    \optionD{O estilo Aspectos}
    \putOptions
    % Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qnginxModuleTypesINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes nginx:
    \begin{quote}
      nginx's modular architecture generally allows developers to
      extend the set of web server features without modifying the
      nginx core.  nginx modules come in slightly different
      incarnations, namely core modules, event modules, phase
      handlers, protocols, variable handlers, filters, upstreams and
      load balancers.  [...]  Event modules provide a particular
      OS-dependent event notification mechanism like kqueue or epoll.
      Protocol modules allow nginx to communicate through HTTPS,
      TLS/SSL, SMTP, POP3 and IMAP.
    \end{quote}
    Which architectural style is more adequate to represent the
    information presented above?

    \optionA{The Generalization style}
    \optionB{The Uses style}
    \optionC{The Layers style}
    \optionD{The Aspects style}
    \putOptions
    % Resposta: A
  \end{ClosedQuestion}
}

%8
\newcommand{\qnginxEventDriven}{
  \begin{ClosedQuestion}
    No documento que descreve o nginx pode ler-se o seguinte:
    \begin{quote}
      Traditional process- or thread-based models of handling
      concurrent connections involve handling each connection with a
      separate process or thread, and blocking on network or
      input/output operations.  nginx followed a different model.  It
      was actually inspired by the ongoing development of advanced
      event-based mechanisms in a variety of operating systems.  What
      resulted is a modular, event-driven, asynchronous,
      single-threaded, non-blocking architecture which became the
      foundation of nginx code.
    \end{quote}
    A deciso de fazer o nginx como um sistema \emph{event-driven},
    \emph{asynchronous}, \emph{single-threaded}, e \emph{non-blocking}
    foi porque

    \optionA{O cdigo  mais fcil de desenvolver por no ser concorrente}
    \optionB{Se pretendia fazer um uso mais eficiente dos recursos
      computacionais existentes}
    \optionC{Os programas \emph{event-driven} so mais fceis de
      modificar}
    \optionD{Num sistema \emph{event-driven} cada componente pode
      funcionar independentemente dos restantes}
    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qnginxEventDrivenINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes nginx:
    \begin{quote}
      Traditional process- or thread-based models of handling
      concurrent connections involve handling each connection with a
      separate process or thread, and blocking on network or
      input/output operations.  nginx followed a different model.  It
      was actually inspired by the ongoing development of advanced
      event-based mechanisms in a variety of operating systems.  What
      resulted is a modular, event-driven, asynchronous,
      single-threaded, non-blocking architecture which became the
      foundation of nginx code.
    \end{quote}
    The decision of turning nginx into an \emph{event-driven},
    \emph{asynchronous}, \emph{single-threaded}, and
    \emph{non-blocking} system was made because

    \optionA{The code is easier to develop because it is not concurrent}
    \optionB{They wanted to have a more efficient use of the
      computational resources}
    \optionC{Event-driven programs are easier to change}
    \optionD{In an event-driven system each component may function
      independently of the others}
    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}


%9
\newcommand{\qnginxOSOptimizations}{
  \begin{ClosedQuestion}
    No documento que descreve o nginx pode ler-se o seguinte:
    \begin{quote}
      While handling a variety of actions associated with accepting,
      processing and managing network connections and content
      retrieval, nginx uses event notification mechanisms and a number
      of disk I/O performance enhancements in Linux, Solaris and
      BSD-based operating systems, like kqueue, epoll, and event
      ports.  The goal is to provide as many hints to the operating
      system as possible, in regards to obtaining timely asynchronous
      feedback for inbound and outbound traffic, disk operations,
      reading from or writing to sockets, timeouts and so on.
    \end{quote}
    Esta abordagem usada no desenvolvimento do nginx tem como objectivo

    \optionA{Tornar o sistema mais facilmente modificvel}
    \optionB{Tornar o sistema mais portvel para diferentes sistemas operativos}
    \optionC{Tornar o sistema mais rpido}
    \optionD{Tornar o sistema mais tolerante a faltas}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qnginxOSOptimizationsINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes nginx:
    \begin{quote}
      While handling a variety of actions associated with accepting,
      processing and managing network connections and content
      retrieval, nginx uses event notification mechanisms and a number
      of disk I/O performance enhancements in Linux, Solaris and
      BSD-based operating systems, like kqueue, epoll, and event
      ports.  The goal is to provide as many hints to the operating
      system as possible, in regards to obtaining timely asynchronous
      feedback for inbound and outbound traffic, disk operations,
      reading from or writing to sockets, timeouts and so on.
    \end{quote}
    The goal of this approach used in the development of nginx was

    \optionA{To make the system more modifiable}
    \optionB{To make the system more portable to different operating systems}
    \optionC{To make the system faster}
    \optionD{To make the system more fault tolerant}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}


%10
\newcommand{\qnginxProcessThread}{
  \begin{ClosedQuestion}
    No documento que descreve o nginx pode ler-se o seguinte:
    \begin{quote}
      Traditional process- or thread-based models of handling
      concurrent connections involve handling each connection with a
      separate process or thread, and blocking on network or
      input/output operations.
    \end{quote}
    O estilo arquitectural que melhor descreve o modelo descrito acima
    para o processamento de pedidos 
	
    \optionA{O estilo Dados Partilhados (\emph{Shared data})}
    \optionB{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \optionC{O estilo Par-a-Par (\emph{Peer-to-Peer})}
    \optionD{O estilo Cliente-Servidor (\emph{Client-Server})}
    \putOptions
    % Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qnginxProcessThreadINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes nginx:
    \begin{quote}
      Traditional process- or thread-based models of handling
      concurrent connections involve handling each connection with a
      separate process or thread, and blocking on network or
      input/output operations.
    \end{quote}
    The architectural style that better describes the model presented
    above for processing requests is
	
    \optionA{The Shared-data style}
    \optionB{The Communicating Processes style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Client-Server style}
    \putOptions
    % Resposta: B
  \end{ClosedQuestion}
}


%11
\newcommand{\qZeroMQApps}{
  \begin{ClosedQuestion}
    Qual das seguintes frases melhor caracteriza o sistema ZeroMQ
    
    \optionA{ um sistema com uma arquitectura Par-a-Par}
    \optionB{ um sistema com uma arquitectura Cliente-Servidor}
    \optionC{Permite a implementao de sistemas com uma arquitectura Par-a-Par}
    \optionD{Permite a implementao de sistemas com arquitecturas
      Par-a-Par, Cliente-Servidor, ou Publicao-Subscrio}
  \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQAppsINGLES}{
  \begin{ClosedQuestion}
    Which of the following sentences better describes the ZeroMQ system?
    
    \optionA{It is a system with a Peer-to-Peer architecture}
    \optionB{It is a system with a Client-Server architecture}
    \optionC{It allows the development of systems with a Peer-to-Peer architecture}
    \optionD{It allows the development of systems with Peer-to-Peer,
      Client-Server, or Publish-Subscribe architectures}
  \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

%12
\newcommand{\qZeroMQWorkersPerCore}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      The idea was to launch one worker thread per CPU core---having
      two threads sharing the same core would only mean a lot of
      context switching for no particular advantage.
    \end{quote}
    Qual  o estilo arquitectural mais adequado para representar esta
    deciso de desenho?

    \optionA{O estilo Tiers}
    \optionB{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \optionC{O estilo Instalao (\emph{Deployment})}
    \optionD{O estilo Atribuio de Trabalho (\emph{Work Assignment})}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQWorkersPerCoreINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      The idea was to launch one worker thread per CPU core---having
      two threads sharing the same core would only mean a lot of
      context switching for no particular advantage.
    \end{quote}
    Which architectural style is more adequate to represent the
    information presented above?

    \optionA{The Tiers style}
    \optionB{The Communicating Processes style}
    \optionC{The Deployment style}
    \optionD{The Work Assignment style}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%13
\newcommand{\qZeroMQMessagingPatterns}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      Messaging patterns form a layer (the so-called "scalability
      layer") on top of the transport layer (TCP and friends).
      Individual messaging patterns are implementations of this layer.
    \end{quote}
    Qual  a principal vantagem da adopo desta arquitectura de
    camadas pelo ZeroMQ?

    \optionA{Aumenta a portabilidade para outros sistemas operativos}
    \optionB{Facilita a adio de novos messaging patterns}
    \optionC{Torna o sistema mais escalvel}
    \optionD{Facilita a reutilizao dos messaging patterns}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQMessagingPatternsINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      Messaging patterns form a layer (the so-called "scalability
      layer") on top of the transport layer (TCP and friends).
      Individual messaging patterns are implementations of this layer.
    \end{quote}
    What is the main advantage of this layered architecture adopted by
    ZeroMQ?

    \optionA{Increases the portability of the system for other
      operating systems}
    \optionB{Facilitates the addition of new messaging patterns}
    \optionC{Makes the system more scalable}
    \optionD{Facilitates the reuse of the messaging patterns}
    \putOptions

% Resposta: B
  \end{ClosedQuestion}
}


%14
\newcommand{\qZeroMQLockFree}{
  \begin{ClosedQuestion}
    No documento que descreve o ZeroMQ pode ler-se o seguinte:
    \begin{quote}
      MQ uses a lock-free queue in pipe objects to pass messages
      between the user's threads and MQ's worker threads.  There are
      two interesting aspects to how MQ uses the lock-free queue.
      First, each queue has exactly one writer thread and exactly one
      reader thread.  If there's a need for 1-to-N communication,
      multiple queues are created.  Given that this way the queue
      doesn't have to take care of synchronising the writers (there's
      only one writer) or readers (there's only one reader) it can be
      implemented in an extra-efficient way.
    \end{quote}
    O estilo arquitectural que melhor representa o padro de
    interaco descrito acima 

    \optionA{O estilo Canais-e-Filtros (\emph{Pipe-and-Filter})}
    \optionB{O estilo Dados Partilhados (\emph{Shared data})}
    \optionC{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \optionD{O estilo Cliente-Servidor (\emph{Client-Server})}
   \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qZeroMQLockFreeINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes ZeroMQ:
    \begin{quote}
      MQ uses a lock-free queue in pipe objects to pass messages
      between the user's threads and MQ's worker threads.  There are
      two interesting aspects to how MQ uses the lock-free queue.
      First, each queue has exactly one writer thread and exactly one
      reader thread.  If there's a need for 1-to-N communication,
      multiple queues are created.  Given that this way the queue
      doesn't have to take care of synchronising the writers (there's
      only one writer) or readers (there's only one reader) it can be
      implemented in an extra-efficient way.
    \end{quote}
    The architectural style that better represents the interaction
    pattern described above is

    \optionA{The Pipe-and-Filter style}
    \optionB{The Shared data style}
    \optionC{The Communicating Processes style}
    \optionD{The Client-Server style}
   \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%15
\newcommand{\qZeroMQBatching}{
  \begin{ClosedQuestion}
    O ZeroMQ usa \emph{batching} dinmico para controlar o desempenho
    do sistema.  A utilizao desta abordagem tem como objectivo

    \optionA{Diminuir a latncia do envio de uma mensagem quando o
      sistema est sobrecarregado}
    \optionB{Aumentar o \emph{throughput} do sistema quando este est
      sobrecarregado}
    \optionC{Diminuir a quantidade de memria necessria para o envio
      de um elevado nmero de mensagens}
    \optionD{Reduzir a utilizao do processador quando o sistema tem
      poucas mensagens para enviar}
    \putOptions

% Resposta: B 
 \end{ClosedQuestion}
}

\newcommand{\qZeroMQBatchingINGLES}{
  \begin{ClosedQuestion}
    ZeroMQ uses dynamic batching to control the performance of the
    system.  The goal of this approach is

    \optionA{To reduce the latency of sending a message when the
      system is overloaded}
    \optionB{To increase the throughput of the system when it is overloaded}
    \optionC{To reduce the amount of memory needed to send a large
      number of messages}
    \optionD{To reduce the CPU usage when the system has just a few
      messages to send}
    \putOptions

% Resposta: B 
 \end{ClosedQuestion}
}



%16
\newcommand{\qWebPartioning}{
  \begin{ClosedQuestion}
    No documento que descreve a arquitectura de um servio web (em
    anexo), uma das abordagens introduzidas na Seco~1.2  a de
    \emph{partitioning}, ilustrada na Figura~1.4.  A utilizao de
    \emph{partitioning} faz com que

    \optionA{A disponibilidade aumente}
    \optionB{A capacidade aumente}
    \optionC{A capacidade aumente mas a disponibilidade diminua}
    \optionD{A disponibilidade e a capacidade aumentem}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qWebPartioningINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes the architecture of web
    services (attached at the end of this document), one of the
    approaches introduced in Section~1.2 is \emph{partitioning}, shown
    in Figure~1.4.  The use of \emph{partitioning}

    \optionA{Increases the availability}
    \optionB{Increases the capacity}
    \optionC{Increases the capacity but decreases the availability}
    \optionD{Increases both the availability and the capacity}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%17
\newcommand{\qWebPartitioningDois}{
  \begin{ClosedQuestion}
    Considerando ainda o caso da pergunta anterior, compare as
    arquitecturas esboadas nas Figura~1.3 e Figura~1.4.  A diferena
    entre as duas arquitecturas manifesta-se

    \optionA{Apenas na vista de Instalao (\emph{Deployment}), porque
      apenas se altera o nmero de mquinas que vo conter as imagens} 
    \optionB{Na vista de Utilizao (\emph{Uses}), porque cada
      \emph{Image Write/Retrieval Service} vai usar um \emph{Image
        File Storage} diferente}
    \optionC{Na vista de Componente-e-Conector, porque  preciso
      alterar os componentes e os conectores do sistema}
    \optionD{Na vista de Decomposio, porque precisamos de mais
      mdulos para representar a diviso das imagens por diferentes
      elementos da arquitectura}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qWebPartitioningDoisINGLES}{
  \begin{ClosedQuestion}
    Considering again the case of the previous question, compare the
    architectures sketched in Figure~1.3 and Figure~1.4.  The
    difference between the two shows

    \optionA{Only in the Deployment view, because only the number of
      machines storing images was changed} 
    \optionB{In the Uses view, because each \emph{Image
        Write/Retrieval Service} is going to use a different
      \emph{Image File Storage}}
    \optionC{In the Component-and-Connector view, because components
      and connectors need to be changed}
    \optionD{In the Decomposition view, because we need more modules
      to represent the split of images by different elements of the
      architecture}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

%18
\newcommand{\qWebRedundancy}{
  \begin{ClosedQuestion}
    Considere a arquitectura apresentada na Figura~1.3 do caso das
    perguntas anteriores, em que se introduziu redundncia no sistema.
    Neste caso particular, a introduo de redundncia na arquitectura
    tem como objectivo

    \optionA{Aumentar o desempenho da operao de \emph{Upload} de uma
    imagem}
    \optionB{Aumentar o desempenho da operao de pesquisa de uma imagem}
    \optionC{Aumentar a escalabilidade do sistema}
    \optionD{Aumentar a tolerncia a faltas do sistema}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qWebRedundancyINGLES}{
  \begin{ClosedQuestion}
    Consider again the architecture shown in Figure~1.3, where
    redundancy was introduced into the system.  In this particular
    case, introducing redundancy into the architecture has the goal of

    \optionA{Increasing the performance of the \emph{Upload} operation}
    \optionB{Increasing the performance of the \emph{Retrieval} operation}
    \optionC{Increasing the scalability of the system}
    \optionD{Increasing the fault tolerance of the system}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%19
\newcommand{\qWebLoadBalancer}{
  \begin{ClosedQuestion}
    No documento que descreve a arquitectura de servios web pode
    ler-se o seguinte:
    \begin{quote}
      Another critical piece of any distributed system is a load
      balancer.  Load balancers are a principal part of any
      architecture, as their role is to distribute load across a set
      of nodes responsible for servicing requests.  This allows
      multiple nodes to transparently service the same function in a
      system.  Their main purpose is to handle a lot of simultaneous
      connections and route those connections to one of the request
      nodes, allowing the system to scale to service more requests by
      just adding nodes.
    \end{quote}
    Com base na descrio acima, qual lhe parece ser a melhor forma de
    representar a arquitectura de um sistema que esteja a usar um
    \emph{load balancer}?

    \optionA{Com uma vista de componente-e-conector, em que o
      \emph{load balancer}  um dos componentes do sistema}
    \optionB{Com uma vista de Instalao (\emph{Deployment}), em que o
      \emph{load balancer} faz parte da infra-estrutura de comunicao
      usada para executar o sistema}
    \optionC{Com uma vista de Utilizao (\emph{Uses}), representando
      as dependncias existentes entre o \emph{load balancer} e os
      servios que ele usa}
    \optionD{Com uma vista de Camadas (\emph{Layers}), em que o
      \emph{load balancer} cria uma camada de abstraco entre quem
      efectua o pedido e quem providencia o servio}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qWebLoadBalancerINGLES}{
  \begin{ClosedQuestion}
    According to the document that describes the architecture of web
    services:
    \begin{quote}
      Another critical piece of any distributed system is a load
      balancer.  Load balancers are a principal part of any
      architecture, as their role is to distribute load across a set
      of nodes responsible for servicing requests.  This allows
      multiple nodes to transparently service the same function in a
      system.  Their main purpose is to handle a lot of simultaneous
      connections and route those connections to one of the request
      nodes, allowing the system to scale to service more requests by
      just adding nodes.
    \end{quote}
    Based on this description, what is the best way to represent the
    architecture of a system that is using a \emph{load balancer}?

    \optionA{With a component-and-connector view, where the 
      \emph{load balancer} is a component of the system}
    \optionB{With a Deployment view, where the \emph{load balancer} is
      part of the communication infra-structure used to execute the
      system}
    \optionC{With a Uses view, representing the existing dependencies
      between the \emph{load balancer} and the services that it uses}
    \optionD{With a Layers view, where the \emph{load balancer}
      creates an abstraction layer between who makes the request and
      who provides the service}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}


%20
\newcommand{\qThreeVsFourTiers}{
  \begin{ClosedQuestion}
    A arquitectura de software tpica de uma aplicao empresarial 
    composta por trs \emph{tiers} e por trs camadas.  No entanto,
    podemos ter variaes a esta arquitectura.  Por exemplo, separando
    o \emph{tier} do meio em dois \emph{tiers}.  Neste caso, que
    alteraes  que existem ao nvel da arquitectura de camadas?

    \optionA{Passamos a ter quatro camadas, em que cada camada 
      executada no \emph{tier} correspondente, como anteriormente}
    \optionB{Cada um dos dois \emph{tiers} do meio executa as trs
      camadas j existentes anteriormente, no sendo necessrio
      alterar a vista de camadas}
    \optionC{No existe qualquer relao entre os \emph{tiers} e as
      camadas, pelo que a arquitectura de camadas no  alterada}
    \optionD{A execuo das camadas anteriormente existente  separada
      entre os dois novos \emph{tiers}, podendo aparecer novas camadas
      pelo meio}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qThreeVsFourTiersINGLES}{
  \begin{ClosedQuestion}
    The typical software architecture of an enterprise application is
    composed of three tiers and three layers.  Yet, we may have
    variations of this architecture.  For instance, by separating the
    middle tier in two tiers.  In this case, which other changes exist
    on the architecture that are related with the layers?

    \optionA{We now have four layers, where each layer is executed in
      the corresponding tier, as before}
    \optionB{Each one of the two middle tiers executes the previously
      existing three layers, and no change is needed on the layers
      view}
    \optionC{There is no relation between the tiers and the layers, so
      the layers architecture is not changed}
    \optionD{The execution of the previously existing layers is split
      between the two new tiers, and new intermediate layers may be
      needed}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%21
\newcommand{\qDomainLogicFenix}{
  \begin{ClosedQuestion}
    A primeira arquitectura do sistema Fnix, correspondendo aos seus
    primeiros anos de desenvolvimento, podia ser descrita como uma
    arquitectura de trs camadas, tpica de uma aplicao empresarial.
    Uma dessas camadas era a camada de lgica de domnio (\emph{Domain
      Logic}).  Qual das seguintes afirmaes melhor caracteriza a
    arquitectura do Fnix no que diz respeito a essa camada?
    
    \optionA{A camada de lgica de domnio era implementada seguindo
      a abordagem do padro Domain Model}
    \optionB{A camada de lgica de domnio era implementada seguindo
      a abordagem do padro Transaction Script}
    \optionC{A camada de lgica de domnio era implementada seguindo
      a abordagem do padro Service Layer}
    \optionD{A camada de lgica de domnio era implementada como um
      modelo de domnio rico, em cima do qual existia uma camada de
      servios fina}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}

\newcommand{\qDomainLogicFenixINGLES}{
  \begin{ClosedQuestion}
    The first architecture of the Fnix system, corresponding to its
    first years of development, could be described as a three-layered
    architecture, typical of an enterprise application.  One of those
    layers was the \emph{domain logic} layer.  Which of the following
    sentences best describes the Fnix architecture in what concerns
    that layer?
    
    \optionA{The domain logic layer was implemented with the Domain
      Model pattern}
    \optionB{The domain logic layer was implemented with the
      Transaction Script pattern}
    \optionC{The domain logic layer was implemented with the Service
      Layer pattern}
    \optionD{The domain logic layer was implemented with a rich domain
      model, on top of which there was a thin service layer}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}


%22
\newcommand{\qIncrementalReleases}{
  \begin{ClosedQuestion}
    Para colocar um produto mais rapidamente no mercado, as empresas
    de desenvolvimento de software esto cada vez mais a usar uma
    estratgia incremental de desenvolvimento, lanando periodicamente
    novas verses do produto com novas funcionalidades.  Qual dos
    estilos arquitecturais  melhor para analizar se a arquitectura de
    software do sistema  adequada para o lanamento incremental das
    vrias verses?

    \optionA{O estilo Decomposio}
    \optionB{O estilo Generalizao}
    \optionC{O estilo Utilizao}
    \optionD{O estilo SOA}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qIncrementalReleasesINGLES}{
  \begin{ClosedQuestion}
    To achieve a faster time-to-market, software companies are
    increasingly using a strategy of incremental releases of their
    software, where each new release has a set of new features.  Which
    architectural style is better to analyse whether the system's
    software architecture is adequate for the planned incremental
    releases?
   
    \optionA{The Decomposition style}
    \optionB{The Generalization style}
    \optionC{The Uses style}
    \optionD{The SOA style}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%23
\newcommand{\qScalability}{
  \begin{ClosedQuestion}
    Vrios dos casos estudados na cadeira tinham requisitos de
    escalabilidade.  Isso significa que os sistemas em causa
    devem ser construdos de forma a

    \optionA{Ter um elevado \emph{throughput}}
    \optionB{Ter uma latncia baixa}
    \optionC{Ter a capacidade de suportar muitos utilizadores em simultneo}
    \optionD{Poderem ser facilmente alterados para aumentar o seu desempenho}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qScalabilityINGLES}{
  \begin{ClosedQuestion}
    Several of the cases studied in this course had scalability
    requirements.  That means that those systems should be designed in
    such a way that they

    \optionA{Have high throughput}
    \optionB{Have low latency}
    \optionC{Allow many simultaneous users}
    \optionD{May be easily changed to increase their performance}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%24
\newcommand{\qSOA}{
  \begin{ClosedQuestion}
    No estilo arquitectural \emph{Service Oriented Architecture} 
    comum a existncia de um componente especializado, designado por
    \emph{Enterprise Service Bus} (ESB).  A utilizao de um ESB num
    sistema tem como objectivo

    \optionA{Facilitar a interaco entre componentes heterogneos que
      utilizam protocolos de comunicao distintos}
    \optionB{Promover a utilizao de um protocolo de comunicao
      comum para todos os restantes componentes do sistema}
    \optionC{Aumentar o desempenho na interaco entre componentes do
      sistema}
    \optionD{Criar uma ligao forte entre os vrios servios
      disponibilizados na organizao}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qSOAINGLES}{
  \begin{ClosedQuestion}
    In the Service Oriented Architecture style it is common to have a
    specialized component, named \emph{Enterprise Service Bus} (ESB).
    The goal of using of an ESB in a system is

    \optionA{To facilitate the interaction among heterogeneous
      components that use distinct communication protocols}
    \optionB{To promote the use of a common communication protocol for
      all the remaining components of the system}
    \optionC{To increase the performance of the interaction between
      the components of the system}
    \optionD{To create a strong coupling between the various services
      provided by the organization}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


%25
\newcommand{\qAvailability}{
  \begin{ClosedQuestion}
    Para satisfazer requisitos de disponibilidade existem diferentes
    tcticas, que podem ser aplicadas dependendo do tipo concreto de
    requisito que pretendemos satisfazer.  Supondo que pretende
    detectar faltas do tipo \emph{resposta} no seu sistema, que
    tctica  mais adequada?

    \optionA{A tctica \emph{Ping/Echo}}
    \optionB{A tctica \emph{Heartbeat}}
    \optionC{A tctica de \emph{Voting}}
    \optionD{A tctica de \emph{Removal from Service}}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qAvailabilityINGLES}{
  \begin{ClosedQuestion}
    There are several tactics to satisfy availability requirements,
    which may be applied depending on the concrete requirement that we
    want to satisfy.  Assuming that you want to detect faults of type
    \emph{response} in your system, which tactic is more adequate?

    \optionA{The Ping/Echo tactic}
    \optionB{The Heartbeat tactic}
    \optionC{The Voting tactic}
    \optionD{The Removal from Service tactic}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%26
\newcommand{\qSecurity}{
  \begin{ClosedQuestion}
    Suponha que para satisfazer um requisito de segurana relacionado
    com a possibilidade de ataques por parte de utilizadores que
    acedem ao seu sistema pela Internet, pretende utilizar a tctica
    designada por \emph{Limit Exposure}.  Como  que a utilizao
    dessa tctica se manifesta nas vistas da arquitectura do seu
    sistema?

    \optionA{Na vista de Instalao}
    \optionB{Na vista de Decomposio}
    \optionC{Numa vista de componente-e-conector}
    \optionD{Na vista de Aspectos}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qSecurityINGLES}{
  \begin{ClosedQuestion}
    Suppose that, to satisfy a security requirement related with
    possible attacks coming from users that access your system through
    the Internet, you want to use the tactic named \emph{Limit
      Exposure}.  How does the use of that tactic manifests in the
    architectural views of your system?

    \optionA{In the Deployment view}
    \optionB{In the Decomposition view}
    \optionC{In a view of the component-and-connector type}
    \optionD{In the Aspects view}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}

%27
\newcommand{\qSkeletonSystem}{
  \begin{ClosedQuestion}
    Uma das boas prticas na concepo de uma arquitectura de software
     a criao de um sistema esqueleto.  Qual o seu objectivo?

    \optionA{Criar uma camada de abstraco entre a arquitectura do
      sistema e as suas funcionalidades, de modo a poder-se alterar a
      arquitectura mais tarde sem afectar as funcionalidades}
    \optionB{Criar um artefacto que pode ser usado para explicar a
      arquitectura de software do sistema aos vrios \emph{stakeholders}}
    \optionC{Permitir testar e validar a arquitectura de software numa
      fase inicial do desenvolvimento}
    \optionD{Facilitar a atribuio de trabalho aos membros da equipa
      de desenvolvimento que vo implementar as funcionalidades do sistema}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qSkeletonSystemINGLES}{
  \begin{ClosedQuestion}
    One of the best practices in the design of a software architecture
    is to create a skeleton system.  What is its purpose?

    \optionA{To create an abstraction layer between the architecture
      of the system and its functionalities, so that the architecture
      may be changed later without affecting the functionalities}
    \optionB{To create an artifact that may be used to explain the
      system's software architecture to the various stakeholders}
    \optionC{To allow testing and validating the software architecture
      in the early development stages}
    \optionD{To facilitate the work assignment to the members of the
      development team that will implement the system's functionalities}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%28
\newcommand{\qChromiumDecomposition}{
  \begin{ClosedQuestion}
    A pgina que descreve a arquitectura do Chromium OS (um projecto
    \emph{open source} para a implementao de um novo sistema
    operativo) comea da seguinte forma:
    \begin{quote}
      Chromium OS consists of three major components: 
      \begin{itemize}
      \item The Chromium-based browser and the window manager
      \item System-level software and user-land services: the kernel, drivers, connection manager, and so on
      \item Firmware 
      \end{itemize}
    \end{quote}

    Tendo em conta esta breve descrio da arquitectura de software do
    Chromium OS, que estilo arquitectural lhe parece mais adequado
    para a representar?

    \optionA{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{Um estilo qualquer do tipo de vista componente-e-conector}
    \optionD{O estilo Decomposio (\emph{Decomposition})}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qChromiumDecompositionINGLES}{
  \begin{ClosedQuestion}
    The web page that describes the architecture of Chromium OS (an
    open source project to implement a new operating system) starts
    like this:
    \begin{quote}
      Chromium OS consists of three major components: 
      \begin{itemize}
      \item The Chromium-based browser and the window manager
      \item System-level software and user-land services: the kernel, drivers, connection manager, and so on
      \item Firmware 
      \end{itemize}
    \end{quote}
    Considering this brief description of the software architecture of
    Chromium OS, which architectural style is more adequate to
    represent it?

    \optionA{The Communicating Processes style}
    \optionB{The Client-Server style}
    \optionC{Any style of the component-and-connector viewtype}
    \optionD{The Decomposition style}

    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%29
\newcommand{\qArqEmailMTAIMAP}{
  \begin{ClosedQuestion}
    O sistema de email  composto por vrios tipos de componentes que
    desempenham diferentes funes.  Por exemplo, para enviar um
    email, um utilizador usa um \emph{mail user agent} (MUA), para
    compor a sua mensagem e envi-la.  Para enviar a mensagem,
    tipicamente o MUA liga-se a um \emph{mail transfer agent} (MTA),
    que recebe a mensagem, analisa os cabealhos da mesma para
    determinar os vrios destinatrios e, aps consulta do sistema DNS
    para determinar quais os MTA responsveis por cada um dos
    destinatrios, liga-se aos MTAs responsveis pelos endereos de
    destino para entregar a mensagem.  Cada um desses MTAs recebe a
    mensagem e armazena-a localmente ou reenvia-a para outros MTAs at
    que a mensagem chegue ao MTA do destino.  O utilizador
    destinatrio da mensagem ir depois usar o seu MUA para ver as
    mensagens que lhe foram enviadas.  Para isso o MUA liga-se a um
    servidor IMAP ou POP para obter as mensagens que lhe foram
    destinadas.  Esses servidores IMAP e POP obtm as mensagens de um
    utilizador consultando as mensagens armazenadas pelo MTA.

    Tendo em conta esta descrio simplificada do funcionamento do
    sistema de email, qual dos estilos arquitecturais lhe parece mais
    adequada para representar o padro de interaco existente entre o
    MTA e os servidores de IMAP e POP?

    \optionA{O estilo arquitectural Par-a-Par (\emph{Peer-to-Peer})}
    \optionB{O estilo arquitectural Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo arquitectural Dados-Partilhados \emph{Shared-Data}}
    \optionD{O estilo arquitectural Publicao-Subscrio (\emph{Publish-subscribe})}

    \putOptions
  \end{ClosedQuestion}
}

\newcommand{\qArqEmailMTAIMAPINGLES}{
  \begin{ClosedQuestion}
    The email system is composed of various types of components
    playing different roles.  For example, to send an email, a user
    uses a \emph{mail user agent} (MUA), to compose his message and
    send it.  To send the message, the MUA typically connects to a
    \emph{mail transfer agent} (MTA) that receives the message,
    analyzes the message's headers to determine the recipients and,
    after querying the DNS system to determine the MTA responsible for
    each recipient, it connects to the MTAs responsible for the
    destination addresses to deliver the message.  Each of these MTAs
    receives the message and stores it locally or forwards it to
    others MTAs until the message reaches its destination MTA.
    The recipient user of the message will then use his MUA to see the
    messages that were sent to him.  To do it, the MUA connects to an
    IMAP or POP server to obtain the user's messages.  Those IMAP and
    POP servers obtain the messages for a user by reading the messages
    stored by the MTA.

    Given this simplified description of the operation of the email
    system, which of the following architectural styles is more
    appropriate to represent the pattern of interaction between the
    MTA and the servers IMAP and POP?

    \optionA{The Peer-to-Peer style}
    \optionB{The Client-Server style}
    \optionC{The Shared-Data style}
    \optionD{The Publish-subscribe style}

    \putOptions
  \end{ClosedQuestion}
}


%30
\newcommand{\qAspects}{
  \begin{ClosedQuestion}
    O estilo arquitectural Aspectos (\emph{Aspects}) foi mais
    recentemente introduzido como um estilo do tipo de vista mdulo.
    A utilizao deste estilo na arquitectura de software de um sistema

    \optionA{No altera os mdulos existentes no sistema, visto que
      isso  determinado pela Decomposio do sistema, que no sofre
      alteraes}
    \optionB{Cria restries s relaes de dependncia existentes
      entre mdulos e representadas noutros estilos, tal como o estilo
      camadas}
    \optionC{Tipicamente d origem  criao de mais mdulos do que os
      que existiriam se este estilo no fosse usado}
    \optionD{Apenas introduz um novo tipo de relao entre os mdulos
      j existentes no sistema, que resultam da aplicao dos outros
      estilos do tipo de vista mdulo}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qAspectsINGLES}{
  \begin{ClosedQuestion}
    The Aspects style was introduced recently as a new style of the
    module viewtype.  Using this style in the software architecture of
    a system

    \optionA{Does not change the existing modules of the system,
      because they are determined by the system's Decomposition, which
      is not changed}
    \optionB{Adds restrictions to the dependency relationships that
      exist between modules and that are represented using other
      styles, as with the layers style}
    \optionC{Typically gives rise to more modules than what we would
      have if not using this style}
    \optionD{Introduces only a new type of relation among the existing
      modules of the system, which resulted from other styles of the
      module viewtype}

    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}



%% =========================================================================
%% exam2 2011/2012
%% =========================================================================

%1
\newcommand{\qHadoopStakeholdersEuros}{
  \begin{ClosedQuestion}
    Para os \emph{stakeholders} do sistema Hadoop a soluo de
    construir um \emph{cluster} de servidores usando muitas mquinas
    de baixo custo foi:

    \optionA{Determinante para garantir a escalabilidade do sistema}
    \optionB{Determinante para que os custos de falha de um elemento de hardware sejam reduzidos}
    \optionC{Determinante para garantir a portabilidade do sistema}
    \optionD{Determinante para permitir a integrao com sistemas legados}

    \putOptions
% Resposta: B
\end{ClosedQuestion}
}

\newcommand{\qHadoopStakeholdersEurosINGLES}{
  \begin{ClosedQuestion}
    From the stakeholders perspective the use of low cost servers to build the clusters is:

    \optionA{Essential to ensure the system scalability}
    \optionB{Essential to reduce costs whenever there is a fault in a hardware element}
    \optionC{Essential to ensure the system portability}
    \optionD{Essential to facilitate the integration with legacy systems}

    \putOptions
% Resposta: B
\end{ClosedQuestion}
}


%2
\newcommand{\qHadoopCheckpointBackupNode}{
  \begin{ClosedQuestion}
    No sistema Hadoop a utilizao de um \emph{BackupNode} em vez de
    um \emph{CheckpointNode}:

    \optionA{Permite a criao de \emph{checkpoints} mas tem que pedir toda a informao de uma vez s ao \emph{NameNode}}
    \optionB{No permite a criao de \emph{checkpoints}}
    \optionC{Permite a criao de \emph{checkpoints} com a informao que recebe gradualmente do \emph{NameNode}}
    \optionD{Permite a criao de \emph{checkpoints} sem necessitar de informao do \emph{NameNode}}

    \putOptions
% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qHadoopCheckpointBackupNodeINGLES}{
  \begin{ClosedQuestion}
    In the Hadoop system the use of a \emph{BackupNode} instead of a \emph{CheckpointNode}:

    \optionA{Allows the creation of checkpoints but it is necessary to request all the information from the \emph{NameNode} whenever a new checkpoint creation begins}
    \optionB{Does not allow the creation of checkpoints}
    \optionC{Allows the creation of checkpoints using the information that it gradually receives from the \emph{NameNode}}
    \optionD{Allows the creation of checkpoints without requiring any kind of information from the \emph{NameNode}}

    \putOptions
% Resposta: C
 \end{ClosedQuestion}
}

%3
\newcommand{\qHadoopCheckpoint}{
  \begin{ClosedQuestion}
    No sistema Hadoop o \emph{CheckpointNode}, quando executa num n
    diferente do n onde executa o \emph{NameNode}, suporta:

    \optionA{As qualidades de desempenho e disponibilidade}
    \optionB{Apenas a qualidade de desempenho}
    \optionC{Apenas a qualidade de disponibilidade}
    \optionD{As qualidades de desempenho e segurana}

    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qHadoopCheckpointINGLES}{
  \begin{ClosedQuestion}
    In the Hadoop system when the \emph{CheckpointNode} and the \emph{NameNode} are deployed in different nodes, the \emph{CheckpointNode} provides:
    \optionA{Performance and availability qualities}
    \optionB{Performance qualities only}
    \optionC{Availability qualities only}
    \optionD{Performance and security qualities}

    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

%4
\newcommand{\qHadoopPoliticaLocalizacaoReplicas}{
  \begin{ClosedQuestion}
    No sistema Hadoop a possibilidade de ter vrias polticas de localizao de rplicas:

    \optionA{Aumenta a facilidade de modificao do sistema sempre que se pretenda mudar de poltica de localizao}
    \optionB{Permite que os \emph{DataNodes} decidam que rplicas possuem}
    \optionC{Aumenta a facilidade de modificao do sistema sempre que se altera a estrutura de instalao}
    \optionD{Permite que as vrias rplicas sejam colocadas em diferentes \emph{DataNodes}}

    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qHadoopPoliticaLocalizacaoReplicasINGLES}{
  \begin{ClosedQuestion}
    The Hadoop system support of different block placement policies:

    \optionA{Increases the system modifiability whenever it is necessary to change the placement policy}
    \optionB{Allows \emph{DataNodes} to decide which replicas they have}
    \optionC{Increases the system modifiability whenever it is necessary to change the the deployment structure}
    \optionD{Allow several replicas to be located in different \emph{DataNodes}}

    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

%5
\newcommand{\qHadoopPing}{
  \begin{ClosedQuestion}
    No sistema Hadoop, durante a operao normal, o \emph{NameNode}
    poderia usar a tctica de \emph{ping} para saber se os \emph{DataNodes} esto disponveis

    \optionA{Porque esta tctica  aquela que no sobrecarrega o \emph{NameNode}}
    \optionB{Mas levaria a um maior \emph{overhead} no \emph{NameNode}}
    \optionC{Mas tambm poderia usar a tctica de excepes}
    \optionD{Para informar os restantes \emph{DataNodes} que esto disponveis}
    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}

\newcommand{\qHadoopPingINGLES}{
  \begin{ClosedQuestion}
    In the Hadoop system, during normal operation, \emph{NameNode}
    could use a ping tactic to know whether \emph{DataNodes} are available

    \optionA{Because this tactic does not overload the \emph{NameNode}}
    \optionB{But it would imply an \emph{overhead} in the \emph{NameNode}}
    \optionC{But an exceptions tactic could be used as well}
    \optionD{To notify other \emph{DataNodes} that they are available}
    \putOptions
% Resposta: B
  \end{ClosedQuestion}
}


%6
\newcommand{\qHadoopInstalacao}{
  \begin{ClosedQuestion}
    O conhecimento da estrutura de instalao no sistema Hadoop 
    relevante para o funcionamento eficaz do sistema.  Para isso o
    administrador pode configurar, para cada instalao do sistema, um
    \emph{script} que retorna a identificao do \emph{rack} onde se
    encontra um n (ver seco 8.3.2).

    \optionA{Este \emph{script} pertence ao mdulo de instalao do sistema}
    \optionB{Este \emph{script}  um mdulo do sistema e implementa uma tctica de segurana}
    \optionC{Este \emph{script}  um mdulo do sistema e implementa uma tctica de facilidade de modificao}
    \optionD{Este \emph{script} no pode ser considerado como um mdulo do sistema pois  apenas un \emph{script}}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qHadoopInstalacaoINGLES}{
  \begin{ClosedQuestion}
    Knowing the deployment structure in the Hadoop system is critical
    to the effective system operation. Therefore, for each deployment,
    the administrator can configure a script that returns a node's
    rack identification given a node's address (see section 8.3.2).

    \optionA{This script is part of the system deployment module}
    \optionB{This script is a module that implements a security tactic}
    \optionC{This script is a module that implements a modifiability tactic}
    \optionD{This script cannot be considered a module because it is only a script}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}

%7
\newcommand{\qTacticaCheckpointRollback}{
  \begin{ClosedQuestion}
    A tctica de \emph{Checkpoint/rollback}  uma tctica de

    \optionA{Disponibilidade, segurana, e desempenho}
    \optionB{Apenas de disponibilidade}
    \optionC{Disponibilidade e desempenho}
    \optionD{Disponibilidade e segurana}
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qTacticaCheckpointRollbackINGLES}{
  \begin{ClosedQuestion}
    The \emph{Checkpoint/rollback} tactic is a tactic for

    \optionA{Availability, security, and performance}
    \optionB{Availability only}
    \optionC{Availability and performance}
    \optionD{Availability and security}
    \putOptions
% Resposta: D
 \end{ClosedQuestion}
}

%8
\newcommand{\qTiposVistaDesempenho}{
  \begin{ClosedQuestion}
    Para analisar o desempenho de um sistema

    \optionA{Apenas so necessrias vistas do tipo componente-conector}
    \optionB{Todos os tipos vista podem ser necessrios}
    \optionC{Apenas so necessrias vistas do tipo componente-conector e do tipo afectao}
    \optionD{Os tipos de vista mdulo no so de certeza necessrios}
    \putOptions
% Resposta: B
 \end{ClosedQuestion}
}

\newcommand{\qTiposVistaDesempenhoINGLES}{
  \begin{ClosedQuestion}
    To analyse the performance of a system

    \optionA{Only views of the component-and-connector viewtype are needed}
    \optionB{All viewtypes may be necessary}
    \optionC{Only views of the component-and-connector viewtype and allocation viewtype are needed}
    \optionD{Views of the module viewtype are not needed}
    \putOptions
% Resposta: B
 \end{ClosedQuestion}
}

%9
\newcommand{\qUsaCircular}{
  \begin{ClosedQuestion}
    Uma vista onde seja utilizado o estilo Utilizao e que possua uma
    circularidade entre relaes usa

    \optionA{Indica que pode haver problemas para desenvolver testes incrementais}
    \optionB{Indica que se pode seguir um processo de desenvolvimento incremental dos mdulos}
    \optionC{Indica que a os mdulos que tm dependncias circulares entre eles devem ser os primeiros a ser implementados}
    \optionD{Sugere que as relaes de usa devem ser substitudas por relaes do tipo -um}
    \putOptions
% Resposta: A
\end{ClosedQuestion}
}

\newcommand{\qUsaCircularINGLES}{
  \begin{ClosedQuestion}
    A view of the \emph{Uses} style that contains a loop in the uses relationships

    \optionA{Means that it may be difficult to design incremental testing}
    \optionB{Means that it is possible to implement the system according to an incremental development process}
    \optionC{Means that the modules that are part of the loop should be implemented first}
    \optionD{Gives a hint to replace the uses relations by is-a relations}
    \putOptions
% Resposta: A
\end{ClosedQuestion}
}

%10
\newcommand{\qUsaPodeUsar}{
  \begin{ClosedQuestion}
    A diferena entre a relao \emph{usa} do estilo Utilizao e a
    relao \emph{pode usar} do estilo Camadas

    \optionA{ que a relao \emph{pode usar} define uma restrio para as possveis relaes \emph{usa} entre mdulos pertencentes a camadas diferentes}
    \optionB{ que a relao \emph{usa} apenas pode ocorrer entre mdulos pertencentes  mesma camada}
    \optionC{ que a relao \emph{pode usar} no indica que o correcto funcionamento da camada acima depende da correcta implementao da camada abaixo}
    \optionD{ que a relao \emph{pode usar}  de facto uma relao \emph{usa} entre camadas}
    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

\newcommand{\qUsaPodeUsarINGLES}{
  \begin{ClosedQuestion}
    The main difference between the \emph{Uses} relation of the Uses
    style and the \emph{Allowed to Use} relation of the Layers style
 
    \optionA{Is that the \emph{Allowed to Use} relation defines a restriction for the possible \emph{Uses} relations between modules belonging to different layers}
    \optionB{Is that the \emph{Uses} relation can happen only among modules belonging to the same layer}
    \optionC{Is that the \emph{Allowed to Use} relation does not imply that the correctness of the upper layer depends on the correct implementation of its nearest lower layer}
    \optionD{Is that the \emph{Allowed to Use} relation is a \emph{Uses} relation between layers}
    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}



%11
\newcommand{\qHadoopFileWriteBuffered}{
  \begin{ClosedQuestion}
    No terceiro pargrafo da seco 8.3.1 descreve-se o mecanismo de
    \emph{buffering} usado pelo cliente de um sistema HDFS durante a
    escrita de um ficheiro.  Suponha que quer descrever este mecanismo
    recorrendo a uma vista arquitectural.  Como  que o faria?
    
    \optionA{No faz sentido usar uma vista arquitectural para isso,
      visto que  um pormenor de implementao do sistema que no
      afecta as suas qualidades}
    \optionB{Usava uma vista do tipo mdulo que mostrasse as
      interfaces providenciadas para o cliente efectuar a escrita}
    \optionC{Usava uma vista do tipo componente-e-conector}
    \optionD{Usava uma vista do estilo arquitectural Instalao (\emph{Deployment})}
  \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qHadoopFileWriteBufferedINGLES}{
  \begin{ClosedQuestion}
    The third paragraph of section 8.3.1 describes the buffering
    mechanism used by an HDFS client when it is writing to a file.
    How would you describe this mechanism using an architectural view?
   
    \optionA{It does not make sense to use an architectural view for
      this, because this is an implementation detail that does affect
      the system's qualities}
    \optionB{Using a view of the module viewtype that shows the
      interfaces available for the client to do the write}
    \optionC{Using a view of the component-and-connector viewtype}
    \optionD{Using a view of the architectural style Deployment}
  \putOptions

% Resposta: C
  \end{ClosedQuestion}
}



%12
\newcommand{\qHadoopDisponibilidadeDados}{
  \begin{ClosedQuestion}
    Um dos principais requisitos para o sistema HDFS  a garantia de
    disponibilidade dos dados armazenados no sistema, mesmo na
    presena de vrios tipos de falhas (no simultneas) no
    \emph{hardware} em que o sistema executa.  Para mostrar que o
    sistema satisfaz este requisito

    \optionA{ necessrio recorrer a vrios tipos de vistas
      diferentes, dos tipos de vista componente-e-conector e afectao}
    \optionB{Basta mostrar, atravs de vistas do tipo
      componente-e-conector, que o sistema mantm rplicas dos dados
      em diferentes componentes}
    \optionC{Basta mostrar, atravs de vistas do estilo Instalao,
      que o componente \emph{DataNode} executa em mais do que uma
      mquina do \emph{cluster}}
    \optionD{Basta mostrar, atravs de vistas do estilo Decomposio,
      que existem mdulos responsveis por fazer a replicao dos
      blocos de um ficheiro}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}


\newcommand{\qHadoopDisponibilidadeDadosINGLES}{
  \begin{ClosedQuestion}
    One of the key requirements for the HDFS system is that the data
    stored in the system remains available, even in the presence of
    various types of failures (non simultaneous) in the hardware in
    which the system executes.  To show that the system satisfies this
    requirement

    \optionA{We must use various different views, both of the
      component-and-connector and the allocation viewtypes}
    \optionB{We just have to show, through component-and-connector
      views, that the system maintains replicas of the data in
      different components}
    \optionC{We just have to show, through Deployment views,
      that the \emph{DataNode} component executes in more than one
      machine of the cluster}
    \optionD{We just have to show, through Decomposition views, that
      there are modules responsible for the replication of file blocks}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}



%13
\newcommand{\qHadoopMapReduce}{
  \begin{ClosedQuestion}
    Considere o seguinte excerto do tutorial sobre o Hadoop MapReduce:

    \begin{quote}
      Hadoop MapReduce is a software framework for easily writing
      applications which process vast amounts of data (multi-terabyte
      data-sets) in-parallel on large clusters (thousands of nodes) of
      commodity hardware in a reliable, fault-tolerant manner.

      A MapReduce job usually splits the input data-set into
      independent chunks which are processed by the map tasks in a
      completely parallel manner.  The framework sorts the outputs of
      the maps, which are then input to the reduce tasks. Typically
      both the input and the output of the job are stored in a
      file-system.  The framework takes care of scheduling tasks,
      monitoring them and re-executes the failed tasks.
    \end{quote}

    Que estilo arquitectural do tipo de vista componente-e-conector
    lhe parece mais adequado para descrever o funcionamento do
    MapReduce, tendo em conta as suas principais vantagens na
    resoluo de um problema?

    \optionA{O estilo Dados Partilhados (\emph{Shared data})}
    \optionB{O estilo Canais-e-filtros (\emph{Pipes-and-filters})}
    \optionC{O estilo Par-a-Par (\emph{Peer-to-Peer})}
    \optionD{O estilo Processos Comunicantes (\emph{Communicating Processes})}
   \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qHadoopMapReduceINGLES}{
  \begin{ClosedQuestion}
    Consider the following excerpt from the tutorial on the Hadoop
    MapReduce:

    \begin{quote}
      Hadoop MapReduce is a software framework for easily writing
      applications which process vast amounts of data (multi-terabyte
      data-sets) in-parallel on large clusters (thousands of nodes) of
      commodity hardware in a reliable, fault-tolerant manner.

      A MapReduce job usually splits the input data-set into
      independent chunks which are processed by the map tasks in a
      completely parallel manner.  The framework sorts the outputs of
      the maps, which are then input to the reduce tasks. Typically
      both the input and the output of the job are stored in a
      file-system.  The framework takes care of scheduling tasks,
      monitoring them and re-executes the failed tasks.
    \end{quote}

    Which architectural style of the component-and-connector viewtype
    is more adequate to describe how the MapReduce works, taking into
    account its main advantages in solving a problem?

    \optionA{The Shared data style}
    \optionB{The Pipes-and-filters style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Communicating Processes style}
   \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%14
\newcommand{\qHadoopComoDatabase}{
  \begin{ClosedQuestion}
    Suponha que est a implementar uma aplicao web e que decidiu
    usar um sistema HDFS para armazenar os dados da sua aplicao.  Ou
    seja, a sua aplicao web ir ser um cliente do sistema HDFS.
    Como  que esta deciso afecta a arquitectura da sua aplicao web?

    \optionA{A vista de componente-e-conector da aplicao tem
      necessariamente que passar a incluir os componentes \emph{NameNode} e
      \emph{DataNode} com os quais a aplicao web tem que interagir
      para aceder aos seus dados}
    \optionB{A vista de camadas da aplicao web passa a
      incluir uma camada que corresponde  \emph{framework} Hadoop
      MapReduce}
    \optionC{A aplicao continua a ter uma arquitectura de trs
      \emph{tiers}, em que um deles  o sistema HDFS}
    \optionD{A vista de Instalao do sistema tem que ser alterada
      para passar a incluir os \emph{racks} necessrios para o
      funcionamento do HDFS}
   \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qHadoopComoDatabaseINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are implementing a web application and that you
    decided to use an HDFS system to store the data of your
    application---that is, your web application will be a client of
    the HDFS system.  How does this decision affects the architecture
    of your web application?

    \optionA{The component-and-connector view must, necessarily, be
      changed to include the components \emph{NameNode} and
      \emph{DataNode}, with which the web application has to interact
      to access its data}
    \optionB{The layered view of the web application will have to
      include a new layer corresponding to the Hadoop MapReduce
      framework}
    \optionC{The application continues to have a three-tiered
      architecture, where one of the tiers is now the HDFS system}
    \optionD{The Deployment view must be changed to include the racks
      needed to run the HDFS system}
   \putOptions

% Resposta: C
  \end{ClosedQuestion}
}



%15
\newcommand{\qHadoopCheckpointNode}{
  \begin{ClosedQuestion}
    Tendo em conta a descrio do \emph{CheckpointNode} feita na
    seco 8.2.5, qual  o estilo arquitectural que melhor representa
    a interaco existente entre os componentes \emph{CheckpointNode}
    e \emph{NameNode}?

    \optionA{O estilo Canais-e-Filtros (\emph{Pipes-and-filters})}
    \optionB{O estilo Publicao-Subscrio (\emph{Publish-Subscribe})}
    \optionC{O estilo Par-a-Par (\emph{Peer-to-Peer})}
    \optionD{O estilo Cliente-Servidor (\emph{Client Server})}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qHadoopCheckpointNodeINGLES}{
  \begin{ClosedQuestion}
    Considering the description of the \emph{CheckpointNode} made in
    Section~8.2.5, which architectural style best represents the
    interaction between the \emph{CheckpointNode} and the
    \emph{NameNode} components?

    \optionA{The Pipes-and-filters style}
    \optionB{The Publish-Subscribe style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Client Server style}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%16
\newcommand{\qDomainModel}{
  \begin{ClosedQuestion}
    Dois dos padres existentes para implementar a camada de lgica de
    domnio de uma aplicao empresarial so o Domain Model e o
    Transaction Script.  A escolha de um ou outro
    
    \optionA{Apenas afecta a camada de lgica de domnio}
    \optionB{Pode afectar a camada de acesso a dados porque cada
      padro coloca requisitos diferentes na interface dessa camada}
    \optionC{No afecta a camada de lgica de apresentao porque no
      a pode usar}
    \optionD{No afecta a camada de acesso a dados porque a camada de
      acesso a dados no usa a camada de lgica de domnio}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}

\newcommand{\qDomainModelINGLES}{
  \begin{ClosedQuestion}
    \emph{Domain Model} and \emph{Transaction Script} are two of the
    existing patterns to implement the domain logic layer of an
    enterprise application.  Choosing one or the other
   
    \optionA{Affects only the domain logic layer}
    \optionB{May affect the data access layer because each pattern
      puts different requirements on the interface of that layer}
    \optionC{Does not affect the presentation logic layer because it
      cannot use it}
    \optionD{Does not affect the data access layer because the data
      access layer does not use the domain logic layer}
    \putOptions

% Resposta: B
 \end{ClosedQuestion}
}


%17
\newcommand{\qRelacaoComponentesMaquinas}{
  \begin{ClosedQuestion}
    Qual das seguintes frases captura melhor as restries existentes
    relativamente a que componentes podem executar em que mquinas no
    estilo Instalao?

    \optionA{Uma mquina pode executar apenas um componente, mas um
      componente pode executar em mais do que uma mquina}
    \optionB{Um componente pode executar apenas numa mquina, mas uma
      mquina pode executar mais do que um componente}
    \optionC{Cada componente executa numa nica mquina e cada mquina
      executa apenas um componente}
    \optionD{Todos os componentes podem executar em todas as mquinas}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}

\newcommand{\qRelacaoComponentesMaquinasINGLES}{
  \begin{ClosedQuestion}
    Which of the following sentences best captures the restrictions
    regarding which components may execute in which machines in the
    Deployment style?

    \optionA{A machine may execute only one component, but a component
      may execute in more than one machine}
    \optionB{A component may execute in only one machine, but a
      machine may execute more than one component}
    \optionC{Each component executes in only one machine and each
      machine executes only one component}
    \optionD{All components may execute in all machines}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}


%18
\newcommand{\qWebDois}{
  \begin{ClosedQuestion}
    Com a evoluo das tecnologias para o desenvolvimento de
    aplicaes web, passou a ser possvel desenvolver aplicaes web
    com uma interface com o utilizador muito mais parecida com a das
    tradicionais aplicaes de \emph{desktop}.  No entanto, para isto
    acontecer, foi necessrio que parte do cdigo que executava no
    servidor web passasse a ser agora executado no browser.  Como 
    que esta mudana se manifesta ao nvel da arquitectura do sistema?

    \optionA{Na vista de Instalao, visto que o componente
      de apresentao passa a executar-se noutro stio}
    \optionB{Na vista de componente-e-conector, porque o
      conector que liga o cliente web ao servidor web tem que mudar}
    \optionC{Na vista de camadas, porque a ordem das camadas passa a
      ser outra}
    \optionD{Na correspondncia entre as camadas do sistema e os
      componentes onde elas executam}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qWebDoisINGLES}{
  \begin{ClosedQuestion}
    With the evolution of the web application technologies, it is now
    possible to develop web applications with a user interface similar
    to the interface of desktop applications.  Yet, for this to
    happen, part of the code that was executing in the web server is
    now executing in the web browser.  How does this change manifests
    in the software architecture of the system?

    \optionA{In the Deployment view, because the presentation
      component is now executing in a different place}
    \optionB{In the component-and-connector view, because the
      connector between the web client and the web server has to change}
    \optionC{In the Layer view, because the order of the layers will
      have to change}
    \optionD{In the mapping between layers of the system and the
      components where they execute}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%19
\newcommand{\qMashups}{
  \begin{ClosedQuestion}
    Uma das evolues no desenvolvimento de aplicaes web foi a
    criao de \emph{mashups}, que so descritas na Wikipedia da
    seguinte forma:

    \begin{quote}
      In web development, a mashup is a web page or application that
      uses and combines data, presentation or functionality from two
      or more sources to create new services.
    \end{quote}

    Sabendo que as fontes usadas pelos \emph{mashups} no tm
    conhecimento da existncia dos \emph{mashups} e mudam com
    frequncia, obrigando a alteraes nos \emph{mashups} para
    acomodar essas mudanas, qual  a melhor arquitectura para
    minimizar o efeito dessas alteraes?
 
    \optionA{Uma arquitectura de \emph{web services}}
    \optionB{Uma arquitectura Cliente-Servidor, em que o \emph{mashup}
       o cliente e as vrias fontes so os servidores}
    \optionC{Uma arquitectura de Camadas, em que o acesso s fontes
       a responsabilidade da camada mais abaixo}
    \optionD{Uma arquitectura Publicao-Subscrio, em que as vrias
      fontes publicam eventos com as alteraes efectuadas e o
      \emph{mashup} subscreve esses eventos}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qMashupsINGLES}{
  \begin{ClosedQuestion}
    One of the evolutions in the development of web applications was
    the appearance of \emph{mashups}, which are described in Wikipedia
    as follows:

    \begin{quote}
      In web development, a mashup is a web page or application that
      uses and combines data, presentation or functionality from two
      or more sources to create new services.
    \end{quote}

    Knowing that the sources used by \emph{mashups} do not know about
    the existence of the \emph{mashups} and that they change
    frequently, forcing the adaptation of the \emph{mashups} to
    accomodate those changes, what is the best architecture to
    minimize the effects of those changes?
 
    \optionA{A \emph{web services} architecture}
    \optionB{A Client-Server architecture, where the \emph{mashup}
      is the client and the various sources are the servers}
    \optionC{A layered architecture, where the access to the various
      sources is the responsibility of the bottommost layer}
    \optionD{A Publish-Subscribe architecture, where the various
      sources publish events with the changes made and the
      \emph{mashup} subscribes those events}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%20
\newcommand{\qSeguranca}{
  \begin{ClosedQuestion}
    Suponha que est a desenhar a arquitectura de software para uma
    aplicao empresarial que tem requisitos de segurana sobre a
    confidencialidade de parte dos seus dados.  Para mostrar aos
    \emph{stakeholders} que o seu sistema satisfaz os requisitos de
    segurana ter de usar que vistas arquitecturais?

    \optionA{Apenas so necessrias vistas do tipo componente-e-conector}
    \optionB{Apenas so necessrias vistas do estilo Instalao}
    \optionC{Podem ser necessrias vistas do tipo componente-e-conector e do estilo Instalao}
    \optionD{So sempre necessrias vistas do tipo componente-e-conector e do estilo Implementao}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qSegurancaINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are designing the software architecture for an
    enterprise application that has security requirements about the
    confidentiality of some of its data.  To show to the stakeholders
    that your system satisfies the security requirements you have to
    use views of which architectural style?

    \optionA{Only views of the component-and-connector viewtype are needed}
    \optionB{Only views of the Deployment style are needed}
    \optionC{We may need views of the component-and-connector viewtype
      and of the Deployment style}
    \optionD{We always need views of the component-and-connector viewtype
      and of the Deployment style}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}



%% =========================================================================
%% exam1 2011/2012
%% =========================================================================

%1
\newcommand{\qHadoopEscalabilidadePossivel}{
  \begin{ClosedQuestion}
    A qualidade de escalabilidade do sistema Hadoop apenas  possvel
    porque?

    \optionA{Os \emph{stakeholders} requerem um sistema onde os
      problemas de desempenho no sejam considerados como os mais
      relevantes}
    \optionB{Os \emph{stakeholders} mais importantes so uma pequena
      equipa de desenvolvimento que tem elevadas competncias
      tcnicas}
    \optionC{Os \emph{stakeholders} aceitam que duas leituras
      simultneas do mesmo ficheiro, efectuadas por aplicaes
      diferentes, possam retornar resultados diferentes}
    \optionD{O sistema foi desenvolvido usando complexos algoritmos
      distribudos que garantem a escalabilidade}

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%1
\newcommand{\qHadoopEscalabilidadePossivelINGLES}{
  \begin{ClosedQuestion}
    The scalability quality is achieved in the Hadoop system only because

    \optionA{Stakeholders requirements do not emphasize performance as the most important issue}

    \optionB{The Hadoop small development team is highly competent and skilled}

    \optionC{Stakeholders do not mind if two simultaneous reads on the same file by two different applications may return different values}

    \optionD{The Hadoop system implementation uses complex distributed algorithms for scalability}

     \putOptions
% Resposta: C
   \end{ClosedQuestion}
}

%2
\newcommand{\qHadoopDisponibilidadeDesempenho}{
  \begin{ClosedQuestion}
    No sistema Hadoop:

     \optionA{As qualidades de disponibilidade e de desempenho so
       conflituosas}
     \optionB{A qualidade de disponibilidade  a mais relevante, pelo
       que o desempenho  tratado a posteriori e em funo das
       tcticas escolhidas para a disponibilidade}
     \optionC{As qualidades de disponibilidade e de desempenho no so
       conflituosas}
     \optionD{ ao nvel da instalao que se garantem as qualidades
       de disponibilidade e desempenho}

     \putOptions
% Resposta: B
 \end{ClosedQuestion}
}


%2
\newcommand{\qHadoopDisponibilidadeDesempenhoINGLES}{
  \begin{ClosedQuestion}
    In the Hadoop system:

     \optionA{There is a conflict between availability and performance qualities}
     \optionB{The availability quality is more important, thus performance is addressed afterwards and depends on the tactics used for availability}
     \optionC{There is no conflict between availability and performance qualities}
     \optionD{Availability and performance qualities are ensured at deployment time only}

     \putOptions
% Resposta: B
 \end{ClosedQuestion}
}


%3
\newcommand{\qHadoopTacticasRecuperacaoFaltas}{
  \begin{ClosedQuestion}
    No sistema Hadoop as tcticas de recuperao de faltas usadas so:

    \optionA{Replicao activa e replicao passiva}
    \optionB{Replicao activa, replicao passiva e \emph{spare}}
    \optionC{Replicao passiva e \emph{spare}}
    \optionD{Quorum, replicao activa e replicao passiva}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}


%3
\newcommand{\qHadoopTacticasRecuperacaoFaltasINGLES}{
  \begin{ClosedQuestion}
    In the Hadoop system the fault recovery tactics are:

    \optionA{Active replication and passive replication}
    \optionB{Active replication, passive replication, and spare}
    \optionC{Passive replication and spare}
    \optionD{Quorum, active replication, and passive replication}
    \putOptions
% Resposta: C
  \end{ClosedQuestion}
}



%4
\newcommand{\qHadoopTacticasRecuperacaoFaltasDois}{
  \begin{ClosedQuestion}
    No sistema Hadoop quando um \emph{DataNode} que falhou 
    reintroduzido so usadas as seguintes tcticas:

    \optionA{\emph{Shadow operation}}
    \optionB{Resincronizao de estado}
    \optionC{\emph{Checkpoint/Rollback}}
    \optionD{Todas as anteriores}
    \putOptions
  \end{ClosedQuestion}
}

%4
\newcommand{\qHadoopTacticasRecuperacaoFaltasDoisINGLES}{
  \begin{ClosedQuestion}
    In the Hadoop system the tactics used to reintroduce a DataNode after its failure are:

    \optionA{Shadow operation}
    \optionB{State Resynchronization}
    \optionC{Checkpoint/Rollback}
    \optionD{All of the above}
    \putOptions
  \end{ClosedQuestion}
}

%5
\newcommand{\qHadoopTacticasSeguranca}{
  \begin{ClosedQuestion}
    No sistema Hadoop instalado no Yahoo! as tcticas de segurana
    utilizadas so:

    \optionA{Autenticar utilizadores e autorizar utilizadores}
    \optionB{Autenticar utilizadores, autorizar utilizadores e limitar exposio}
    \optionC{Autenticar utilizadores, autorizar utilizadores e limitar o acesso}
    \optionD{Autenticar utilizadores, autorizar utilizadores, limitar o acesso e manter integridade}
    \putOptions
  \end{ClosedQuestion}
}

%5
\newcommand{\qHadoopTacticasSegurancaINGLES}{
  \begin{ClosedQuestion}
    The security tactics used in The Hadoop system deployed at Yahoo! are:

    \optionA{Authenticate users and authorize users}
    \optionB{Authenticate users, authorize users, and limit exposure}
    \optionC{Authenticate users, authorize users, and limit access}
    \optionD{Authenticate users, authorize users, limit access, and maintain integrity}
    \putOptions
  \end{ClosedQuestion}
}


%6
\newcommand{\qHadoopHeartbeat}{
  \begin{ClosedQuestion}
    Durante a operao normal os \emph{DataNodes} usam a tctica de
    \emph{heartbeat}

    \optionA{Porque esta tctica  aquela que no sobrecarrega o \emph{NameNode}}
    \optionB{Mas tambm poderiam usar a tctica de \emph{ping} pois o
      \emph{overhead} desta tctica no \emph{NameNode} seria idntico}
    \optionC{Mas tambm poderiam usar a tctica de excepes}
    \optionD{Para informarem os restantes \emph{DataNodes} que esto disponveis}
    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}

%6
\newcommand{\qHadoopHeartbeatINGLES}{
  \begin{ClosedQuestion}
    During normal operation DataNodes use the heartbeat tactic

    \optionA{Because this tactic does not overload the NameNode}
    \optionB{But they could have used the ping tactic instead, because it has the same overhead for the NameNode}
    \optionC{But the exceptions tactic could have been used as well}
    \optionD{To inform other DataNodes about their availability}
    \putOptions
% Resposta: A
 \end{ClosedQuestion}
}


%7
\newcommand{\qModulosCamadas}{
  \begin{ClosedQuestion}
    Uma camada, do estilo arquitectural camadas,  um mdulo:

    \optionA{Pois possui uma interface bem definida}
    \optionB{Que agrega mdulos de acordo com relaes de utilizao}
    \optionC{Pois possui uma interface bem definida e esconde um comportamento interno}
    \optionD{Que fornece um conjunto de servios completo e coeso}
    \putOptions
    % Resposta: D
  \end{ClosedQuestion}
}

%7
\newcommand{\qModulosCamadasINGLES}{
  \begin{ClosedQuestion}
    A layer, in the layers architectural style, is a module:

    \optionA{Because it has a well-defined interface}
    \optionB{That aggregates modules according to the uses relationship}
    \optionC{Because it has a well-defined interface and hides the internal behaviour}
    \optionD{That provides a set of complete and cohesive services}
    \putOptions
    % Resposta: D
  \end{ClosedQuestion}
}



%8
\newcommand{\qUtilizacaoImpactoAlteracoes}{
  \begin{ClosedQuestion}
    O estilo arquitectural Utilizao permite aferir do impacto de
    alteraes aos mdulos

    \optionA{Pois  uma extenso natural dos casos de uso}
    \optionB{Mas necessita de informao sobre a estrutura interna dos mdulos}
    \optionC{Mas necessita de ser complementado, para cada relao de
      utiliza, com informao sobre o nvel de ligao associado}
    \optionD{E fornece toda a informao suficiente para medir o impacto}
    \putOptions
% Resposta: C  (tambm no  nada simples...)
  \end{ClosedQuestion}
}

%8
\newcommand{\qUtilizacaoImpactoAlteracoesINGLES}{
  \begin{ClosedQuestion}
    The uses architectural style allows to assess the impact of changes in modules

    \optionA{Because it is a natural extension of the use cases concept}
    \optionB{But it requires additional information on the modules internal structure}
    \optionC{But it needs to be complemented, for each uses relationship, with the level of coupling}
    \optionD{And contains all the information required to assess effectively the impact}
    \putOptions
% Resposta: C  (tambm no  nada simples...)
  \end{ClosedQuestion}
}


%9
\newcommand{\qUtilizacaoNotifica}{
  \begin{ClosedQuestion}
    No estilo arquitectural Utilizao diz-se que uma invocao entre
    dois mdulos no implica uma relao de utilizao pois:

    \optionA{O sucesso da invocao pode no ter impacto no correcto funcionamento do mdulo invocador}
    \optionB{O sucesso da invocao pode no ter impacto no correcto funcionamento do mdulo invocado}
    \optionC{A invocao pode no passar dados entre os mdulos}
    \optionD{A relao de utilizao requer que as invocaes devolvam o controlo ao mdulo invocador}
    \putOptions
% Resposta: A
  \end{ClosedQuestion}
}


%9
\newcommand{\qUtilizacaoNotificaINGLES}{
  \begin{ClosedQuestion}
    In the uses architectural style a call does not necessarily
    correspond to a uses relationship because:
	
    \optionA{The call's results may not have impact on the correct execution of the caller module}
    \optionB{The call's results may not have impact on the correct execution of the callee module}
    \optionC{The call may not transfer data between the modules}
    \optionD{The uses relationship requires calls to return control to the caller module}
    \putOptions
% Resposta: A
  \end{ClosedQuestion}
}


%10
\newcommand{\qUtilizacaoNotificaDois}{
  \begin{ClosedQuestion}
    De acordo com as tcnicas de desenho orientadas aos atributos, uma
    arquitectura de software deve ser desenhada com base numa lista de
    requisitos, chamados de \emph{architectural drivers}. Estes
    \emph{architectural drivers} devem ser ordenados de acordo com a
    sua importncia para os \emph{stakeholders} pois
	
    \optionA{Devemos satisfazer primeiro os requisitos dos
      \emph{stakeholders} mais importantes, como por exemplo o
      cliente}
    \optionB{Se eles no fossem ordenados no saberamos onde comear
      o processo de desenho}
    \optionC{Se um dos \emph{stakeholders} se queixar que o seu
      requisito no foi satisfeito, podemos explicar-lhe que h
      outros mais importantes}
    \optionD{Quando no  possvel satisfazer todos os requisitos de
      forma ptima,  importante conhecer a sua importncia relativa
      para que se procure uma soluo que corresponda a um
      compromisso satisfatrio} 
    \putOptions
    % Resposta: D
  \end{ClosedQuestion}
}


%10
\newcommand{\qUtilizacaoNotificaDoisINGLES}{
  \begin{ClosedQuestion}
    According to the attribute-driven design process, we should design
    the software architecture for a system based on a selected list of
    requirements, which are called the \textit{architectural drivers}.
    These architectural drivers should be sorted according to their
    importance for the system's stakeholders because
	
    \optionA{We should always satisfy in the first place the requirements
      of more important stakeholders (such as the client)}
    \optionB{If no order was established among them, we would not know
      from where should we start the design process}
    \optionC{If one of the stakeholders complains that his requirement
      is not satisfied, we may explain to him that there were other more
      important requirements first}
    \optionD{When it is not possible to satisfy all of the requirements
      optimally, we should be aware of their relative importance so that
      we may find a solution that corresponds to a satisfactory trade-off}
    \putOptions

% Resposta: D
 \end{ClosedQuestion}
}



%11
\newcommand{\qHadoopInteraccaoDataNodes}{
  \begin{ClosedQuestion}
    No sistema HDFS o componente \emph{DataNode} tem como principal
    responsabilidade guardar os blocos de dados correspondentes aos
    ficheiros dos clientes, existindo tipicamente vrias instncias
    deste componente num sistema.  O estilo arquitectural que melhor
    descreve o padro de interaco existente entre as vrias
    instncias de \emph{DataNode} 
    
    \optionA{O estilo Dados Partilhados (\emph{Shared data})}
    \optionB{O estilo Canais-e-filtros (\emph{Pipes-and-filters})}
    \optionC{O estilo Par-a-Par (\emph{Peer-to-Peer})}
    \optionD{O estilo Cliente-Servidor (\emph{Client-Server})}
  \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


\newcommand{\qHadoopInteraccaoDataNodesINGLES}{
  \begin{ClosedQuestion}
    In the HDFS system, the main responsibility of the DataNode
    component is to store the data blocks corresponding to the
    client's files, and usually there are several instances of this
    component on each system.  The architectural style that best
    describes the interaction pattern among the various instances of
    DataNode is
    
    \optionA{The Shared data style}
    \optionB{The Pipes-and-filters style}
    \optionC{The Peer-to-Peer style}
    \optionD{The Client-Server style}
  \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%12
\newcommand{\qHadoopInteraccaoNameNodeDataNodes}{
  \begin{ClosedQuestion}
    Conforme descrito na seco 8.2.3., o componente \emph{NameNode}
    d comandos aos \emph{DataNodes} para que eles procedam a algumas
    operaes sobre os seus blocos, ao passo que os \emph{DataNodes}
    tm que enviar relatrios regulares para o \emph{NameNode}.  A
    arquitectura que melhor descreve a forma como no sistema HDFS
    estes dois tipos de componentes interagem  como

    \optionA{Uma arquitectura Cliente-Servidor, em que o
      \emph{DataNode}  o Cliente e o \emph{NameNode}  o Servidor}
    \optionB{Uma arquitectura Cliente-Servidor, em que o
      \emph{NameNode}  o Cliente e o \emph{DataNode}  o Servidor}
    \optionC{Uma arquitectura Par-a-Par}
    \optionD{Uma arquitectura Processos Comunicantes}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}

\newcommand{\qHadoopInteraccaoNameNodeDataNodesINGLES}{
  \begin{ClosedQuestion}
    According to Section 8.2.3, the NameNode component issues commands
    to the DataNodes so that they execute some operations on their
    blocks, whereas DataNodes have to send reports regularly to the
    NameNode.  The architecture that best describes how these two
    types of components interact in the HDFS system is

    \optionA{A Client-Server architecture, where the DataNode is the
      Client and the NameNode is the Server}
    \optionB{A Client-Server architecture, where the NameNode is the
      Client and the DataNode is the Server}
    \optionC{A Peer-to-Peer architecture}
    \optionD{A Communicating Processes architecture}
    \putOptions

% Resposta: A
  \end{ClosedQuestion}
}


%13
\newcommand{\qHadoopNameNodeComoConector}{
  \begin{ClosedQuestion}
    Suponha que pretende descrever como  que um cliente l um
    ficheiro de um sistema HDFS suportando falhas espordicas no
    hardware de alguns \emph{DataNodes}, sem que isso afecte a
    disponibilidade do sistema.  Para isso pretende usar uma vista do
    tipo componente-e-conector, mas em que os nicos componentes so o
    \emph{HDFS Client} e o \emph{DataNode}.

    \optionA{Essa vista estar sempre incompleta sem o
      \emph{NameNode}, visto que o \emph{HDFS Client} precisa de
      interagir com ele} 
    \optionB{Essa vista estar sempre incompleta sem o
      \emph{NameNode}, visto que o \emph{DataNode} precisa de
      interagir com ele} 
    \optionC{A vista no precisa de incluir o \emph{NameNode}, mas
      nesse caso no ser possvel raciocinar sobre a disponibilidade
      do sistema}
    \optionD{A garantia de disponibilidade pode ser dada pela
      utilizao de um conector adequado entre o \emph{HDFS Client} e os
      \emph{DataNodes}} 
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


\newcommand{\qHadoopNameNodeComoConectorINGLES}{
  \begin{ClosedQuestion}
    Imagine that you intend to describe how a client reads a file from
    an HDFS system while supporting sporadic failures in the hardware
    of some DataNodes, but without affecting the availability of the
    system.  To accomplish that, you want to use a
    component-and-connector view containing only two types of
    components: the HDFS Client, and the DataNode.

    \optionA{That view will always be incomplete without the NameNode,
      because the HDFS Client needs to interact with it} 
    \optionB{That view will always be incomplete without the NameNode,
      because the DataNode needs to interact with it} 
    \optionC{The view does not need to include the NameNode, but in
      that case it will not be possible to reason about the
      availability of the system}
    \optionD{The availability guarantee may be given by the usage of
      an adequate connector between the HDFS Client and the DataNodes} 
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}


%14
\newcommand{\qHadoopNameNodeThreads}{
  \begin{ClosedQuestion}
    No ltimo pargrafo da seco 8.2.2 descreve-se qual foi a soluo
    adoptada pelo \emph{NameNode} para obter um determinado nvel de
    desempenho na escrita para disco.  Que estilo arquitectural  mais
    adequado para representar a soluo adoptada?

    \optionA{O estilo Dados Partilhados}
    \optionB{O estilo Processos Comunicantes}
    \optionC{O estilo Instalao (\emph{Deployment})}
    \optionD{O estilo Par-a-Par}
   \putOptions

% Resposta: B
  \end{ClosedQuestion}
}


\newcommand{\qHadoopNameNodeThreadsINGLES}{
  \begin{ClosedQuestion}
    The last paragraph of Section 8.2.2 describes the solution used by
    the NameNode to obtain a certain level of performance while
    writing to disk.  Which architectural style is more adequate to
    represent the solution used?

    \optionA{The Shared Data style}
    \optionB{The Communicating Processes style}
    \optionC{The Deployment style}
    \optionD{The Peer-to-Peer style}
   \putOptions

% Resposta: B
  \end{ClosedQuestion}
}


%15
\newcommand{\qHadoopReplicarNameNode}{
  \begin{ClosedQuestion}
    A arquitectura do sistema HDFS apenas prev a existncia de um
    \emph{NameNode}.  Tendo em conta as responsabilidades deste
    componente e a actual arquitectura do HDFS, quais seriam as
    consequncias de adicionarmos a possibilidade de termos rplicas
    de \emph{NameNode} no sistema?

    \optionA{O sistema passava a responder em menos tempo a todos os
      pedidos dos clientes}
    \optionB{O desempenho do sistema no seria alterado}
    \optionC{O sistema passava a poder responder em menos tempo a
      pedidos de localizaes de ficheiros}
    \optionD{O sistema passava a poder responder em menos tempo aos
      pedidos de actualizao dos metadados feitos pelos \emph{DataNodes}}
    \putOptions

% Resposta: C   
 \end{ClosedQuestion}
}

\newcommand{\qHadoopReplicarNameNodeINGLES}{
  \begin{ClosedQuestion}
    The architecture of the HDFS system only allows the existence of
    one NameNode.  Given the responsibilities of this component and
    the current architecture of HDFS, what would be the consequences
    of adding the possibility of having replicas of the NameNode in
    the system?

    \optionA{The system would respond faster to all the
      clients' requests}
    \optionB{The performance of the system would not change}
    \optionC{The system would respond faster to requests about
      file locations}
    \optionD{The system would respond faster to requests made by
      DataNodes to update the metadata}
    \putOptions

% Resposta: C   
 \end{ClosedQuestion}
}


%16
\newcommand{\qServiceLayer}{
  \begin{ClosedQuestion}
    Quando se utiliza o padro Domain Model na implementao da camada
    de lgica de domnio de uma aplicao empresarial,  comum
    utilizar-se tambm o padro Service Layer.  O padro Service Layer
     usado nestes casos para
    
    \optionA{Controlar e reduzir a interface exposta pela camada de
      lgica de domnio, aumentando assim a modificabilidade dessa
      camada}
    \optionB{Permitir a existncia de mais do que uma interface para a
      camada de lgica de domnio (para providenciar, por exemplo, uma
      interface de \emph{web services})}
    \optionC{Permitir a existncia de diferentes camadas de lgica de apresentao}
    \optionD{Facilitar a utilizao da camada de acesso a dados por
      parte da camada de lgica de apresentao}
    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}


\newcommand{\qServiceLayerINGLES}{
  \begin{ClosedQuestion}
    When someone uses the Domain Model pattern to implement the domain
    logic layer of an enterprise application, it is common to use also
    the Service Layer pattern. The Service Layer pattern is used in
    these cases
   
    \optionA{To control and to reduce the interface exposed by the
      domain logic layer, thereby increasing the modifiability of that
      layer}
    \optionB{To allow the existence of more than one interface to the
      domain logic layer (to provide, for example, an interface to web
      services)}
    \optionC{To allow the existence of different presentation logic layers} 
    \optionD{To facilitate the use of the data access layer by the
      presentation logic layer}

    \putOptions

% Resposta: A
 \end{ClosedQuestion}
}



%17
\newcommand{\qSharedDataAccessorsDirect}{
  \begin{ClosedQuestion}
    Suponha que est a desenvolver uma vista arquitectural onde
    utiliza o estilo de Dados Partilhados (\emph{Shared Data}) e que
    um dos membros da sua equipa prope que dois dos componentes com o
    papel de \emph{data accessors} comuniquem directamente entre si.
    Na sua opinio

    \optionA{Isso no deve ser permitido porque todas as interaces
      entre componentes devem ser feitas atravs do \emph{Repositrio}} 
    \optionB{ uma soluo aceitvel se pretendermos reduzir as
      dependncias entre os vrios componentes do sistema}
    \optionC{Essa  a soluo recomendada se existir um fluxo de
      controlo que envolva a coreografia dos dois componentes}
    \optionD{Essa interaco no pode ser representada nesta vista,
      mas sim numa outra vista da arquitectura do sistema}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}

\newcommand{\qSharedDataAccessorsDirectINGLES}{
  \begin{ClosedQuestion}
    Imagine that you are developing an architectural view where you
    are using the Shared Data style and that a member of your team
    proposes that two of Data Accessors communicate directly between
    them.  In your opinion

    \optionA{That should not be allowed because all interactions among
      components must be made through the Repository} 
    \optionB{That is an acceptable solution if we want to reduce the
      dependencies among the various components of the system}
    \optionC{That is the recommended solution if there is a control
      flow that involves the choreography of both components}
    \optionD{That interaction cannot be represented in this view, but
      it may in another view of the system's architecture}
    \putOptions

% Resposta: C
 \end{ClosedQuestion}
}


%18
\newcommand{\qWhiteBoxTesting}{
  \begin{ClosedQuestion}
    Considere o seguinte excerto da pgina da Wikipedia sobre testes
    de caixa branca (\emph{white-box testing}):
    \begin{quote}
      White-box testing is a method of testing software that tests
      internal structures or workings of an application, as opposed to
      its functionality. In white-box testing an internal perspective
      of the system (including the module's code), as well as
      programming skills, are required and used to design test
      cases. The tester chooses inputs to exercise paths through the
      code and determine the appropriate outputs.
    \end{quote}
  
    Supondo que pertence  equipa de testes de um sistema complexo e
    que  responsvel por efectuar testes de caixa branca sobre o
    sistema, quais das seguintes vistas da arquitectura de software do
    sistema lhe seriam mais teis?

    \optionA{Vistas de Atribuio de Trabalho (\emph{Work Assignment})}
    \optionB{Vistas de Generalizao (\emph{Generalization})}
    \optionC{Vistas de Instalao (\emph{Deployment})}
    \optionD{Vistas de Implementao (\emph{Implementation})}
    \putOptions

% Resposta: D (creio que falmos o ano passado sobre esta def pois white-box testing de um mdulo  feito conhecendo o seu cdigo interno, acima  vago a diferena entre internal perspective of the system vs internal perspective of the module)
% NOTA: Ver esta com o Rito
  \end{ClosedQuestion}
}

\newcommand{\qWhiteBoxTestingINGLES}{
  \begin{ClosedQuestion}
    Consider the following excerpt from the Wikipedia page on
    \emph{white-box testing}:
    \begin{quote}
      White-box testing is a method of testing software that tests
      internal structures or workings of an application, as opposed to
      its functionality. In white-box testing an internal perspective
      of the system (including the module's code), as well as
      programming skills, are required and used to design test
      cases. The tester chooses inputs to exercise paths through the
      code and determine the appropriate outputs.
    \end{quote}
  
    Assuming that you belong to the team testing a complex system and
    that you are responsible for performing white box tests on the
    system, which of the following architectural views of the system
    would be most useful to you?

    \optionA{Work Assignment views}
    \optionB{Generalization views}
    \optionC{Deployment views}
    \optionD{Implementation views}
    \putOptions

% Resposta: D (creio que falmos o ano passado sobre esta def pois white-box testing de um mdulo  feito conhecendo o seu cdigo interno, acima  vago a diferena entre internal perspective of the system vs internal perspective of the module)
% NOTA: Ver esta com o Rito
  \end{ClosedQuestion}
}

%19
\newcommand{\qTresTiers}{
  \begin{ClosedQuestion}
    Actualmente, a arquitectura mais popular para uma aplicao
    empresarial  constituda por 3 \emph{tiers}.  Esses trs
    \emph{tiers} so

    \optionA{As camadas de lgica de apresentao, lgica de domnio,
      e acesso a dados}
    \optionB{As aplicaes web tradicionais, os \emph{mashups}, e as
      \emph{rich internet applications} (RIAs)}
    \optionC{O \emph{browser} web, o servidor web, e a base de dados}
    \optionD{As camadas de \emph{web services}, lgica de domnio, e
      acesso a dados}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}

\newcommand{\qTresTiersINGLES}{
  \begin{ClosedQuestion}
    Currently, the most popular architecture for an enterprise
    application is composed of 3 tiers.  The three tiers are

    \optionA{The presentation logic layer, domain logic layer, and
      data access layer}
    \optionB{The traditional web applications, the mashups, and the rich internet applications (RIAs)}
    \optionC{The web browser, o web server, and the data base}
    \optionD{The web services layer, the domain logic layer, and the
      data access layer}
    \putOptions

% Resposta: C
  \end{ClosedQuestion}
}


%20
\newcommand{\qTempoRespostaAplicacaoEmpresarial}{
  \begin{ClosedQuestion}
    Suponha que est a desenhar a arquitectura de software para uma
    aplicao empresarial que tem requisitos sobre o tempo mximo que
    o sistema deve demorar a responder a um determinado tipo de
    pedidos por parte dos utilizadores.  Suponha ainda que a
    frequncia desses pedidos  previsvel, mas que os restantes
    pedidos ao sistema podem variar significativamente.  Finalmente,
    suponha que o seu sistema vai ter apenas um nico servidor que se
    executar numa mquina pr-definida com um processador AMD de 12
    cores.  Para mostrar aos \emph{stakeholders} que o seu sistema
    satisfaz os requisitos de desempenho ter que usar vistas de que
    estilo arquitectural?

    \optionA{Do estilo Atribuio de Trabalho}
    \optionB{Do estilo Cliente-Servidor}
    \optionC{Do estilo Instalao}
    \optionD{Do estilo Processos Comunicantes}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

\newcommand{\qTempoRespostaAplicacaoEmpresarialINGLES}{
  \begin{ClosedQuestion}
    Suppose that you are designing the software architecture for an
    enterprise application that has requirements about the maximum
    response time for a certain type of requests.  Moreover, assume
    that those requests arrive at the system periodically, whereas the
    remaining requests have an unpredictable frequency.  Finally,
    assume that your system will have a single server that will be
    executing on a predefined machine with a 12-core AMD processor.
    To show to the stakeholders that your system satisfies the
    performance requirements you have to use views of which
    architectural style?

    \optionA{The Work Assignment style}
    \optionB{The Client-Server style}
    \optionC{The Deployment style}
    \optionD{The Communicating Processes style}
    \putOptions

% Resposta: D
  \end{ClosedQuestion}
}

%% =========================================================================
%% exam2 2010/2011
%% =========================================================================

%1
\newcommand{\qPorqueSepararComponentes}{
\begin{ClosedQuestion}
  Suponha que ao conceber a arquitectura de software de um sistema, um
  arquitecto decidiu particionar o sistema em trs componentes, cada
  um dos quais com um conjunto de funcionalidades diferentes.  Qual
  das seguintes razes lhe parece mais adequada para justificar esta
  deciso?


    \optionA{Porque assim se pode fazer o desenvolvimento do sistema de
      forma incremental, em trs etapas claramente separadas}
    \optionB{Porque assim  mais fcil modificar cada uma das trs
      funcionalidades sem afectar as outras funcionalidades do sistema}
    \optionC{Porque existem requisitos de desempenho diferentes para
    cada um dos trs tipos de funcionalidades, e esta soluo permite
    controlar melhor o desempenho de cada um}
    \optionD{Porque esta soluo permite o desenvolvimento do sistema
    em paralelo por trs equipas diferentes, que apenas precisam de
    acordar entre si qual a interface de cada um dos componentes}
 \putOptions
\end{ClosedQuestion}
}


%2
\newcommand{\qArqChrome}{
\begin{ClosedQuestion}
  O Chromium  um navegador da web (\emph{web browser}), que
  introduziu uma arquitectura inovadora na forma como lida com a
  navegao simultnea de vrias pginas, cada uma das quais numa
  \emph{tab} diferente do navegador.  No documento que descreve a
  arquitectura do Chromium, podemos ler o seguinte:

  \begin{quote}
    We use separate processes for browser tabs to protect the overall
    application from bugs and glitches in the rendering engine.  We
    also restrict access from each rendering engine process to others
    and to the rest of the system.  In some ways, this brings to web
    browsing the benefits that memory protection and access control
    brought to operating systems.

    We refer to the main process that runs the UI and manages tab and
    plugin processes as the "browser process" or "browser."  Likewise,
    the tab-specific processes are called "render processes" or
    "renderers."  The renderers use the WebKit open-source layout
    engine for interpreting and laying out HTML.
  \end{quote}

  Tendo em conta esta breve descrio da arquitectura de software do
  Chromium, que estilo arquitectural lhe parece mais adequado para a
  representar?


    \optionA{O estilo Processos Comunicantes (\emph{Communicating Processes})}
    \optionB{O estilo Cliente-Servidor (\emph{Client-Server})}
    \optionC{O estilo Par-a-Par (\emph{Peer-to-Peer})}
    \optionD{O estilo Utilizao (\emph{Uses})}
  \putOptions
\end{ClosedQuestion}
}


%3
\newcommand{\qChromeMultiPlatform}{
\begin{ClosedQuestion}
  Considerando ainda o exemplo do Chromium, encontra-se na pgina do
  projecto um outro documento intitulado ``Conventions and patterns
  for multi-platform development,'' onde se pode ler o seguinte:

  \begin{quote}
    Chromium is a large and complex cross-platform product.  We try to
    share as much code as possible between platforms, while
    implementing the UI and OS integration in the most appropriate way
    for each.  While this gives a better user experience, it adds
    extra complexity to the code.  This document describes the
    recommended practices for keeping such cross-platform code clean.

    We use a variety of different file naming suffixes to indicate
    when a file should be used:
    \begin{itemize}
    \item Windows files use the \texttt{\_win} suffix.
    \item Cocoa (Mac UI) files use the \texttt{\_cocoa} suffix, and lower-level Mac files use the \texttt{\_mac} suffix.
    \item Linux files use \texttt{\_linux} for lower-level files, \texttt{\_gtk} for GTK-specific files, and \texttt{\_x} for X Windows (with no GTK) specific files.
    \item Posix files shared between Mac and Linux use the \texttt{\_posix} suffix.
    \item Files for Chrome's ``Views'' UI (on Windows and experimental GTK) layout system use the \texttt{\_views} suffix.
   \end{itemize}

    The separate front-ends of the browser are contained in their own directories:
    \begin{itemize}
    \item Windows Views (and the experimental GTK-views): \\
      \texttt{chrome/browser/ui/views}
    \item Linux GTK: \texttt{chrome/browser/gtk}
    \item Mac: \texttt{chrome/browser/cocoa}
    \end{itemize}
  \end{quote}
  
  Novamente, tendo em conta esta breve descrio, que estilo
  arquitectural lhe parece mais adequado para a representar?


    \optionA{O estilo Implementao (\emph{Implementation})}
    \optionB{O estilo Atribuio de Trabalho (\emph{Work assignment})}
    \optionC{O estilo Decomposio (\emph{Decomposition})}
    \optionD{Nenhum, visto que esta descrio no tem nada a ver com a
    arquitectura do sistema}
  \putOptions
\end{ClosedQuestion}
}


%4
\newcommand{\qWebkit}{
\begin{ClosedQuestion}
  Na descrio da arquitectura do Chromium  dito que os
  \emph{renderers} usam o WebKit, que  descrito na Wikipedia da
  seguinte forma:

  \begin{quote}
    WebKit is a layout engine designed to allow web browsers to render
    web pages.  WebKit powers Google Chrome and Apple's Safari, the
    third and fourth most widely used web browsers respectively.  The
    WebKit engine provides a set of classes to display web content in
    windows, and implements browser features such as following links
    when clicked by the user, managing a back-forward list, and
    managing a history of pages recently visited.  
  
    WebKit was originally created as a fork of KHTML as the layout
    engine for Apple's Safari; it is portable to many other computing
    platforms.  Mac OS X and Windows are supported by the project.

    WebKit's WebCore and JavaScriptCore components are available under
    the GNU Lesser General Public License, and the rest of WebKit is
    available under a BSD-style license.
  \end{quote}
  
  Suponha que vai desenvolver um novo \emph{browser} e que decidiu
  usar o WebKit para suportar o \emph{rendering} das pginas de HTML,
   semelhana do que  feito no Chromium e no Safari.  Qual das
  seguintes vistas arquitecturais  mais adequada para representar
  esta deciso?


    \optionA{A vista de Decomposio (\emph{Decomposition})}
    \optionB{As vistas do tipo Componente-e-Conector }
    \optionC{A vista de Atribuio de Trabalho (\emph{Work Assignment})}
    \optionD{A vista de Utilizao (\emph{Uses})}
  \putOptions
\end{ClosedQuestion}
}


%5
\newcommand{\qArqEmailMUA}{
\begin{ClosedQuestion}
  O sistema de email  composto por vrios tipos de componentes que
  desempenham diferentes funes.  Por exemplo, para enviar um email,
  um utilizador pode utilizar um programa como o Microsoft Outlook ou
  o Mozilla Thunderbird, genericamente designado por \emph{mail user
    agent} (MUA), para compor a sua mensagem e envi-la.  Para enviar
  a mensagem, tipicamente o MUA liga-se a um \emph{mail transfer
    agent} (MTA), que recebe a mensagem, analisa os cabealhos da
  mesma para determinar os vrios destinatrios e, aps consulta do
  sistema DNS para determinar quais os MTA responsveis por cada um
  dos destinatrios, liga-se aos MTAs responsveis pelos endereos de
  destino para entregar a mensagem.  Cada um desses MTAs recebe a
  mensagem e armazena-a localmente ou reenvia-a para outros MTAs at
  que a mensagem chegue ao MTA do destino.  O utilizador destinatrio
  da mensagem ir depois usar o seu MUA para ver as mensagens que lhe
  foram enviadas.

  Tendo em conta esta descrio simplificada do funcionamento do
  sistema de email, qual das seguintes descries lhe parece mais
  adequada para representar a arquitectura de software do sistema de
  email, se apenas estivermos interessados no padro de interaco
  existente entre os MUAs?


    \optionA{O padro de interaco existente entre os MUAs corresponde
    ao estilo arquitectural Par-a-Par (\emph{Peer-to-Peer})}
    \optionB{O padro de interaco existente entre os MUAs corresponde
    ao estilo arquitectural Cliente-Servidor (\emph{Client-Server})}
    \optionC{O padro de interaco existente entre os MUAs corresponde
    ao estilo arquitectural \emph{Blackboard}}
    \optionD{O padro de interaco existente entre os MUAs corresponde
    ao estilo arquitectural Publicao-Subscrio
    (\emph{Publish-subscribe}), sendo que os MTAs e DNS implementam o
    conector }
 \putOptions
\end{ClosedQuestion}
}


%6
\newcommand{\qCamadasParaCloudComputing}{
\begin{ClosedQuestion}
  Suponha que vai desenvolver uma aplicao web que pretende alojar
  numa das vrias plataformas de \emph{Cloud Computing} actualmente
  existentes.  Para isso, analisou as vrias ofertas disponveis, e
  seleccionou um subconjunto de plataformas que providenciam um
  conjunto de servios semelhantes (por exemplo, servios de
  armazenamento de dados, servios de mensagens, etc), mas que o fazem
  usando interfaces diferentes.  Por isso, para desenvolver o seu
  sistema acaba por escolher uma dessas plataformas, mas, para evitar
  ficar preso a essa escolha, coloca como requisito para o seu sistema
  que este seja facilmente portvel para outra plataforma semelhante 
  que escolheu.  Que soluo arquitectural melhor satisfaz este
  requisito?

   
    \optionA{A criao de um mdulo na decomposio do sistema que
    represente a plataforma escolhida, mdulo este que poder ser
    alterado posteriormente quando se trocar de plataforma}
    \optionB{A arquitectura padro para aplicaes empresariais,
    composta pelas trs camadas de ``Lgica de apresentao,''
    ``Lgica de domnio,'' e ``Acesso a dados''}
    \optionC{A criao de um mdulo genrico com os servios comuns a
    todas as plataformas, mdulo este que  depois especializado
    por mdulos especficos para cada plataforma}
    \optionD{Uma arquitectura de camadas em que a camada mais de baixo
    providencia uma interface que  uma abstraco dos servios
    fornecidos pelas vrias plataformas}
 \putOptions
\end{ClosedQuestion}
}


%7
\newcommand{\qVistasParaReplicacao}{
\begin{ClosedQuestion}
  A replicao  uma das tcticas mais usadas para satisfazer
  requisitos de disponibilidade como, por exemplo, o requisito de que
  uma aplicao web deve continuar a funcionar normalmente, mesmo
  quando existe uma falta ao nvel do seu servidor web.  A utilizao
  da tctica de replicao do servidor web reflecte-se em que vistas
  da arquitectura de software?

  
    \optionA{Em ambas as vistas componente-e-conector e Instalao
    (\emph{Deployment}), visto que cada uma delas aborda um aspecto
    diferente da concretizao da tctica de replicao}
    \optionB{Apenas na vista de componente-e-conector que inclui o
    servidor web}
    \optionC{Apenas na vista de Instalao (\emph{Deployment}), visto
    que a utilizao desta tctica no altera os componentes, mas sim
    onde  que eles executam}
   \optionD{A utilizao dessa tctica no altera nenhuma das vistas
    da arquitectura de uma aplicao web, visto que a arquitectura
    padro para este tipo de aplicaes j suporta, de raiz, a
    replicao do servidor web}
  \putOptions
\end{ClosedQuestion}
}


%8
\newcommand{\qVistasNecessarias}{
\begin{ClosedQuestion}
  De acordo com o modelo do SEI, existem apenas trs tipos diferentes
  de vistas arquitecturais que so suficientes para descrever qualquer
  arquitectura de software.  Isto significa que, para se descrever a
  arquitectura de software de um sistema, qualquer que ele seja

  
    \optionA{ necessrio ter exactamente uma vista de cada um destes
    trs tipos de vistas}
    \optionB{Apenas se usa uma vista de um destes trs tipos, embora
    outros sistemas possam usar vistas de tipos diferentes}
    \optionC{ necessrio ter pelo menos uma vista de cada um destes
    trs tipos de vistas, mas podemos ter mais do que uma vista de
    cada tipo}
    \optionD{Podemos ter zero ou mais vistas de qualquer um dos trs
    tipos de vista}
 \putOptions
\end{ClosedQuestion}
}



%9
\newcommand{\qImportanciaStakeholders}{
\begin{ClosedQuestion}
  No Ciclo de Negcio da Arquitectura uma das principais influncias
  na arquitectura de um sistema de software so os seus
  \emph{stakeholders}, porque

  
    \optionA{O arquitecto tem que descrever a arquitectura do sistema
    de forma a que todos os stakeholders compreendam o funcionamento
    do sistema}
    \optionB{Os stakeholders financiam o desenvolvimento do sistema e,
    portanto, ao estabelecerem o oramento disponvel, influenciam a
    arquitectura do sistema}
    \optionC{Os stakeholders so a fonte dos requisitos funcionais do sistema}
    \optionD{Os stakeholders so a principal fonte dos requisitos
    funcionais e de qualidade do sistema}
  \putOptions
\end{ClosedQuestion}
}


%10
\newcommand{\qGerirEquipaManutencao}{
\begin{ClosedQuestion}
  Aps o desenvolvimento de todas as funcionalidades pedidas para um
  sistema de software e da sua entrada em produo,  normal que a
  maior parte da equipa envolvida no desenvolvimento desse sistema
  seja posta a trabalhar no desenvolvimento de outros sistemas.  No
  entanto,  normal que surjam com alguma frequncia pedidos de
  alterao de funcionalidades do sistema em produo (correspondendo
   sua fase de manuteno evolutiva).
  
  Suponha que foi contratado para fazer a gesto desses pedidos de
  alterao, planeando a sua execuo (que ser feita pelos
  programadores da equipa de desenvolvimento e no por si) tendo em
  conta, entre outros factores, a disponibilidade dos membros da
  equipa de desenvolvimento.  Quais das seguintes vistas
  arquitecturais lhe seriam, em princpio, mais teis para desempenhar
  o seu trabalho?

  
    \optionA{Vistas de Decomposio (\emph{Decomposition}) e de Camadas (\emph{Layers})}
    \optionB{Vistas de Decomposio (\emph{Decomposition}) e de
    Atribuio de Trabalho (\emph{Work assignment})}
    \optionC{Vistas de Decomposio (\emph{Decomposition}) e de Implementao (\emph{Implementation})}
    \optionD{Vistas de Decomposio (\emph{Decomposition}) e de Generalizao (\emph{Generalization})}
  \putOptions
\end{ClosedQuestion}
}


%11
\newcommand{\qAumentarDesempenhoClienteServidor}{
\begin{ClosedQuestion}
  Suponha que desenvolveu uma aplicao web que permite aos seus
  utilizadores jogarem Xadrez uns contra os outros.  A aplicao
  permite que os jogadores se juntem em pares para realizarem um jogo,
  aps o que o jogo decorre entre esses dois jogadores durante algum
  tempo at ao fim do jogo.  Um jogo completo pode demorar desde cerca
  de 1 hora, at vrios dias, dependendo do tempo que cada jogador
  demora a realizar uma jogada.  Este sistema foi concebido como uma
  aplicao web tradicional, e tem estado a funcionar j h alguns
  meses com um nico componente do tipo servidor ao qual se ligam
  todos os clientes web.  No entanto, dada a recente exposio
  meditica do seu jogo, o nmero de utilizadores da sua aplicao
  aumentou substancialmente nos ltimos tempos.  De facto, viu o seu
  sistema passar rapidamente dos habituais 10 pedidos simultneos que
  eram processados com um tempo mdio de resposta inferior a 300 ms,
  para 100 pedidos a serem processados simultaneamente com um tempo
  mdio de resposta de cerca de 5 segundos.  Na realidade, o nmero de
  pedidos simultneos no aumentou mais porque o seu servidor rejeita
  pedidos adicionais assim que atinge os 100 pedidos em processamento.

  Visto que as expectativas  que a utilizao do sistema continue a
  aumentar, podendo mesmo chegar aos 10000 pedidos simultneos, e que
  o sistema s  utilizvel se tiver tempos mdios de resposta abaixo
  dos 2 segundos, que soluo prope para resolver os problemas de
  desempenho do sistema?

  
    \optionA{Manter a arquitectura actual do sistema e optimizar o
    cdigo de modo a alcanar os nveis de desempenho necessrios actualmente}
    \optionB{Utilizar uma tctica de introduo de concorrncia de
    forma a que possam existir mais servidores a processar pedidos}
    \optionC{Utilizar uma tctica de replicao activa de forma a que
    se consiga obter respostas com um tempo mdio de resposta mais baixo}
    \optionD{Substituir a mquina usada pelo servidor por uma mquina
    mais poderosa que satisfaa os novos requisitos de desempenho,
    mantendo apenas um componente servidor em funcionamento}
  \putOptions
\end{ClosedQuestion}
}


%12
\newcommand{\qPluginsEclipse}{
\begin{ClosedQuestion}
  O IDE Eclipse  uma aplicao \emph{open source} escrita em Java, e
   extensvel atravs da utilizao de \emph{plug-ins}.  No documento
  que descreve a arquitectura de plug-ins existente no Eclipse,
  podemos ler o seguinte:

  \begin{quote}
    A plug-in in Eclipse is a component that provides a certain type
    of service within the context of the Eclipse workbench. [...] The
    Eclipse runtime provides an infrastructure to support the
    activation and operation of a set of plug-ins working together to
    provide a seamless environment for development activities. Within
    a running Eclipse instance, a plug-in is embodied in an instance
    of some plug-in runtime class, or plug-in class, for short. 
    
    [...]

    Such a plug-in can then be activated by the Eclipse runtime when
    it is required to perform some function.  Activating a plug-in
    means loading its runtime class and instantiating and initializing
    its instance.

    The main function of a plug-in class is to do special processing
    during plug-in activation and deactivation, e.g., to allocate and
    release resources.
  \end{quote}

  Tendo em conta o modelo e a nomenclatura usados na cadeira para a
  descrio de uma arquitectura de software, que tipo de vistas lhe
  parecem mais adequadas para representar a arquitectura de plug-ins
  do Eclipse descrita acima?

  
    \optionA{Vistas do tipo de vista componente-e-conector}
    \optionB{Vistas do tipo de vista mdulo}
    \optionC{Vistas do tipo de vista afectao (\emph{Allocation})}
    \optionD{Todas as anteriores}
  \putOptions
\end{ClosedQuestion}
}


%13
\newcommand{\qUsesAMais}{
\begin{ClosedQuestion}
  Suponha que no processo de desenho da arquitectura de software de um
  sistema chega  concluso de que existem ciclos na relao de
  utilizao (\emph{uses}) entre os mdulos do sistema, fazendo com
  que quase todos os mdulos do sistema dependam da maior parte dos
  restantes mdulos.  Como  que resolveria este problema?

  
    \optionA{Eliminava algumas das relaes de utilizao para quebrar
    os ciclos}
    \optionB{Voltava ao estilo decomposio (\emph{decomposition}) para
    decompor o sistema de outra forma, de modo a que no surjam ciclos
    no estilo de utilizao}
    \optionC{Substitua algumas das relaes de utilizao por relaes
    de generalizao (\emph{generalization}) de modo a quebrar os
    ciclos}
    \optionD{A existncia de ciclos ou de muitas relaes de utilizao
    no  um problema que precise de ser resolvido}
  \putOptions
\end{ClosedQuestion}
}


%14
\newcommand{\qRelacaoComponentsDeployment}{
\begin{ClosedQuestion}
  Qual  a relao existente entre os elementos de hardware
  correspondentes a unidades de processamento (mquinas) numa vista do
  estilo Instalao (\emph{Deployment}) e os componentes de um
  sistema, considerando que rplicas do mesmo componente contam como
  componentes diferentes?

  
    \optionA{O nmero de elementos de hardware tem que ser igual ao
    nmero de componentes}
    \optionB{O nmero de elementos de hardware tem que ser menor ou
    igual ao nmero de componentes}
    \optionC{O nmero de elementos de hardware tem que ser maior ou
    igual ao nmero de componentes}
    \optionD{No existe qualquer restrio quanto ao nmero de
    elementos de hardware}
  \putOptions
\end{ClosedQuestion}
}

%15
\newcommand{\qMashups}{
\begin{ClosedQuestion}
  Uma das evolues no desenvolvimento de aplicaes web foi a criao
  de \emph{mashups}, que so descritas na Wikipedia da seguinte forma:

  \begin{quote}
    In web development, a mashup is a web page or application that
    uses and combines data, presentation or functionality from two or
    more sources to create new services.
  \end{quote}

  Embora existam vrias formas de implementar e providenciar estes
  mashups, uma abordagem comum  passar para o \emph{browser} a
  responsabilidade de contactar os vrios servios que se pretende
  combinar e de processar as suas respostas, implementando assim o
  \emph{mashup}.

  Que estilo arquitectural melhor descreve o funcionamento deste tipo
  de aplicaes?

  
    \optionA{O estilo Dados partilhados (\emph{Shared data})}
    \optionB{O estilo Repositrio (\emph{Repository})}
    \optionC{O estilo Camadas (\emph{Layers})}
    \optionD{O estilo Cliente-Servidor (\emph{Client-Server})}
  \putOptions
\end{ClosedQuestion}
}



%16
\newcommand{\qDisponibilidadeRetalhix}{
\begin{ClosedQuestion}
  O sistema Retalhix  um sistema que permite fazer a gesto dos
  produtos e das vendas dos hipermercados, incluindo o funcionamento
  das caixas por onde os clientes passam para registar e pagar as suas
  compras.  Considere o seguinte requisito de disponibilidade para o
  Retalhix

  \begin{quote}
    O aspecto mais crtico para o funcionamento de uma loja  a
    correcta operao das caixas, visto que o no funcionamento das
    caixas afecta directamente os clientes e a sua possibilidade de
    comprar produtos.
  \end{quote}

 Supondo que o que se pretende  que, em caso de falta (qualquer que
  ela seja) de uma s caixa, o cliente que estava a ser atendido nessa
  caixa possa  mesma pagar as suas compras e sair da loja com elas,
  como  que a arquitectura do sistema pode dar resposta a este
  requisito?

  
    \optionA{Criando mecanismos que permitam, em primeiro lugar,
    detectar falhas numa caixa e, uma vez detectada uma falha, reparar a
    falha rapidamente para que a caixa volte a operar normalmente}
    \optionB{Prevendo nas vistas de componente-e-conector e na de
    instalao (\emph{deployment}) a execuo de pelo menos um
    componente redundante em cada caixa, para evitar que existam
    falhas nas caixas}
    \optionC{Mostrando na vista de instalao (\emph{deployment}) que
    num hipermercado existem vrias caixas em funcionamento em cada
    instante, pelo que j existe redundncia ao nvel do hardware para
    satisfazer este requisito}
    \optionD{Replicando os servidores que so contactados pelas caixas,
    e colocando um \emph{load balancer} entre as caixas e os
    servidores}
  \putOptions
\end{ClosedQuestion}
}

%17
\newcommand{\qDisponibilidadeRetalhixMeioDasCompras}{
\begin{ClosedQuestion}
  Considerando ainda o sistema Retalhix da pergunta anterior, imagine
  a situao em que um cliente tem dois carrinhos de supermercado
  cheios de compras e vai a meio do registo das suas compras na caixa
  quando esta falha.  Suponha que o que se pretende neste cenrio 
  que se possa continuar a registar os produtos do cliente sem ter que
  voltar a registar os produtos j registados.  Que consequncias 
  que este novo requisito tem na arquitectura do sistema?

  
    \optionA{No tem nenhuma}
    \optionB{Reflecte-se apenas ao nvel da vista de instalao
    (\emph{deployment})}
    \optionC{Reflecte-se apenas ao nvel das vistas do tipo de vista mdulo}
    \optionD{Pode reflectir-se no s ao nvel das funcionalidades do
    sistema, como ainda ao nvel das vistas componente-e-conector e instalao
    (\emph{deployment})}
  \putOptions
\end{ClosedQuestion}
}


%18
\newcommand{\qRelacaoModulosComponentes}{
\begin{ClosedQuestion}
  Qual das seguintes frases descreve melhor a relao existente entre
  mdulos e componentes?

  \optionA{Um mdulo pode conter cdigo de diferentes componentes}
  \optionB{Um componente pode executar cdigo de mdulos diferentes}
  \optionC{Um mdulo pode executar cdigo de componentes diferentes}
  \optionD{Um componente pode conter cdigo de diferentes mdulos}
  \putOptions
\end{ClosedQuestion}
}



%19
\newcommand{\qIdentityMap}{
\begin{ClosedQuestion}
  O padro Identity Map  usado em aplicaes empresariais

  
    \optionA{Quando a lgica de domnio da aplicao  implementada
    recorrendo ao padro Transaction Script que acede aos dados persistentes atravs de Record Sets}
    \optionB{Quando a lgica de domnio da aplicao  implementada
    recorrendo ao padro Domain Model }
    \optionC{Quando a lgica de domnio da aplicao  implementada
    recorrendo ao padro Service Layer}
    \optionD{Independentemente de qual  a forma usada para implementar
    a lgica de domnio da aplicao}
  \putOptions
\end{ClosedQuestion}
}



%20
\newcommand{\qUnitOfWork}{
\begin{ClosedQuestion}
  O padro Unit of Work  normalmente usado em aplicaes empresariais
  para agrupar uma srie de operaes de acesso a dados que pertencem
  a uma nica operao de negcio.  Visto que o cdigo executado no
  contexto de uma Unit of Work pode estar espalhado por diferentes
  mdulos do sistema, pode acontecer que durante a mesma Unit of Work
  se leia da base de dados os mesmos dados mais do que uma vez, o que
  pode trazer problemas de coerncia da informao se no forem
  tomadas as precaues devidas.  Como  que este problema  resolvido
  quando se est a usar o padro Unit of Work?

  
    \optionA{Uma vez que o padro Unit of Work coordena as escritas na
    base de dados, consegue detectar quando  que os dados podem ficar
    incoerentes, e aborta a operao nesses casos}
   \optionB{Cada Unit of Work utiliza um Identity Map para evitar este
    problema}
    \optionC{Visto que todas as operaes de acesso a dados feitas no
    contexto de uma Unit of Work so feitas na mesma transaco de
    base de dados, a base de dados garante a coerncia dos dados}
    \optionD{Este problema no  resolvido pelo Unit of Work, e  uma
    das desvantagens da sua utilizao, porque  o programador que tem
    que lidar com o problema directamente no cdigo que escreve}
  \putOptions
\end{ClosedQuestion}
}


%% =========================================================================
%% exam1 2010/2011
%% =========================================================================


%1
\newcommand{\qVistasDesempenho}{
\begin{ClosedQuestion}
  Suponha que existem determinados requisitos de desempenho para um
  sistema, e que pretende mostrar aos stakeholders desse sistema que a
  arquitectura de software que concebeu satisfaz esses requisitos.
  Para isso

  \begin{options}
    \option No faz sentido usar vistas do tipo de vista mdulo, uma
    vez que estas apenas descrevem o sistema do ponto de vista esttico
    \option Deve-se usar exclusivamente vistas do tipo de vista
    componente-e-conector, que descrevem os aspectos dinmicos do sistema
    \option Pode ser necessrio usar vistas dos trs tipos de vistas
    \option As nicas vistas que so relevantes para aspectos de
    desempenho so vistas do estilo instalao (\emph{deployment})
  \end{options}
\end{ClosedQuestion}
}


%2
\newcommand{\qAtrQualNegocio}{
\begin{ClosedQuestion}
  Existem outros factores que afectam o desenvolvimento de um sistema
  de software, para alm dos seus requisitos funcionais e de atributos
  de qualidade.  Por exemplo, factores como o oramento ou o tempo
  disponvel.  Estes factores

  \begin{options}
    \option Influenciam o processo de desenvolvimento de software e a
    gesto do mesmo, mas no a arquitectura de software do sistema a
    desenvolver
    \option Devem ser capturados atravs de cenrios, tais como os
    requisitos de atributos de qualidade, e ser tidos em conta no
    desenho da arquitectura de software
    \option So importantes para determinar a viabilidade do sistema,
    mas uma vez que se chegue  concluso de que o sistema pode ser
    desenvolvido com essas restries, a arquitectura de software j
    no depende destes factores
    \option No so uma das influncias da arquitectura de software no
    ciclo de negcio da arquitectura
  \end{options}
\end{ClosedQuestion}
}


%3
\newcommand{\qReutilizar}{
\begin{ClosedQuestion}
  Suponha que vai desenvolver um novo sistema de software e que
  pretende que uma parte da funcionalidade deste novo sistema possa
  ser facilmente reutilizada em sistemas a desenvolver no futuro.
  Quais dos seguintes estilos arquitecturais so mais adequados para
  mostrar que a arquitectura do sistema satisfaz este requisito.

  \begin{options}
   \option Os estilos decomposio (\emph{decomposition}) e
    utilizao (\emph{uses}), que nos permitem mostrar at que ponto
    um determinado mdulo depende de outras partes do sistema
    \option O estilo implementao (\emph{implementation}), que nos
    permite saber onde esto os artefactos que implementam um
    determinado mdulo
    \option O estilo camadas (\emph{layers}), que nos permite mostrar
    que a estrutura do nosso sistema  composta por vrios mdulos que
    podem ser facilmente reutilizados noutros sistemas
    \option Os estilos cliente-servidor (\emph{client-server}) e
    instalao (\emph{deployment}), que nos permitem isolar a
    funcionalidade pretendida num componente que executa autonomamente
    e, portanto, reutilizvel noutros sistemas
  \end{options}
\end{ClosedQuestion}
}


%4
\newcommand{\qTresTiposVista}{
\begin{ClosedQuestion}
  De acordo com o modelo do SEI, existem trs tipos diferentes de
  vistas arquitecturais que so normalmente necessrias para descrever
  completamente uma arquitectura de software.

  \begin{options}
    \option Estes trs tipos de vistas complementam-se, mas so
    completamente independentes entre si, mostrando aspectos
    diferentes de um sistema que no se relacionam de nenhuma forma
    \option Os tipos de vista mdulo e componente-e-conector
    so independentes entre si, mas o tipo de vista afectao depende
    dos dois primeiros
    \option Cada tipo de vista utiliza elementos de software
    diferentes, como mdulos ou componentes, pelo que no faz sentido
    falar em relaes entre estes tipos de vistas
    \option Apesar de cada tipo de vista apresentar aspectos
    diferentes de um sistema, existem relaes entre todos eles
  \end{options}
\end{ClosedQuestion}
}


%5
\newcommand{\qModificabilidadeCamadas}{
\begin{ClosedQuestion}
  Numa arquitectura de camadas composta por quatro camadas, em que a
  camada mais de cima  a camada nmero 1 e a de mais de baixo  a
  camada nmero 4, qual das camadas  mais facilmente modificvel?

  \begin{options}
    \option A camada 1
    \option A camada 4
    \option Numa arquitectura de camadas, qualquer camada  igualmente
    modificvel
    \option A facilidade de modificao no  particularmente
    facilitada por uma arquitectura de camadas
  \end{options}
\end{ClosedQuestion}
}


%6
\newcommand{\qUtilidadeArquitectura}{
\begin{ClosedQuestion}
  O desenho da arquitectura de software de um sistema complexo

  \begin{options}
    \option S  til se for feito (ainda que apenas parcialmente)
    antes de a implementao do sistema ter sido concluda, visto que
    a arquitectura serve para restringir a implementao
    \option S  til se for feito (ainda que apenas parcialmente)
    antes de a implementao do sistema ter sido concluda, porque
    se o sistema j est implementado, a sua implementao determina
    univocamente a arquitectura do sistema
    \option S  til se for feito (ainda que apenas parcialmente)
    antes de o sistema passar todos os testes de aceitao por parte
    do cliente, altura a partir da qual no vo existir mais
    alteraes de requisitos
    \option  til mesmo que a implementao j tenha sido concluda e
    o sistema tenha entrado na fase de manuteno
 \end{options}
\end{ClosedQuestion}
}


%7
\newcommand{\qArchitecturalDrivers}{
\begin{ClosedQuestion}
  Os requisitos para sistemas complexos so normalmente muito
  numerosos e conflituosos entre si, tornando impossvel satisfazer
  todos os requisitos completamente numa implementao do sistema.
  Por isso, o processo recomendado para se fazer o desenho da
  arquitectura de software de um sistema passa pela identificao dos
  \emph{architectural drivers}, que iro moldar o desenho da
  arquitectura.  Estes \emph{architectural drivers} devem ser
  escolhidos de forma a que sejam

  \begin{options}
    \option Um subconjunto dos requisitos que no entram em conflito
    entre si e que correspondam aos objectivos de negcio mais importantes
    \option Um subconjunto dos requisitos que mais entram em conflito e
    para os quais  preciso encontrar compromissos cedo no processo de desenho
    \option Um subconjunto dos requisitos que correspondam aos
    objectivos de negcio mais importantes, independentemente de
    entrarem em conflito entre si
    \option Um subconjunto dos requisitos que  escolhido
    exclusivamente pelo arquitecto tendo em conta a sua influncia na
    arquitectura do sistema
  \end{options}
\end{ClosedQuestion}
}


%8
\newcommand{\qArqEmailMTA}{
\begin{ClosedQuestion}
  O sistema de email  composto por vrios tipos de componentes
 que desempenham diferentes funes.  Por exemplo, para
  enviar um email, um utilizador pode utilizar um programa como o
  Microsoft Outlook ou o Mozilla Thunderbird, genericamente designado
  por \emph{mail user agent} (MUA), para compor a sua mensagem e
  envi-la.  Para enviar a mensagem, tipicamente o MUA liga-se a um
  \emph{mail transfer agent} (MTA), que recebe a mensagem, analisa os
  cabealhos da mesma para determinar os vrios destinatrios e, aps
  consulta do sistema DNS para determinar quais os MTA responsveis
  por cada um dos destinatrios, liga-se aos MTAs responsveis pelos
  endereos de destino para entregar a mensagem.  Cada um desses MTAs
  recebe a mensagem e armazena-a localmente ou reenvia-a para outros
  MTAs (por exemplo, quando existem \emph{forwards} ou \emph{aliases}
  configurados, ou quando o MTA que recebe a mensagem no  o
  responsvel final pelo endereo de email do destinatrio).

 Tendo em conta esta descrio simplificada do funcionamento do
  sistema de email, qual dos seguintes estilos arquitecturais lhe
  parece mais adequado para representar o padro de interaco
  existente entre os MTAs?

  \begin{options}
    \option O estilo Par-a-Par (\emph{Peer-to-Peer})
    \option O estilo Dados Partilhados (\emph{Shared data})
    \option O estilo Cliente-Servidor (\emph{Client-Server})
    \option O estilo Publicao-Subscrio (\emph{Publish-subscribe})
 \end{options}
\end{ClosedQuestion}
}


%9
\newcommand{\qArqEmailIMAP}{
\begin{ClosedQuestion}
  Considerando ainda o exemplo do sistema de email, os MUAs servem no
  s para compor e enviar mensagens, mas tambm para os utilizadores
  lerem as mensagens de email que lhe foram enviadas.  Para isso os
  MUAs tm que obter essas mensagens do componente que as armazena
  para as mostrar ao utilizador.  Duas formas diferentes de o fazer 
  usando os protocolos POP e IMAP.  No primeiro caso, as mensagens so
  movidas do servidor de POP para o computador do utilizador.  No
  segundo caso, as mensagens continuam armazenadas no servidor de
  IMAP, permitindo assim que o utilizador possa aceder ao seu email a
  partir de computadores diferentes, desde que todos eles se consigam
  ligar ao mesmo servidor de IMAP.

  Qual dos seguintes estilos arquitecturais lhe parece mais adequado
  para representar o padro de interaco existente entre os MUAs e um
  servidor de IMAP?

 \begin{options}
    \option O estilo Processos Comunicantes (\emph{Communicating Processes})
    \option O estilo Canais-e-filtros (\emph{Pipes-and-filters})
    \option O estilo Par-a-Par (\emph{Peer-to-Peer})
    \option O estilo Dados Partilhados (\emph{Shared data})
  \end{options}
\end{ClosedQuestion}
}


%10
\newcommand{\qXBoardChess}{
\begin{ClosedQuestion}
  Dada a complexidade de construir um bom jogador automtico de
  Xadrez,  normal que os programas para jogar Xadrez recorram a
  motores de Xadrez (\emph{chess engines}) j existentes, como mostra
  o seguinte excerto da Wikipedia:
  \begin{quote}
    A chess engine is a computer program that can play the game of
    chess.

    Most chess engines do not have their own graphical user interface
    (GUI) but are rather console applications that communicate with a
    GUI such as XBoard (Linux) and WinBoard (Windows) via a standard
    protocol.
  \end{quote}

  Na pgina web do XBoard, podemos ler o seguinte:
  \begin{quote}
    XBoard is a graphical user interface for chess [...]. It displays
    a chessboard on the screen, accepts moves made with the mouse, and
    loads and saves games in Portable Game Notation (PGN). It serves
    as a front-end for many different chess services, including:

    \begin{itemize}
    \item Chess engines that will run on your machine and play a game
      against you or help you analyze, such as GNU Chess, Crafty, or
      many others.
    \item [...]
    \end{itemize}
  \end{quote}
 
  Tendo em conta a informao acima sobre o XBoard, os motores de
  Xadrez, e a forma como eles interagem em tempo de execuo, qual dos
  seguintes estilos arquitecturais melhor representa a arquitectura de
  software de um sistema baseado no XBoard e num dos motores?

  \begin{options}
    \option O estilo Processos Comunicantes (\emph{Communicating Processes})
    \option O estilo Utilizao (\emph{Uses})
    \option O estilo Camadas (\emph{Layers})
    \option O estilo Par-a-Par (\emph{Peer-to-Peer})
\end{options}
\end{ClosedQuestion}
}


%11 
\newcommand{\qAlterarFuncionalidadesExistentes}{
\begin{ClosedQuestion}
  Suponha que vai trabalhar para a equipa de desenvolvimento de um
  sistema de software de grandes dimenses, e que lhe so atribudas
  tarefas de alterao de funcionalidades j existentes.  Quais das
  seguintes vistas arquitecturais lhe seriam, em princpio, mais teis
  para desempenhar rapidamente essas tarefas?

  \begin{options}
    \option Vistas de Decomposio (\emph{Decomposition}) e de Camadas (\emph{Layers})
    \option Vistas de Decomposio (\emph{Decomposition}) e de
    Atribuio de Trabalho (\emph{Work assignment})
    \option Vistas de Decomposio (\emph{Decomposition}) e de Implementao (\emph{Implementation})
    \option Vistas de Decomposio (\emph{Decomposition}) e de Generalizao (\emph{Generalization})
  \end{options}
\end{ClosedQuestion}
}


%12
\newcommand{\qBlackBoxTesting}{
\begin{ClosedQuestion}
  Considere o seguinte excerto da pgina da Wikipedia sobre testes de
  caixa preta (\emph{black-box testing}):
  \begin{quote}
    Black-box testing is a method of software testing that tests the
    functionality of an application as opposed to its internal
    structures or workings.  Specific knowledge of the application's
    code/internal structure and programming knowledge in general is
    not required.  Test cases are built around specifications and
    requirements, i.e., what the application is supposed to do.
  \end{quote}
  
  Supondo que pertence  equipa de testes de um sistema complexo e que
   responsvel por efectuar testes de caixa preta sobre o sistema,
  quais das seguintes vistas da arquitectura de software do sistema
  lhe seriam mais teis?

  \begin{options}
    \option Vistas de Decomposio (\emph{Decomposition}) e de Implementao (\emph{Implementation})
    \option Vistas de Decomposio (\emph{Decomposition}) e de Utilizao (\emph{Uses})
    \option Vistas de componente-e-conector
    \option Nenhumas, visto que para efectuar os testes de caixa preta
    no  necessrio conhecer o cdigo ou a estrutura interna da
    aplicao a ser testada
  \end{options}
\end{ClosedQuestion}
}


%13
\newcommand{\qTrocarBDCamadas}{
\begin{ClosedQuestion}
  Considere uma aplicao empresarial que necessita de guardar os seus
  dados de forma persistente, mas para a qual no se sabe ainda qual
  ser o volume de informao que esta ter que suportar.  Por isso,
  pretende-se desenvolver o sistema de forma a que seja possvel
  alterar facilmente o componente de bases de dados relacional (RDBMS)
  usado para armazenar os dados da aplicao, substituindo-o por um
  RDBMS de outro fabricante.  Visto que este  um requisito comum, a
  arquitectura de software recomendada para este tipo de aplicaes
  satisfaz este requisito atravs da utilizao de um determinado
  estilo arquitectural.  Que estilo  esse?

  \begin{options}
    \option O estilo Dados partilhados (\emph{Shared data})
    \option O estilo Repositrio (\emph{Repository})
    \option O estilo Camadas (\emph{Layers})
    \option O estilo Cliente-Servidor (\emph{Client-Server})
  \end{options}
\end{ClosedQuestion}
}


%14
\newcommand{\qGoogleAppEngine}{
\begin{ClosedQuestion}
  Suponha que decidiu usar o Google App Engine (GAE) no
  desenvolvimento de uma aplicao web.

  O GAE  descrito na Wikipedia da seguinte forma:
  \begin{quote}
    Google App Engine is a platform for developing and hosting web
    applications in Google-managed data centers.

    Google App Engine is cloud computing technology.  It virtualizes
    applications across multiple servers and data centers. [...]

    Google App Engine is free up to a certain level of used resources.
    Fees are charged for additional storage, bandwidth, or CPU cycles
    required by the application.
  \end{quote}
  
  Por outro lado a documentao do GAE diz o seguinte:
  \begin{quote}
    With App Engine, you can build web applications using standard
    Java technologies and run them on Google's scalable
    infrastructure.  The Java environment provides a Java 6 JVM, a
    Java Servlets interface, and support for standard interfaces to
    the App Engine scalable datastore and services, such as JDO, JPA,
    JavaMail, and JCache.  Standards support makes developing your
    application easy and familiar, and also makes porting your
    application to and from your own servlet environment
    straightforward.
  \end{quote}

  Tendo em conta estas duas perspectivas sobre o GAE, que estilos
  arquitecturais so mais indicados para representar a sua utilizao
  na arquitectura de software da sua aplicao web?

  \begin{options}
    \option Os estilos Decomposio (\emph{Decompostion}) e Implementao (\emph{Implementation})
    \option Os estilos Instalao (\emph{Deployment}) e Utilizao (\emph{Uses})
    \option Os estilos Cliente-Servidor (\emph{Client-Server}) e Generalizao (\emph{Generalization})
    \option Os estilos Instalao (\emph{Deployment}) e Camadas (\emph{Layers})
  \end{options}
\end{ClosedQuestion}
}


%15
\newcommand{\qAumentarDesempenhoClienteServidor}{
\begin{ClosedQuestion}
  Suponha que tem um sistema com uma arquitectura cliente-servidor que
  foi concebido para suportar a existncia simultnea de no mximo 100
  clientes, sem requisitos especiais de disponibilidade.  A soluo
  adoptada e posta em funcionamento h 4 anos consiste num nico
  componente do tipo servidor ao qual se ligam todos os clientes.
  Esta soluo satisfazia os requisitos iniciais mas com o aumento
  recente do nmero mximo de clientes para 200, o sistema deixou de
  ter um desempenho aceitvel.  No sabendo mais nada sobre a
  arquitectura do sistema, que soluo prope para resolver os
  problemas de desempenho do sistema?

  \begin{options}
    \option Manter a arquitectura actual do sistema e optimizar o
    cdigo de modo a alcanar os nveis de desempenho necessrios actualmente
    \option Alterar a vista de instalao do sistema, replicando o servidor por
    mais mquinas
    \option Rever a arquitectura do sistema de forma a passar parte da
    computao actualmente feita no servidor para os clientes
    \option Substituir a mquina usada pelo servidor por uma mquina
    mais poderosa que satisfaa os novos requisitos de desempenho,
    mantendo apenas um componente servidor em funcionamento
  \end{options}
\end{ClosedQuestion}
}


%16
\newcommand{\qAlteracaoWebDois}{
\begin{ClosedQuestion}
  A evoluo registada nas aplicaes web no sentido de providenciar
  uma interface com o utilizador mais rica levou a uma mudana na sua
  arquitectura: parte da computao da aplicao passou a ser feita no
  \emph{browser} web usado pelos utilizadores para aceder  aplicao.
  Como  que esta alterao na arquitectura se manifesta nos
  diferentes tipos de vista que descrevem a arquitectura de software
  de uma aplicao web?

  \begin{options}
    \option Visto que  sobre aspectos de execuo, a alterao
    manifesta-se apenas atravs da alterao dos componentes e
    conectores existentes no sistema
   \option Esta alterao na forma de funcionamento das aplicaes
    no corresponde a nenhuma alterao da sua arquitectura, visto
    que, a nvel arquitectural, continuamos a ter os mesmos
    componentes
    \option A nica alterao arquitectural  na vista de Instalao
    (\emph{Deployment}), uma vez que os componentes e conectores
    continuam a ser os mesmos, mas executam em stios diferentes
    \option Esta alterao reflecte-se na relao existente entre
    mdulos e componentes do sistema
  \end{options}
\end{ClosedQuestion}
}


%17
\newcommand{\qPluginsEclipse}{
\begin{ClosedQuestion}
  O IDE Eclipse  uma aplicao \emph{open source} escrita em Java, e
   extensvel atravs da utilizao de \emph{plug-ins}.  No documento
  que descreve a arquitectura de plug-ins existente no Eclipse,
  podemos ler o seguinte:

  \begin{quote}
    A plug-in in Eclipse is a component that provides a certain type
    of service within the context of the Eclipse workbench. [...]  The
    plug-in class provides configuration and management support for
    the plug-in.  A plug-in class in Eclipse must extend
    \texttt{org.eclipse.core.runtime.Plugin}, which is an abstract
    class that provides generic facilities for managing plug-ins.
  \end{quote}

  Tendo em conta o modelo e a nomenclatura usados na cadeira para a
  descrio de uma arquitectura de software, que tipo de vistas lhe
  parecem mais adequadas para representar a arquitectura de plug-ins
  do Eclipse descrita acima?

  \begin{options}
    \option Vistas do tipo de vista componente-e-conector
    \option Vistas do tipo de vista mdulo
    \option Vistas do tipo de vista afectao (\emph{Allocation})
    \option Todas as anteriores
  \end{options}
\end{ClosedQuestion}
}


%18
\newcommand{\qServiceLayer}{
\begin{ClosedQuestion}
  Quando se utiliza o padro Domain Model na implementao da camada
  de lgica de domnio de uma aplicao empresarial,  comum
  utilizar-se tambm o padro Service Layer.  O padro Service Layer 
  usado nestes casos para

  \begin{options}
    \option Controlar e reduzir a interface exposta pela camada de lgica de
    domnio, aumentando assim a modificabilidade dessa camada
    \option Permitir a existncia de mais do que uma camada de lgica
    de apresentao para a mesma aplicao (para providenciar, por
    exemplo, uma interface de \emph{web services})
    \option Expor diferentes interfaces da camada de lgica de domnio
    para permitir a existncia de diferentes camadas de lgica de apresentao
    \option Facilitar o utilizao da camada de acesso a dados por
    parte da camada de lgica de apresentao
  \end{options}
\end{ClosedQuestion}
}


%19
\newcommand{\qUnitOfWork}{
\begin{ClosedQuestion}
  O padro Unif of Work  normalmente usado nas aplicaes
  empresariais para

  \begin{options}
    \option Implementar cada um dos servios que so executados sempre
    que  feito um pedido do cliente ao servidor
    \option Melhorar o desempenho do servidor por manter uma cache
    dos objectos mais acedidos durante o processamento de um pedido
    feito pelo cliente
    \option Dividir a computao necessria para processar cada um dos
    pedidos feitos pelo cliente em unidades de trabalho mais pequenas
    e paralelizveis
    \option Manter um registo das alteraes feitas aos dados durante
    uma transaco de negcio e coordenar a escrita dessas alteraes
    para a base de dados
  \end{options}
\end{ClosedQuestion}
}


%20
\newcommand{\qIdentityMap}{
\begin{ClosedQuestion}
  O padro Identity Map  normalmente usado nas aplicaes
  empresariais para
 
  \begin{options}
    \option Melhorar o desempenho do servidor aplicacional porque se
    mantm uma cache de entidades que reduz o nmero de operaes
    feitas sobre a base de dados
    \option Evitar carregar muitos dados da base de dados quando uma
    entidade que tem muitas relaes com outras entidades  carregada
    \option Evitar que os dados fiquem incoerentes quando existem
    mltiplos acessos dentro da mesma operao de negcio  mesma
    entidade
    \option Conseguir associar a cada entidade carregada pelo servidor
    aplicacional a identidade dessa entidade na base de dados, para
    poder actualizar a base de dados mais tarde, se for necessrio
  \end{options}
\end{ClosedQuestion}
}


%% =========================================================================
%% exam2 2009/2010
%% =========================================================================


\begin{ClosedQuestion}
  Existem vrios factores que podem influenciar o desenho da
  arquitectura de software de um sistema, mas, tanto a arquitectura,
  como o sistema desenvolvido com base nessa arquitectura, tambm
  podem influenciar o ambiente que lhe deu origem.  A isto chamamos o
  Ciclo de Negcio da Arquitectura (\emph{Architecture Business
    Cycle}).  Qual dos seguintes aspectos  mais raramente
  influenciado pela arquitectura?

  \begin{options}
    \option A experincia do arquitecto de software
    \option O ambiente tecnolgico para o desenvolvimento de novos sistemas
    \option A estrutura da organizao que desenvolve o sistema
    \option Os requisitos dos utilizadores
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  A descrio da arquitectura de software de um sistema tem, entre
  outras, a funo de mostrar que o sistema satisfaz cada um dos
  requisitos que foram identificados para o sistema (por exemplo, um
  requisito de disponibilidade).  Que relao existe entre as vistas
  de uma arquitectura de software e os requisitos?

  \begin{options}
    \option Cada vista mostra a satisfao de um s requisito e esse
    requisito fica completamente satisfeito atravs dessa vista
    \option Basta uma vista para mostrar a satisfao de um requisito,
    mas uma vista pode mostrar a satisfao de mais do que um requisito
    \option So necessrias vrias vistas para mostrar a satisfao de
    um requisito, mas cada vista apenas trata de um tipo de requisitos
    (embora possam ser vrios do mesmo tipo)
    \option Nenhuma das anteriores
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Os cenrios gerais desempenham um papel importante no
  desenvolvimento de uma arquitectura de software porque

  \begin{options}
    \option Identificam quais so os requisitos mais importantes que o
    sistema deve satisfazer
    \option Servem-nos de guia na elicitao de requisitos junto dos
    intervenientes (\emph{stakeholders}) do sistema  
    \option Descrevem requisitos gerais que todos os sistemas devem
    tentar satisfazer
    \option Permitem construir uma arquitectura mais robusta que
    satisfaz requisitos menos especficos e que cobrem um leque maior
    de situaes que podem ocorrer no sistema
  \end{options}
\end{ClosedQuestion}



\begin{ClosedQuestion}
  Uma decomposio por objectos de um mdulo  mais adequada do que
  uma decomposio funcional quando

  \begin{options}
    \option Se prev que a maior parte das evolues do mdulo sejam a
    adio de novas operaes que o mdulo deve fornecer
    \option Se prev que a maior parte das evolues do mdulo sejam
    alteraes ao comportamento das operaes j existentes, por
    causa da necessidade de lidar com novos tipos de entidades
    \option A maior parte das operaes do mdulo tm necessidade de
    manipular muitos tipos de objectos diferentes
    \option A maior parte das operaes do mdulo tm necessidade de
    manipular muitas entidades diferentes
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Suponha que  administrador de sistemas de uma empresa que
  desenvolve software, e que tem como tarefa preparar um sistema de
  backups regulares e automticos para o cdigo de um projecto de
  grande dimenso e importncia para a empresa.  Qual das seguintes
  afirmaes  mais correcta?

  \begin{options}
    \option No existe nenhuma vista arquitectural que seja relevante
    para si
    \option A vista mais importante para o seu trabalho  a de
    Decomposio (\emph{Decomposition}), porque identifica as unidades
    de implementao do projecto
    \option A vista mais importante para o seu trabalho  a de
    Atribuio de Trabalho (\emph{Work Assignment}), porque lhe
    permite identificar quem so as pessoas envolvidas no projecto e
    assim saber que reas de utilizadores devem ser salva-guardadas
    \option A vista mais importante para o seu trabalho  a de
    Implementao (\emph{Implementation}), porque descreve de que
    forma  que os artefactos do sistema esto organizados no sistema
    de ficheiros
  \end{options}
\end{ClosedQuestion}

\begin{ClosedQuestion}
  Um dos mais conhecidos fornecedores de solues para \emph{Cloud
    Computing}  a Amazon, atravs do seu servio \emph{Amazon Elastic
    amamozn (EC2)}.  O seguinte excerto foi retirado da pgina
  da Amazon que descreve as funcionalidades do EC2:
  \begin{quote}
    Amazon EC2 presents a true virtual computing environment, allowing
    you to use web service interfaces to launch instances with a
    variety of operating systems, load them with your custom
    application environment, manage your network's access permissions,
    and run your image using as many or few systems as you desire.
 \end{quote}
 Supondo que pretende usar o servio EC2 da Amazon descrito acima num
 sistema de software que est a desenvolver, que vista arquitectural 
 mais afectada por essa deciso?

  \begin{options}
    \option A vista do estilo Decomposio (\emph{Decomposition})
    \option A vista do estilo Instalao (\emph{Deployment})
    \option A vista do tipo Componente-e-Conector
    \option Nenhuma destas, uma vez que a utilizao do EC2 no altera
    o cdigo que vai ser desenvolvido
  \end{options}
\end{ClosedQuestion}

\begin{ClosedQuestion}
  Os conectores numa vista do tipo componente-e-conector

  \begin{options}
    \option Representam a infra-estrutura de rede que permite que os
    componentes comuniquem entre si
    \option Podem, numa outra vista do sistema, ser representados por um
    conjunto de componentes e conectores
    \option Representam as relaes de dependncia existentes entre os
    vrios componentes
    \option Representam os fluxos de controlo durante a execuo do
    sistema
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Suponha que est a desenvolver um sistema de software para uma
  organizao, e que esse sistema tem vrios componentes a executar em
  diversos dispositivos dentro da organizao, componentes esses que
  trocam informao entre si.  Suponha ainda que um dos requisitos de
  segurana para o sistema  que a informao manipulada pelo sistema
  no possa ser acedida por pessoas externas  organizao (isto ,
  pessoas sem acesso s instalaes da organizao).  Para satisfazer
  este requisito

  \begin{options}
    \option Deve providenciar um mdulo na vista de Decomposio
    (\emph{Decomposition}) que seja responsvel pela segurana da
    informao
    \option Deve criar um componente que fique responsvel pela
    autenticao dos utilizadores
    \option Deve exigir que os conectores utilizem protocolos seguros
    de comunicao
    \option Deve exigir, na vista de Instalao (\emph{Deployment}) do
    sistema, que a rede que liga os computadores esteja isolada do exterior
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Suponha que est a implementar um mdulo num sistema que tem uma
  arquitectura de duas camadas.  Sabendo que o seu mdulo pertence 
  camada de cima (assumindo a notao habitual para o estilo camadas),
  isso significa que

  \begin{options}
    \option Pode utilizar operaes definidas em qualquer mdulo do
    sistema
    \option Pode utilizar operaes definidas na camada de baixo,
    mas no as definidas na camada de cima
    \option Pode utilizar operaes definidas na camada de cima,
    mas no as definidas na camada de baixo
    \option Deve utilizar alguma operao definida na camada de baixo
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Normalmente, os clientes de Instant Messaging tm uma janela com a
  lista de contactos do utilizador, e mostram nessa janela o estado de
  cada contacto (se est disponvel, indisponvel, ocupado, etc).
  Visto que o estado de um contacto pode ser alterado a qualquer
  instante, e que o estado de um contacto  fornecido pelo cliente de
  Instant Messaging desse contacto, qual  o estilo arquitectural que
  melhor representa o padro de interaco entre estes componentes?

  \begin{options}
    \option O estilo Dados Partilhados (\emph{Shared Data})
    \option O estilo Canais-e-Filtros (\emph{Pipes-and-filters})
    \option O estilo Publicao-Subscrio (\emph{Publish-subscribe})
    \option O estilo Cliente-Servidor (\emph{Client-Server})
 \end{options}
\end{ClosedQuestion}



\begin{ClosedQuestion}
  Suponha que pertence  equipa de testes de uma empresa de
  desenvolvimento de software, sendo responsvel por verificar o
  funcionamento correcto dos mdulos desenvolvidos pela empresa para
  um determinado sistema.  Que vistas da arquitectura do sistema so
  mais teis para realizar o seu trabalho

  \begin{options}
    \option As vistas do estilo Atribuio de Trabalho (\emph{Work Assignment})
    \option As vistas do estilo Decomposio (\emph{Decomposition})
    \option As vistas do estilo Utilizao (\emph{Uses})
    \option As vistas do estilo Implementao (\emph{Implementation})
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  No desenvolvimento de uma aplicao distribuda, desconfia que pode
  precisar de utilizar uma cache num dos componentes para reduzir o
  nmero de pedidos que esse componente tem que fazer aos restantes
  componentes do seu sistema, mas no quer ter que lidar com os
  problemas de manter uma cache se isso no for estritamente
  necessrio.  Infelizmente, s quando o sistema estiver em produo 
  que ser possvel saber se a cache  mesmo necessria.  Sabendo que
  existem vrios pontos no cdigo desse componente onde  preciso
  invocar servios remotos, qual  a arquitectura mais adequada para
  desenvolver este sistema?

  \begin{options}
    \option Uma arquitectura por camadas em que a camada mais abaixo
    providencia uma interface para invocao de servios remotos
    \option Uma arquitectura do estilo Dados Partilhados (\emph{Shared
      Data}), em que a cache corresponde aos dados a que o resto do
    cdigo precisa de aceder
    \option Uma arquitectura em que definimos um mdulo que tem como
    responsabilidade manter uma cache e que tem dois submdulos: um
    que implementa uma cache sempre vazia, e outro que implementa uma
    cache real
    \option Uma arquitectura do estilo Canais-e-Filtros
    (\emph{Pipes-and-filters}), em que as invocaes de um servio
    remoto so feitas atravs de uma cadeia de filtros, que pode
    incluir ou no a utilizao de uma cache
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Suponha que para desenvolver uma aplicao empresarial (que
  necessita de aceder a uma base de dados) foi decidido usar a
  \emph{framework} Hibernate para facilitar o desenvolvimento do
  cdigo de acesso aos dados.  Que vista arquitectural  mais adequada
  para representar esta deciso?

  \begin{options}
    \option Uma vista do estilo Instalao (\emph{Deployment})
    \option Uma vista do tipo Componente-e-Conector
    \option Uma vista do estilo Utilizao (\emph{Uses})
    \option Uma vista do estilo Decomposio (\emph{Decomposition})
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  A operadora de telecomunicaes mveis Pessimus mantm uma base de
  dados onde regista todas as chamadas efectuadas pelos seus clientes.
  Cada registo tem o nmero do cliente, o nmero contactado, e tempos
  de incio e de fim da chamada.  Para alm disso, a Pessimus tem,
  naturalmente, uma outra base de dados onde tem informao completa
  sobre cada um dos seus clientes (nome, morada, nmero de
  contribuinte, etc).  Suponha que a Pessimus lhe pediu para
  desenvolver uma aplicao web que permita consultar os extractos
  detalhados de um cliente (um extracto detalhado mostra a lista de
  todas as chamadas efectuadas num determinado perodo).  Qual dos
  seguintes padres  mais adequado para implementar a camada de
  acesso aos dados desta aplicao
 
  \label{q:pessimus}

  \begin{options}
    \option O padro Table Data Gateway
    \option O padro Row Data Gateway
    \option O padro Active Record
    \option O padro Data Mapper
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Considerando o cenrio da aplicao a desenvolver para a Pessimus
  descrito na pergunta~\ref{q:pessimus}, qual dos seguintes padres
  lhe parece mais adequado para ser aplicado no desenvolvimento desta
  aplicao

  \begin{options}
    \option O padro Domain Model, porque permite representar os
    clientes e os registos das suas chamadas atravs de uma relao de
    um para muitos, facilitando assim a leitura dos dados necessrios
    para uma operao
    \option O padro Transaction Script, porque  o que permite o
    desenvolvimento mais rpido da aplicao
    \option O padro Unit of Work, porque garante uma viso
    consistente dos dados das duas bases de dados numa nica operao
    de negcio
    \option O padro Identity Map, porque evita a existncia de duas
    instncias diferentes para representar o mesmo cliente
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  A aplicao que desenvolveu para a Pessimus (ver
  pergunta~\ref{q:pessimus}), teve um enorme sucesso e  agora uma das
  aplicaes mais usadas pelos clientes, tendo um nmero muito elevado
  de pedidos todos os dias.  Por isso, foi-lhe pedido que aumentasse o
  desempenho da aplicao.  Nomeadamente, que aumentasse o nmero de
  pedidos que a aplicao consegue processar por minuto.  Supondo que
   aceitvel que os extractos detalhados no mostrem as chamadas
  realizadas nas ltimas 24 horas, a melhor soluo para este problema
  

  \begin{options}
    \option Replicar a base de dados
    \option Replicar o servidor web
    \option Utilizar uma cache no servidor web para reduzir os pedidos
     base de dados
    \option Qualquer uma das opes acima  vlida, dependendo de onde
     que est o estrangulamento (bottleneck) do sistema
  \end{options}
\end{ClosedQuestion}



\begin{ClosedQuestion}
  Um dos objectivos do padro Unit of Work  reduzir o nmero de
  acessos feitos  base de dados (BD).  Para isso, este padro

  \begin{options}
    \option Mantm uma cache dos objectos lidos anteriormente para
    evitar fazer leituras repetidas da BD
    \option Permite ao programador definir um conjunto de objectos que
    iro ser necessrios para a realizao de uma determinada
    operao, e l-os todos numa nica operao de acesso  BD
    \option Mantm um registo dos objectos que foram alterados no
    decorrer de uma operao e faz os acessos  BD para efectuar
    essas alteraes apenas no final da operao
    \option Ao carregar da BD um objecto que tem relaes com outros
    objectos, carrega na mesma operao os objectos que so apontados
    pelo objecto carregado para reduzir a probabilidade de precisar de
    fazer novos acessos  BD a seguir
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  Para implementar o padro Identity Map  necessrio manter um
  registo dos objectos lidos da base de dados anteriormente.  Que
  objectos do modelo de domnio da aplicao devem ser mantidos nesse
  registo?

  \begin{options}
    \option Apenas os objectos que correspondem a entidades
    (instncias de \emph{entity types})
    \option Apenas os objectos que correspondem a valores (instncias
    de \emph{value types})
    \option Todos os objectos que so criados a partir de dados
    armazenados na BD, sejam eles entidades ou valores
    \option Todos os objectos do modelo de domnio, quer tenham vindo
    da base de dados ou no
  \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  O padro Lazy Load  usado na implementao de um Data Mapper para
  controlar a forma como os objectos so lidos da base de dados (BD).
  O objectivo deste padro 

  \begin{options}
    \option Reduzir o nmero de acessos feitos  BD para ler os
    objectos que so necessrios para executar uma operao
    \option Reduzir o tempo gasto na leitura dos objectos necessrios
    para executar uma operao
    \option Reduzir a memria gasta pelos objectos lidos para a
    execuo de uma operao
    \option Permitir ler os objectos em paralelo com a execuo da
    operao para reduzir o tempo em que se espera pela resposta da BD
 \end{options}
\end{ClosedQuestion}


\begin{ClosedQuestion}
  A arquitectura mais comum para uma aplicao web actualmente 
  composta por trs componentes: cliente web, servidor web, e base de
  dados.  O servidor web, por sua vez, costuma ter uma arquitectura de
  trs camadas: lgica de apresentao, lgica de domnio, e acesso a
  dados.  Suponha que tem uma aplicao web com esta arquitectura e
  que pretende fornecer uma interface de \emph{web services} para a
  sua aplicao (para alm da interface web j existente).  Para isso,
  a melhor opo, tendo em conta o esforo de desenvolvimento 

  \begin{options}
    \option Adicionar uma nova camada de servios entre a camada de
    lgica de domnio e a camada de apresentao j existentes, e
    fazer as alteraes no cdigo j existente que forem necessrias
    para respeitar esta nova arquitectura
    \option Criar uma nova camada acima da camada de lgica de negcio
    que implemente a interface de \emph{web services} pretendida, e
    us-la num novo componente do tipo servidor que executa esta nova
    camada e as duas camadas de baixo do sistema original
    \option Criar um novo mdulo que implemente os \emph{web
      services} e executar este mdulo num novo componente do sistema
    que funcione como cliente do servidor web j existente
    \option Separar o componente servidor web em dois componentes, um
    que apenas tem a responsabilidade de servir pedidos de pginas
    web, e um servidor aplicacional que implemente a lgica de negcio
    do sistema
  \end{options}
\end{ClosedQuestion}



%% =========================================================================
%% exam1 2009/2010
%% =========================================================================


%% 1
\begin{ClosedQuestion}
  Supondo que est a desenvolver uma aplicao sozinho para depois a
  comercializar, ento

 \begin{options}
    \option No precisa de fazer o desenho da arquitectura de software
    do sistema, visto que est a fazer a aplicao sozinho
    \option Deve documentar a arquitectura de software do sistema,
    para o caso de precisar de envolver mais algum na equipa de
    desenvolvimento 
    \option Deve documentar a arquitectura de software do sistema se
    isso ajudar a explicar as caractersticas da sua aplicao aos
    potenciais clientes da aplicao
    \option No precisa de documentar a arquitectura de software do
    sistema, visto que o sistema no tem complexidade suficiente que o
    justifique
  \end{options}
\end{ClosedQuestion}


%% 2
\begin{ClosedQuestion}
  Se dois arquitectos de software diferentes forem desenvolver o mesmo
  sistema, muito provavelmente produziro duas arquitecturas de
  software diferentes.  Se o sistema j se encontrar desenvolvido, mas
  sem documentao sobre a sua arquitectura, e os mesmos dois
  arquitectos tiverem como funo documentar a arquitectura do sistema
  com base apenas no cdigo do sistema

  \begin{options}
    \option Muito provavelmente produziro duas arquitecturas de
    software diferentes, visto que o cdigo no permite representar
    toda a informao arquitecturalmente relevante
    \option Muito provavelmente produziro a mesma arquitectura de
    software, visto que o sistema j se encontra desenvolvido e no existem
    ambiguidades sobre o que ele faz
    \option No  possvel documentar a arquitectura de software de um
    sistema a partir apenas do seu cdigo
    \option No  relevante documentar a arquitectura de software do
    sistema se este j se encontra desenvolvido, visto que a
    arquitectura serve para guiar o desenvolvimento do sistema
\end{options}
\end{ClosedQuestion}


%% 3
\begin{ClosedQuestion}
  A arquitectura de software de um sistema  normalmente representada
  atravs de vrias vistas diferentes porque

  \begin{options}
  \option Representar tudo numa vista seria demasiado complexo
  \option Existem vrios intervenientes no processo de desenvolvimento
  e temos que ter uma vista para cada um deles
  \option Existem trs tipos de vista e normalmente temos uma vista de
  cada tipo
  \option Temos que ter pelo menos uma vista por cada componente do
  sistema, e os sistemas normalmente tm mais do que um componente
 \end{options}
\end{ClosedQuestion}


%% 4
\begin{ClosedQuestion}
  Um conceito fundamental no desenvolvimento de uma arquitectura de
  software  o conceito de \emph{architectural driver}.  Os
  \emph{architectural drivers} so

  \begin{options}
  \option Os intervenientes do sistema que colocam os requisitos que
  mais influenciam o desenho da arquitectura
  \option Os intervenientes do sistema que guiam o desenho da
  arquitectura (nomeadamente, os arquitectos e alguns dos membros da
  equipa de programao)
  \option Todos os atributos de qualidade capturados em cenrios
  concretos que estabelecem os requisitos que o sistema deve satisfazer
  \option Uma lista seleccionada dos requisitos do sistema que mais
  podem influenciar a arquitectura do sistema
  \end{options}
\end{ClosedQuestion}



%% 5
\begin{ClosedQuestion}
  Suponha que no processo de desenho da arquitectura de software de um
  sistema chega  concluso de que existem relaes de utilizao
  (\emph{uses}) nos dois sentidos entre quase todos os mdulos do
  sistema.  Isto significa que

  \begin{options}
    \option H muita comunicao entre os vrios mdulos, o que ir
    provocar um baixo desempenho do sistema
    \option No  possvel instalar o sistema em mais do que uma mquina
    \option No  possvel desenvolver e testar o sistema de forma incremental
    \option  muito difcil explicar o que  que o sistema faz, porque
    precisamos de perceber todos os fluxos de execuo
  \end{options}
\end{ClosedQuestion}


%% 6
\begin{ClosedQuestion}
  Supondo que se encontra na situao indicada na pergunta anterior,
  como  que resolveria o problema.

  \begin{options}
    \option Negociava com o cliente os requisitos do sistema para
    tentar eliminar os que provocam o problema
    \option Alterava a decomposio feita para o sistema, de modo a
    obter uma nova modularidade que no envolva tantas relaes de
    utilizao
    \option Alterava algumas das estruturas de dados e dos algoritmos
    escolhidos para minimizar a necessidade de comunicao entre os
    vrios mdulos
    \option Utilizava o estilo de Generalizao para reduzir as
    relaes entre os mdulos
 \end{options}
\end{ClosedQuestion}



%% 7
\begin{ClosedQuestion}
  Foi-lhe pedido para desenvolver uma aplicao que recolha notcias
  de vrias fontes de notcias existentes na web e processe essa
  informao para a apresentar de forma resumida aos utilizadores.  As
  vrias fontes de notcias providenciam essencialmente o mesmo tipo
  de informao, mas so independentes entre si, apresentando
  diferentes interfaces para aceder s notcias que providenciam.
  Para alm disso,  provvel que essas interfaces vo sofrendo
  alteraes ao longo do tempo.

  Que estilo arquitectural aborda melhor estes requisitos da
  aplicao?

  \begin{options}
    \option O estilo Par-a-Par (\emph{Peer-to-Peer}) para representar
    a comunicao entre os vrios componentes
    \option O estilo Cliente-Servidor (\emph{Client-Server}) para
    representar os pedidos feitos pela nova aplicao s vrias fontes
    de notcias
    \option O estilo Utilizao (\emph{Uses}) para representar as
    relaes de dependncia existentes entre a aplicao e cada uma
    das fontes de onde esta obtm notcias
    \option O estilo Camadas (\emph{Layers}) para criar uma mquina
    virtual que esconda do resto da aplicao a variabilidade no
    acesso s vrias fontes de notcias
 \end{options}
\end{ClosedQuestion}


%% 8
\begin{ClosedQuestion}
  Utilizando ainda o exemplo da aplicao da pergunta anterior, qual
  das seguintes afirmaes est mais correcta

  \begin{options}
    \option O estilo Generalizao no tem utilidade neste caso
    \option O estilo Generalizao  til para representar a herana de
    implementao existente entre os vrios mdulos
    \option O estilo Generalizao  til para definir uma interface
    comum a todos os mdulos que acedem a fontes de notcias
    \option A utilizao ou no utilizao do estilo Generalizao
    neste caso no tem qualquer influncia na decomposio do sistema
 \end{options}
\end{ClosedQuestion}


%% 9
\begin{ClosedQuestion}
  Existem duas abordagens radicalmente diferentes de efectuar a
  decomposio de um sistema em mdulos: a decomposio funcional e a
  decomposio por objectos.  Qual das duas deve ser usada ao efectuar
  a decomposio de um sistema?

  \begin{options}
    \option A decomposio funcional, visto que permite capturar e
    explicar melhor as funcionalidades do sistema aos diferentes
    intervenientes
    \option A decomposio por objectos, visto que  uma abordagem
    mais recente que veio substituir a decomposio funcional,
    trazendo claras vantagens de modularidade para os sistemas
    \option Deve ser usada a decomposio que permitir encapsular
    melhor as mudanas previstas para o sistema
    \option Devem ser usadas ambas as formas de decomposio,
    em vistas diferentes do mesmo sistema, permitindo assim obter o
    melhor de cada abordagem
 \end{options}
\end{ClosedQuestion}

%% 10
\begin{ClosedQuestion}
  Suponha que pretende desenvolver um sistema para ser usado em
  servidores de email, cujo objectivo  permitir efectuar alteraes
  aos emails recebidos pelo servidor (por exemplo, para remover
  potenciais vrus ou URLs para sites de phishing).  O objectivo  que
  o servidor de email passe cada email recebido por este sistema antes
  de o processar (quer reencaminh-lo para outro servidor, ou
  armazen-lo localmente).  Pretende-se que o sistema desenvolvido
  seja facilmente modificvel para suportar novos tipos de
  transformaes aos emails.  Que estilo arquitectural lhe parece mais
  adequado para satisfazer estes requisitos?

  \begin{options}
    \option O estilo Par-a-Par (\emph{Peer-to-Peer})
    \option O estilo Canais-e-Filtros (\emph{Pipes-and-filters})
    \option O estilo Cliente-Servidor (\emph{Client-Server})
    \option O estilo Publicao-Subscrio (\emph{Publish-subscribe})
 \end{options}
\end{ClosedQuestion}

%% 11
\begin{ClosedQuestion}
  Suponha que o gestor de projecto de um sistema de software pretende
  avaliar qual o custo associado ao desenvolvimento e posterior
  colocao em funcionamento do sistema.  Que estilo arquitectural 
  til para esta tarefa?

  \begin{options}
    \option O estilo Atribuio de Trabalho (\emph{Work assignment})
    \option O estilo Instalao (\emph{Deployment})
    \option O estilo Utilizao (\emph{Uses})
    \option Todos os anteriores
  \end{options}
\end{ClosedQuestion}


%% 12
\begin{ClosedQuestion}
  Suponha que est a desenvolver uma aplicao web que mantm numa
  base de dados alguma informao introduzida pelos utilizadores, e
  que um dos requisitos  que essa informao seja mantida
  confidencial, no podendo ser vista sequer pelo administrador da
  base de dados.  Apenas os utilizadores que introduziram essa
  informao devem poder aceder a essa informao novamente.

  Como  que satisfazia este requisito?

  \begin{options}
    \option No  possvel satisfazer este requisito relativamente ao
    administrador da base de dados
    \option Utilizava mecanismos de autenticao robustos para
    identificar os utilizadores do sistema com confiana
    \option Cifrava a informao na base de dados com uma password
    conhecida apenas pela aplicao
    \option Cifrava a informao no cliente web (\emph{browser}) usado
    pelo utilizador antes de a enviar para o servidor web
  \end{options}
\end{ClosedQuestion}


%% 13
\begin{ClosedQuestion}
  Utilizando ainda o exemplo da aplicao da pergunta anterior,
  suponha agora que existe tambm o requisito de que, mesmo na
  eventualidade de existir uma avaria no computador que armazena os
  dados da aplicao, deve ser possvel recuperar o funcionamento da
  aplicao com pelo menos todos os dados existentes duas horas antes
  da avaria ter ocorrido.  O tempo de recuperao no  relevante.

  Que estilo arquitectural permite demonstrar melhor a satisfao
  deste requisito?

  \begin{options}
    \option Um estilo do tipo componente-e-conector que contenha um
    componente para detectar a falha existente no componente que
    armazena os dados
    \option O estilo Instalao (\emph{Deployment})
    \option O estilo Implementao (\emph{Implementation})
    \option O estilo Repositrio (\emph{Repository})
  \end{options}
\end{ClosedQuestion}


%% 14
\begin{ClosedQuestion}
  Uma forma de aumentar a disponibilidade de uma aplicao web 
  utilizar um \emph{load-balancer} entre os clientes web e os
  servidores web que seja capaz de detectar falhas nos servidores e
  redireccionar os pedidos dos clientes para um servidor a funcionar
  de forma transparente para o cliente.  Para representar esta
  arquitectura

  \begin{options}
    \option Basta apresentar uma vista de instalao
    (\emph{deployment}) do sistema que contenha o \emph{load-balancer}
    fisicamente entre as mquinas que executam os clientes web e as
    mquinas que executam os servidores
    \option Altera-se o conector usado entre os clientes web e os
    servidores web na vista de componente-e-conector do sistema, de
    modo a que tenha a semntica providenciada pelo \emph{load-balancer}
    \option Cria-se um mdulo na vista decomposio que tenha a
    responsabilidade do \emph{load-balancer}
    \option Nenhuma das anteriores
  \end{options}
\end{ClosedQuestion}


%% 15
\begin{ClosedQuestion}
  Os servidores web implementados em Java, como por exemplo o Tomcat,
  usam normalmente um modelo baseado em \emph{threads} para processar
  os pedidos.  Isto , processam cada pedido numa nova (ou
  reutilizada) \emph{thread} dentro do mesmo processo, ao invs de
  usar processos diferentes para cada pedido, como fazem outros servidores.

  Se quiser desenhar um diagrama arquitectural para descrever o
  funcionamento deste tipo de servidores web, que vista  mais
  adequado?

  \begin{options}
    \option Uma vista do tipo Mdulo
    \option Uma vista do tipo Componente-e-Conector
    \option Uma vista do tipo Afectao
    \option Uma vista de Atribuio de Trabalho (\emph{Work assignment})
  \end{options}
\end{ClosedQuestion}


%% 16
\begin{ClosedQuestion}
  O padro Transaction Script  muitas vezes utilizado no
  desenvolvimento de aplicaes empresariais porque

  \begin{options}
    \option Permite maior independncia no desenvolvimento de
    diferentes casos de uso
    \option  necessrio sempre que as operaes de negcio tm que
    ser processadas dentro de uma transaco
    \option Complementa bem o padro Data Mapper no acesso aos dados
    \option Todas as anteriores
  \end{options}
\end{ClosedQuestion}


%% 17
\begin{ClosedQuestion}
  Suponha que est a desenvolver uma aplicao para fazer a gesto de
  tarefas de uma equipa.  Nessa aplicao precisa de representar
  informao sobre a durao expectvel de cada tarefa (por exemplo, 2
  horas, 3 dias, ou 4 semanas), bem como o instante de tempo em que
  uma determinada tarefa comeou ou deve terminar.  Para alm disso,
  precisa de lidar com intervalos de tempo, que correspondem ao tempo
  entre dois instantes de tempo, para representar o trabalho feito no
  contexto de uma determinada tarefa.  Qual  a melhor forma de
  representar estes conceitos temporais no modelo de domnio da
  aplicao?

  \begin{options}
    \option Representar todos como \emph{value-types}
    \option Representar todos como \emph{entity-types}
    \option Representar os instantes de tempo como \emph{value-type},
    mas os restantes como \emph{entity-types}
    \option Representar os instantes de tempo como \emph{entity-type},
    mas os restantes como \emph{value-types}
 \end{options}
\end{ClosedQuestion}


%% 18
\begin{ClosedQuestion}
  Uma organizao possui j vrias aplicaes que acedem a uma base de
  dados relacional, central  organizao, e que contm todos os dados
  acumulados ao longo dos ltimos 20 anos de funcionamento dos
  sistemas de informao dentro da organizao.

  Pretende-se agora desenvolver uma nova aplicao em Java que utiliza
  o padro Domain Model para representar as entidades de domnio da
  aplicao, a maior parte das quais (mas no todas) correspondem a
  dados j existentes na base de dados central da organizao e que l
  se devem manter.  A generalidade desses dados so manipulados
  concorrentemente pelas aplicaes j existentes.

  Que padro de acesso a dados acha mais adequado para esta nova
  aplicao?

  \begin{options}
    \option O padro Row Data Gateway
    \option O padro Table Data Gateway
    \option O padro Active Record
    \option O padro Data Mapper
  \end{options}
\end{ClosedQuestion}


%% 19
\begin{ClosedQuestion}
  O padro Unit of Work  normalmente usado para implementar um Data
  Mapper porque

  \begin{options}
    \option Reduz o nmero de round-trips  base de dados, melhorando
    assim o desempenho
    \option  responsvel por saber qual  a correspondncia existente
    entre uma classe que representa uma entidade de domnio e a
    estrutura da base de dados
    \option Garante que cada entidade de domnio  carregada da base
    de dados no mximo uma vez
    \option Reduz o volume de dados transferidos por cada pedido feito
     base de dados, reduzindo assim a memria necessria para a aplicao
  \end{options}
\end{ClosedQuestion}


%% 20
\begin{ClosedQuestion}
  Considere novamente a aplicao que recolhe notcias descrita na
  pergunta~7.  Durante o desenvolvimento desta aplicao descobriu que
  algumas das fontes de notcias utilizadas pela sua aplicao
  comunicam elas prprias entre si para obter notcias de outras
  fontes e providenci-las juntamente com as suas.  Felizmente, as
  vrias fontes utilizam um identificador nico para as notcias que
  preservam quando obtm uma notcia de outra fonte.  Que padro pode
  utilizar para eliminar notcias repetidas obtidas atravs das vrias
  fontes?

  \begin{options}
    \option O padro Unit of Work
    \option O padro Identity Map
    \option O padro Lazy Load
    \option O padro Active Record
  \end{options}
\end{ClosedQuestion}


%% =========================================================================
%% exam3 2008/2009
%% =========================================================================


%% 1
\begin{ClosedQuestion}
  The software architecture of a system is an artifact that results
  from the development process for that system.  This artifact

  \begin{options}
    \option Should be concluded after the initial high-level design
    phases of the system, so that the team knows what to build
    \option Should be concluded at the end of the design process,
    before the implementation starts
    \option Should be developed along the entire development process,
    from the initial design phases up to the system's maintenance phases
    \option Should be developed at the end of the development process,
    once we know what are the system's structures
  \end{options}
\end{ClosedQuestion}


%% 2
\begin{ClosedQuestion}
  Consider that a software development team uses an agile methodology
  such as XP (Extreme Programming), where no documentation is
  produced.  Then, the systems developed by that team

  \begin{options}
    \option Typically have a software architecture that results
    from the common knowledge about the system that is shared among
    the team members
    \option Do not have a software architecture, because in agile
    methodologies there is no architectural design phase
    \option Do not have a software architecture, because the practice of
    refactoring allows changing every part of the system easily
    \option May have a software architecture, but that architecture is
    not known because it was neither designed nor  documented
  \end{options}
\end{ClosedQuestion}


%% 3
\begin{ClosedQuestion}
  Assuming that you were asked to document the software architecture
  of an existing (and already developed) system, the best thing for
  you to do would be

  \begin{options}
  \option To analyse the source code of the system to see how it is built
  \option To analyse the system's functional requirements to see what
  is the system supposed to do
  \option To analyse the implemented set of features to see what is it
  that the system actually does
  \option To talk with the people that developed the system to know
  what they did and why they did it
  \end{options}
\end{ClosedQuestion}


%% 4
\begin{ClosedQuestion}
  As part of the process of creating an architecture, we talked about
  a framework for capturing some of the requirements for a system.  In
  this context, \textbf{concrete scenarios} are used for

  \begin{options}
  \option Describing what are the qualities that the system should possess
  \option Describing a set of steps that a user of the system must
  perform to accomplish some task 
  \option Describing a use case for the system that makes clear  what
  should be the system's responses to each of the user's inputs
  \option Describing the system's features by way of different
  usage scenarios for it, in which users play the role of actors
  \end{options}
\end{ClosedQuestion}



%% 5
\begin{ClosedQuestion}
  According to the attribute-driven design process, we should design
  the software architecture for a system based on a selected list of
  requirements, which are called the \textit{architectural drivers}.
  These architectural drivers should be sorted according to their
  importance for the system's stakeholders because
 
  \begin{options}
    \option We should always satisfy in the first place the requirements
    of more important stakeholders (such as the client)
    \option If no order was established among them, we would not know
    from where should we start the design process
    \option If one of the stakeholders complains that his requirement
    is not satisfied, we may explain to him that there were other more
    important requirements first
    \option When it is not possible to satisfy all of the requirements
    optimally, we should be aware of their relative importance so that
    we may find a solution that corresponds to a satisfactory trade-off
  \end{options}
\end{ClosedQuestion}


%% 6
\begin{ClosedQuestion}
  The Work-assignment is an architectural style of the allocation
  viewtype, where
 
  \begin{options}
    \option Components are allocated to persons and teams
    \option Modules are allocated to persons and teams
    \option Components and modules are allocated to persons and teams
    \option None of the above
  \end{options}
\end{ClosedQuestion}



%% 7
\begin{ClosedQuestion}
  Since the iPhone was launched by Apple, many software companies
  release a desktop application for the Mac OS X and a companion
  application that runs on the iPhone (for example, an application for
  managing \emph{to-do lists}).  Typically, the applications have
  completely different user interfaces (because the iPhone has
  radically different ways for interacting with the user), even though
  they share many of the same features.  That is, they do almost the
  same thing, but through different user interfaces.  Knowing also
  that the programming language used to program Mac OS X applications
  is the same used to program iPhone applications, which of the
  following architectural patterns should be used to develop these
  applications?

  \begin{options}
  \option A decomposition of the system into two modules, one with the
  responsibility of the user interface and the other with all the
  remaining responsibilities
  \option The previous one plus a view of the uses style where the
  module of the user interface uses the other
  \option A layered architecture, where the bottommost layer
  provides an interface for creating a graphical interface
  \option A layered architecture, where all the code for the user
  interface of the application is in the topmost layer
  \end{options}
\end{ClosedQuestion}


%% 8
\begin{ClosedQuestion}
  Imagine that we want to implement the \textit{to-do lists}
  application mentioned in the previous question, with both an
  application for the Mac OS X and another one for the iPhone.  The
  goal is that a user owning both applications may manage his list of
  \textit{to dos} in either of the applications and the changes made
  in one of the applications should be visible in the other.

  Which of the following solutions is better?

  \begin{options}
    \option Use a Peer-to-peer style where the two applications play
    the roles of peers and interact directly through the Internet
    \option Use a server in the Internet for storing the to-do lists
    of each client and each application synchronizes its data with
    this server
    \option Use a Publish-subscribe style where each application
    publishes and subscribes to events that correspond to changes in
    the to-do lists
    \option Use a Communicating-processes style where the two
    applications are independent processes that communicate to
    synchronize their data
  \end{options}
\end{ClosedQuestion}


%% 9
\begin{ClosedQuestion}
  In the software architecture of a system, the Deployment view is
  best suited for

  \begin{options}
    \option Analysing the performance of the system
    \option Planning incremental releases of the system
    \option Estimating the effort needed to implement the system
    \option Analysing the system's portability and reusability
  \end{options}
\end{ClosedQuestion}


%% 10
\begin{ClosedQuestion}
  Consider that we have a software system that comprises two
  components that need to exchange some data between them.  One of the
  security requirements for this system is that the data exchanged
  between them should be kept confidential from anyone without
  physical access to any of the components, but that may have physical
  access to the network connecting them.  That is, if someone with
  physical access to the network connecting the machines where the
  components are running tries to read the data exchanged between
  them, the system should not allow reading that data.

  Which of the following is correct?
 
  \begin{options}
  \option It is not possible to satisfy this requirement without
  securing the physical network between the components
  \option To justify that our system satisfies this requirement, we
  just have to provide an adequate component-and-connector view
  \option To justify that our system satisfies this requirement, we
  must have a component-and-connector view and a deployment view
  \option To justify that our system satisfies this requirement, we
  must have a module for authentication and another for access control
  \end{options}
\end{ClosedQuestion}


%% 11
\begin{ClosedQuestion}
  Imagine that you are developing a new software system that needs to
  store its data in a relational database and that you decide to use
  the Hibernate framework for helping with that.  Which view of the
  system's software architecture would be most affected by this
  decision?

  \begin{options}
  \option The Decomposition view
  \option The Component-and-connector view
  \option The Deployment view
  \option The Work Assignment view
  \end{options}
\end{ClosedQuestion}


%% 12
\begin{ClosedQuestion}
  One way to increase the performance of a 3-tier enterprise
  application (with the standard separation in the web client, web
  server, and database tiers) is to replicate the web server tier and
  to add a load-balancer between the web clients and the web servers.
  Unfortunately, for some enterprise applications that option is not
  enough (or does not work at all), because

  \begin{options}
    \option They have many different use cases, corresponding to many
    distinct user interfaces
    \option They have to process very large amounts of data in each request
    \option They need to be able to process concurrent requests from
    the users
    \option They have a very complex domain logic that requires much
    processing power for answering each request
  \end{options}
\end{ClosedQuestion}


%% 13
\begin{ClosedQuestion}
  Web servers implemented in Java, such as the Tomcat web server,
  typically use a thread-based model for processing requests.  That
  is, they process each request on a different thread within the same
  JVM process, rather than on a different process.  One of the reasons
  for this is that

  \begin{options}
  \option Launching a new process for processing each request is too expensive
  \option Using threads ensures that the processing of each request is
  isolated from the remaining requests
  \option With this approach they may use all of the available cores
  in multiprocessor machines
  \option They are used for implementing enterprise applications that
  typically have complex domain logic and, by using threads, it is
  easier to reuse code from one request to another
  \end{options}
\end{ClosedQuestion}


%% 14
\begin{ClosedQuestion}
  Compared to the Transaction Script pattern, the Domain Logic pattern
  has a higher initial cost of adoption.  That is, it is harder to
  start with the Domain Logic pattern than with the Transaction Script
  pattern.  The reason for this is that the Domain Logic pattern

  \begin{options}
  \option Requires a more skilled team, because the object-oriented
  paradigm is more complex than the procedural paradigm
  \option Is typically used with more complex data access code
  \option Requires that we write more code when we have only a
  couple of simple use cases
  \option All of the above
  \end{options}
\end{ClosedQuestion}


%% 15
\begin{ClosedQuestion}
  Consider the case of a web application for trading antique coins.
  The system keeps a record of all the antique coins traded through
  the system, storing such information about a coin such as its face
  value (e.g., 10 cents of a dollar), its year, its current trading
  price, and who owns it at the time.  When a coin is sold, the
  application should update the coin's owner.  What is the best way to
  model the concept of antique coin in this application's domain
  model?
 
  \begin{options}
    \option As a value-type
    \option As an entity-type
    \option Both of the above options are valid, because that
    choice is not relevant for this application
    \option None of the above
  \end{options}
\end{ClosedQuestion}


%% 16
\begin{ClosedQuestion}
  Ruby on Rails is a popular full-stack framework for building web
  applications.  One of the elements of this framework is the
  \textbf{model}, which is described in the Rails documentation in the
  following way:
  \begin{quote}
    A model represents the information (data) of the application and
    the rules to manipulate that data. In the case of Rails, models
    are primarily used for managing the rules of interaction with a
    corresponding database table. In most cases, one table in your
    database will correspond to one model in your application. The
    bulk of your application's business logic will be concentrated in
    the models.
  \end{quote}
  Given this description, the Rails' model is best described as an
  instance of
 
  \begin{options}
  \option The Service Layer pattern
  \option The Active Record pattern
  \option The Transaction Script pattern
  \option The Data Mapper pattern
  \end{options}
\end{ClosedQuestion}


%% 17
\begin{ClosedQuestion}
  The Lazy Load pattern is typically used to implement a Data Mapper because
 
  \begin{options}
    \option It reduces the number of round-trips to the database,
    thereby improving the performance of each request
    \option It reduces the coupling between the domain entities, thereby
    making them more modular
    \option It guarantees that only one instance of each entity is
    ever loaded, thereby avoiding inconsistencies in the data
    \option It reduces the amount of data transferred from the
    database on each round-trip, thereby reducing the memory needed to
    process each request
  \end{options}
\end{ClosedQuestion}


%% 18
\begin{ClosedQuestion}
  Even though the Optimistic Offline Locking pattern is the
  recommended approach for implementing most of the business
  transactions, there are cases where the best solution is to use the
  Pessimistic Offline Locking pattern.  For instance,

  \begin{options}
    \option If within the business transaction we call some external
    service that is irrevocable, such as debiting a credit card
    \option If the user had to do some work during the business
    transaction and that work is lost when there is a restart of the
    transaction
    \option If the probability of having two users doing two
    transactions that need to access the same data is too high
    \option All of the above
  \end{options}
\end{ClosedQuestion}


%% 19
\begin{ClosedQuestion}
  Consider that we have a class \verb|Person| in a Java program for
  representing a domain entity that has a property \verb|name|, and
  that the \verb|getName| and \verb|setName| methods are the usual
  getter and setter methods for reading and changing the name of a
  person.  Assume, also, that our program uses the Hibernate framework
  for persisting its data into a database, including instances of the
  class \verb|Person|.  The following transcript shows an interaction
  with the BeanShell (an interpreter for a Java-like language that
  allows us to test code in the Java platform) where we use the
  Hibernate API and the \verb|Person| class:
\begin{verbatim}
> s = HibernateUtil.getSessionFactory().getCurrentSession();
> s.beginTransaction();
> p = s.load(Person.class, 1);
> print(p.getName());
John
> p.setName("Mark");
> print(p.getName());
Mark
> p2 = s.load(Person.class, 1);
> print(p == p2);
true
> print(p2.getName());
\end{verbatim}
  What are the correct answers for the following questions: (1) Which
  pattern explains the print value of \verb|true|?, and (2) What would
  be printed by the last print instruction?

  \begin{options}
  \option The Unit of Work pattern; The value \verb|Mark|
  \option The Identity Map pattern; The value \verb|Mark|
  \option The Unit of Work pattern; The value \verb|John|
  \option The Lazy Load pattern; The value \verb|Mark|
  \end{options}
\end{ClosedQuestion}


%% 20
\begin{ClosedQuestion}
  In an enterprise application that uses the Domain Model pattern,
  there is a class \verb|C1| that represents a certain entity in the
  application's domain and that has relationships with other entities.
  This class has three fields to represent the entity's attributes and
  several methods that implement the entity's behavior, including the
  method \verb|m1|.  Given that in this application's domain there are
  10 variations of this entity that differ among them only in the
  behavior implemented by \verb|m1|, the developers of this
  application created 10 subclasses of \verb|C1|, each one overriding
  the method \verb|m1| and adding nothing else.  Now, they want to
  choose the best way to map these entities into a relational
  database.  Assuming that in the domain model of the application
  there are no relationships with subclasses of \verb|C1|, which
  pattern is best to map these entities?
 
  \begin{options}
  \option The Single Table Inheritance pattern
  \option The Class Table Inheritance pattern
  \option The Concrete Table Inheritance pattern
  \option The Inheritance Mappers pattern
  \end{options}
\end{ClosedQuestion}



%% =========================================================================
%% exam2 2008/2009
%% =========================================================================


%% 1
\begin{ClosedQuestion}
  The software architecture of a system is an artifact that results
  from the development process for that system.  This artifact

  \begin{options}
    \option Should be concluded after the initial high-level design
    phases of the system, so that the team knows what to build
    \option Should be concluded at the end of the design process,
    before the implementation starts
    \option Should be developed along the entire development process,
    from the initial design phases up to the system's maintenance phases
    \option Should be developed at the end of the development process,
    once we know what are the system's structures
  \end{options}
\end{ClosedQuestion}


%% 2
\begin{ClosedQuestion}
  Consider that a software development team uses an agile methodology
  such as XP (Extreme Programming), where no documentation is
  produced.  Then, the systems developed by that team

  \begin{options}
    \option Typically have a software architecture that results
    from the common knowledge about the system that is shared among
    the team members
    \option Do not have a software architecture, because in agile
    methodologies there is no architectural design phase
    \option Do not have a software architecture, because the practice of
    refactoring allows changing every part of the system easily
    \option May have a software architecture, but that architecture is
    not known because it was neither designed nor documented
  \end{options}
\end{ClosedQuestion}


%% 3
\begin{ClosedQuestion}
  Assuming that you were asked to document the software architecture
  of an existing (and already developed) system, the best thing for
  you to do would be

  \begin{options}
  \option To analyse the source code of the system to see how it is built
  \option To analyse the system's functional requirements to see what
  is the system supposed to do
  \option To analyse the implemented set of features to see what is it
  that the system actually does
  \option To talk with the people that developed the system to know
  what they did and why they did it
  \end{options}
\end{ClosedQuestion}


%% 4
\begin{ClosedQuestion}
  As part of the process of creating an architecture, we talked about
  a framework for capturing some of the requirements for a system.  In
  this context, \textbf{concrete scenarios} are used for

  \begin{options}
  \option Describing what are the qualities that the system should possess
  \option Describing a set of steps that a user of the system must
  perform to accomplish some task 
  \option Describing a use case for the system that makes clear what
  should be the system's responses to each of the user's inputs
  \option Describing the system's features by way of different
  usage scenarios for it, in which users play the role of actors
  \end{options}
\end{ClosedQuestion}



%% 5
\begin{ClosedQuestion}
  According to the attribute-driven design process, we should design
  the software architecture for a system based on a selected list of
  requirements, which are called the \textit{architectural drivers}.
  These architectural drivers should be sorted according to their
  importance for the system's stakeholders because
 
  \begin{options}
    \option We should always satisfy in the first place the requirements
    of more important stakeholders (such as the client)
    \option If no order was established among them, we would not know
    from where should we start the design process
    \option If one of the stakeholders complains that his requirement
    is not satisfied, we may explain to him that there were other more
    important requirements first
    \option When it is not possible to satisfy all of the requirements
    optimally, we should be aware of their relative importance so that
    we may find a solution that corresponds to a satisfactory trade-off
  \end{options}
\end{ClosedQuestion}


%% 6
\begin{ClosedQuestion}
  The Work-assignment is an architectural style of the allocation
  viewtype, where
 
  \begin{options}
    \option Components are allocated to persons and teams
    \option Modules are allocated to persons and teams
    \option Components and modules are allocated to persons and teams
    \option None of the above
  \end{options}
\end{ClosedQuestion}



%% 7
\begin{ClosedQuestion}
  Since the iPhone was launched by Apple, many software companies
  release a desktop application for the Mac OS X and a companion
  application that runs on the iPhone (for example, an application for
  managing \emph{to-do lists}).  Typically, the applications have
  completely different user interfaces (because the iPhone has
  radically different ways for interacting with the user), even though
  they share many of the same features.  That is, they do almost the
  same thing, but through different user interfaces.  Knowing also
  that the programming language used to program Mac OS X applications
  is the same used to program iPhone applications, which of the
  following architectural patterns should be used to develop these
  applications?

  \begin{options}
  \option A decomposition of the system into two modules, one with the
  responsibility of the user interface and the other with all the
  remaining responsibilities
  \option The previous one plus a view of the uses style where the
  module of the user interface uses the other
  \option A layered architecture, where the bottommost layer
  provides an interface for creating a graphical interface
  \option A layered architecture, where all the code for the user
  interface of the application is in the topmost layer
  \end{options}
\end{ClosedQuestion}


%% 8
\begin{ClosedQuestion}
  Imagine that we want to implement the \textit{to-do lists}
  application mentioned in the previous question, with both an
  application for the Mac OS X and another one for the iPhone.  The
  goal is that a user owning both applications may manage his list of
  \textit{to dos} in either of the applications and the changes made
  in one of the applications should be visible in the other.

  Which of the following solutions is better?

  \begin{options}
    \option Use a Peer-to-peer style where the two applications play
    the roles of peers and interact directly through the Internet
    \option Use a server in the Internet for storing the to-do lists
    of each client and each application synchronizes its data with
    this server
    \option Use a Publish-subscribe style where each application
    publishes and subscribes to events that correspond to changes in
    the to-do lists
    \option Use a Communicating-processes style where the two
    applications are independent processes that communicate to
    synchronize their data
  \end{options}
\end{ClosedQuestion}


%% 9
\begin{ClosedQuestion}
  In the software architecture of a system, the Deployment view is
  best suited for

  \begin{options}
    \option Analysing the performance of the system
    \option Planning incremental releases of the system
    \option Estimating the effort needed to implement the system
    \option Analysing the system's portability and reusability
  \end{options}
\end{ClosedQuestion}


%% 10
\begin{ClosedQuestion}
  Consider that we have a software system that comprises two
  components that need to exchange some data between them.  One of the
  security requirements for this system is that the data exchanged
  between them should be kept confidential from anyone without
  physical access to any of the components, but that may have physical
  access to the network connecting them.  That is, if someone with
  physical access to the network connecting the machines where the
  components are running tries to read the data exchanged between
  them, the system should not allow reading that data.

  Which of the following is correct?
 
  \begin{options}
  \option It is not possible to satisfy this requirement without
  securing the physical network between the components
  \option To justify that our system satisfies this requirement, we
  just have to provide an adequate component-and-connector view
  \option To justify that our system satisfies this requirement, we
  must have a component-and-connector view and a deployment view
  \option To justify that our system satisfies this requirement, we
  must have a module for authentication and another for access control
  \end{options}
\end{ClosedQuestion}


%% 11
\begin{ClosedQuestion}
  Imagine that you are developing a new software system that needs to
  store its data in a relational database and that you decide to use
  the Hibernate framework for helping with that.  Which view of the
  system's software architecture would be most affected by this
  decision?

  \begin{options}
  \option The Decomposition view
  \option The Component-and-connector view
  \option The Deployment view
  \option The Work Assignment view
  \end{options}
\end{ClosedQuestion}


%% 12
\begin{ClosedQuestion}
  One way to increase the performance of a 3-tier enterprise
  application (with the standard separation in the web client, web
  server, and database tiers) is to replicate the web server tier and
  to add a load-balancer between the web clients and the web servers.
  Unfortunately, for some enterprise applications that option is not
  enough (or does not work at all), because

  \begin{options}
    \option They have many different use cases, corresponding to many
    distinct user interfaces
    \option They have to process very large amounts of data in each request
    \option They need to be able to process concurrent requests from
    the users
    \option They have a very complex domain logic that requires much
    processing power for answering each request
  \end{options}
\end{ClosedQuestion}


%% 13
\begin{ClosedQuestion}
  Web servers implemented in Java, such as the Tomcat web server,
  typically use a thread-based model for processing requests.  That
  is, they process each request on a different thread within the same
  JVM process, rather than on a different process.  One of the reasons
  for this is that

  \begin{options}
  \option Launching a new process for processing each request is too expensive
  \option Using threads ensures that the processing of each request is
  isolated from the remaining requests
  \option With this approach they may use all of the available cores
  in multiprocessor machines
  \option They are used for implementing enterprise applications that
  typically have complex domain logic and, by using threads, it is
  easier to reuse code from one request to another
  \end{options}
\end{ClosedQuestion}


%% 14
\begin{ClosedQuestion}
  Compared to the Transaction Script pattern, the Domain Logic pattern
  has a higher initial cost of adoption.  That is, it is harder to
  start with the Domain Logic pattern than with the Transaction Script
  pattern.  The reason for this is that the Domain Logic pattern

  \begin{options}
  \option Requires a more skilled team, because the object-oriented
  paradigm is more complex than the procedural paradigm
  \option Is typically used with more complex data access code
  \option Requires that we write more code when we have only a
  couple of simple use cases
  \option All of the above
  \end{options}
\end{ClosedQuestion}


%% 15
\begin{ClosedQuestion}
  Consider the case of a web application for trading antique coins.
  The system keeps a record of all the antique coins traded through
  the system, storing such information about a coin such as its face
  value (e.g., 10 cents of a dollar), its year, its current trading
  price, and who owns it at the time.  When a coin is sold, the
  application should update the coin's owner.  What is the best way to
  model the concept of antique coin in this application's domain
  model?
 
  \begin{options}
    \option As a value-type
    \option As an entity-type
    \option Both of the above options are valid, because that
    choice is not relevant for this application
    \option None of the above
  \end{options}
\end{ClosedQuestion}


%% 16
\begin{ClosedQuestion}
  Ruby on Rails is a popular full-stack framework for building web
  applications.  One of the elements of this framework is the
  \textbf{model}, which is described in the Rails documentation in the
  following way:
  \begin{quote}
    A model represents the information (data) of the application and
    the rules to manipulate that data. In the case of Rails, models
    are primarily used for managing the rules of interaction with a
    corresponding database table. In most cases, one table in your
    database will correspond to one model in your application. The
    bulk of your application's business logic will be concentrated in
    the models.
  \end{quote}
  Given this description, the Rails' model is best described as an
  instance of
 
  \begin{options}
  \option The Service Layer pattern
  \option The Active Record pattern
  \option The Transaction Script pattern
  \option The Data Mapper pattern
  \end{options}
\end{ClosedQuestion}


%% 17
\begin{ClosedQuestion}
  The Lazy Load pattern is typically used to implement a Data Mapper because
 
  \begin{options}
    \option It reduces the number of round-trips to the database,
    thereby improving the performance of each request
    \option It reduces the coupling between the domain entities, thereby
    making them more modular
    \option It guarantees that only one instance of each entity is
    ever loaded, thereby avoiding inconsistencies in the data
    \option It reduces the amount of data transferred from the
    database on each round-trip, thereby reducing the memory needed to
    process each request
  \end{options}
\end{ClosedQuestion}


%% 18
\begin{ClosedQuestion}
  Even though the Optimistic Offline Locking pattern is the
  recommended approach for implementing most of the business
  transactions, there are cases where the best solution is to use the
  Pessimistic Offline Locking pattern.  For instance,

  \begin{options}
    \option If within the business transaction we call some external
    service that is irrevocable, such as debiting a credit card
    \option If the user had to do some work during the business
    transaction and that work is lost when there is a restart of the
    transaction
    \option If the probability of having two users doing two
    transactions that need to access the same data is too high
    \option All of the above
  \end{options}
\end{ClosedQuestion}


%% 19
\begin{ClosedQuestion}
  Consider that we have a class \verb|Person| in a Java program for
  representing a domain entity that has a property \verb|name|, and
  that the \verb|getName| and \verb|setName| methods are the usual
  getter and setter methods for reading and changing the name of a
  person.  Assume, also, that our program uses the Hibernate framework
  for persisting its data into a database, including instances of the
  class \verb|Person|.  The following transcript shows an interaction
  with the BeanShell (an interpreter for a Java-like language that
  allows us to test code in the Java platform) where we use the
  Hibernate API and the \verb|Person| class:
\begin{verbatim}
> s = HibernateUtil.getSessionFactory().getCurrentSession();
> s.beginTransaction();
> p = s.load(Person.class, 1);
> print(p.getName());
John
> p.setName("Mark");
> print(p.getName());
Mark
> p2 = s.load(Person.class, 1);
> print(p == p2);
true
> print(p2.getName());
\end{verbatim}
  What are the correct answers for the following questions: (1) Which
  pattern explains the print value of \verb|true|?, and (2) What would
  be printed by the last print instruction?

  \begin{options}
  \option The Unit of Work pattern; The value \verb|Mark|
  \option The Identity Map pattern; The value \verb|Mark|
  \option The Unit of Work pattern; The value \verb|John|
  \option The Lazy Load pattern; The value \verb|Mark|
  \end{options}
\end{ClosedQuestion}


%% 20
\begin{ClosedQuestion}
  In an enterprise application that uses the Domain Model pattern,
  there is a class \verb|C1| that represents a certain entity in the
  application's domain and that has relationships with other entities.
  This class has three fields to represent the entity's attributes and
  several methods that implement the entity's behavior, including the
  method \verb|m1|.  Given that in this application's domain there are
  10 variations of this entity that differ among them only in the
  behavior implemented by \verb|m1|, the developers of this
  application created 10 subclasses of \verb|C1|, each one overriding
  the method \verb|m1| and adding nothing else.  Now, they want to
  choose the best way to map these entities into a relational
  database.  Assuming that in the domain model of the application
  there are no relationships with subclasses of \verb|C1|, which
  pattern is best to map these entities?
 
  \begin{options}
  \option The Single Table Inheritance pattern
  \option The Class Table Inheritance pattern
  \option The Concrete Table Inheritance pattern
  \option The Inheritance Mappers pattern
  \end{options}
\end{ClosedQuestion}



%% =========================================================================
%% exam1 2008/2009
%% =========================================================================


%% 1
\begin{ClosedQuestion}
  The software architecture of a system

  \begin{options}
    \option Depends mostly on the system's functional requirements
    \option Depends more on the architect's experience than on anything
    else
    \option Should not depend on the skills of the developing team
    \option None of the above
  \end{options}
\end{ClosedQuestion}


%% 2
\begin{ClosedQuestion}
  The software architecture of a system

  \begin{options}
  \option Is a high-level view of the system with the purpose of
  understanding what are the system's goals and features
  \option Is composed of things such as code units, runtime elements,
  hardware, and people, together with the relationships among them
  \option Is a set of guidelines that the developing team should
  follow in the development of the system
  \option Is a set of diagrams that show the runtime elements of the
  system and their relationships
  \end{options}
\end{ClosedQuestion}


%% 3
\begin{ClosedQuestion}
  The documentation of the software architecture for a system is often
  composed of several views, because

  \begin{options}
  \option We need one view for each system stakeholder
  \option A single view would be too simplistic
  \option The views describe different aspects of the system
  \option All of the above
  \end{options}
\end{ClosedQuestion}


%% 4
\begin{ClosedQuestion}
  Establishing a programming convention such as 
  \begin{quote}
    All of the global variables of the program should start with the
    prefix ``\verb|g_|'', whereas all the non-global variables have
    no underscores in their name.
  \end{quote}

  \begin{options}
  \option Is never an architectural decision because it is too low-level
  \option Is always an architectural decision because it applies to
  the entire program
  \option May be an architectural decision, depending on the
  requirements for the system
  \option May be an architectural decision, depending on the
  architect's experience
  \end{options}
\end{ClosedQuestion}



%% 5
\begin{ClosedQuestion}
  The architectural drivers are important in the process of creating
  the software architecture for a system because they are
 
  \begin{options}
  \option The most important requirements (both functional and
  qualities) that the system must achieve
  \option The components that manage the communication between the
  remaining elements in the system 
  \option The stakeholders that drive the development of the system
  \option The tactics that satisfy the most important requirements for
  the system
  \end{options}
\end{ClosedQuestion}


%% 6
\begin{ClosedQuestion}
  Assume that one of the requirements for a graphical chess game is
  that it should be able to run both in Microsoft's Windows and
  Apple's Mac OS X operating systems.  A good solution for this system
  would:

  \begin{options}
  \option Create a decomposition where there is a module corresponding
  to the Windows OS and another one for the Mac OS X, each one
  encapsulating the behavior of the corresponding OS
  \option Use a classic 3-layer architecture with the following
  layers, from top to bottom: Presentation, Domain Logic, and Data
  Access
  \option Use a layered architecture, where the bottommost layer
  provides an interface for creating a graphical interface
  \option Use two deployment views, each one allocating different
  components to different machines with different operating systems
  \end{options}
\end{ClosedQuestion}


%% 7
\begin{ClosedQuestion}
  Consider now that the chess game of the previous question should
  provide an automatic and intelligent chess player, and that to
  implement that player we will use some of the many chess engines
  already available in the market.  Moreover, the system should allow
  the user to choose which engine to use for each new game.  Given
  these requirements, which of the architectural styles from the
  module viewtype are best suited to satisfy them?
 
  \begin{options}
  \option The Decomposition style
  \option The Decomposition and Uses styles
  \option The Layered style
  \option The Generalization and Decomposition styles
  \end{options}
\end{ClosedQuestion}


%% 8
\begin{ClosedQuestion}
  Another requirement for the chess game from the previous questions
  is that it keeps a table with the best scores obtained in the game.
  Naturally, this information should be kept between two different
  executions of the system.  Assuming that the game is a desktop
  application, then

  \begin{options}
  \option We must use a Repository component-and-connector style
  \option We must use a layered architecture with a ``Data Access''
  layer
  \option We must identify a module for writing the scores in a
  Decomposition style
  \option We may assign the responsibility of writing the scores to
  another module that already has other responsibilities
  \end{options}
\end{ClosedQuestion}


%% 9
\begin{ClosedQuestion}
  An email client such as Mozilla's Thunderbird or Microsoft's Outlook
  allows a user both to read the emails that were sent to him and to
  send new emails to other people.  To do that, the email client
  connects to other components (one or more): some of these components
  keep the user's mailboxes with all the emails that were sent to him,
  whereas other components know how to forward the emails sent by the
  user to their final destinations.  In either case, it is always the
  email client that makes a request to the other components, but
  whereas in the first case the email client receives all the
  information about the user's emails, in the second case only a
  success or failure error code is returned.  The architectural
  patterns that best describe the interactions between these
  components is

  \begin{options}
  \option Client-server in both cases
  \option Client-server in the first case and Peer-to-peer in the second
  \option Peer-to-peer in both cases
  \option Peer-to-peer in the first case and Client-Server in the second
  \end{options}
\end{ClosedQuestion}


%% 10
\begin{ClosedQuestion}
  To achieve a faster time-to-market, software companies are
  increasingly using a strategy of incremental releases of their
  software, where each new release has a set of new features.  Which
  architectural style is better to analyse whether the system's
  software architecture is adequate for the planned incremental
  releases?
 
  \begin{options}
  \option The Decomposition style
  \option The Deployment style
  \option The Uses style
  \option The Work-assignment style
  \end{options}
\end{ClosedQuestion}


%% 11
\begin{ClosedQuestion}
  Which of the following phrases best describe the relationship
  between modules and components?

  \begin{options}
  \option A module may contain code from different components
  \option A component may execute code from different modules
  \option A module may execute code from different components
  \option A component may contain code from different modules
  \end{options}
\end{ClosedQuestion}


%% 12
\begin{ClosedQuestion}
  Enterprise applications are difficult to develop because 

  \begin{options}
  \option They are developed by large teams of software developers
  \option They have requirements of  high-performance
  \option They have requirements of high-availability
  \option None of the above
  \end{options}
\end{ClosedQuestion}


%% 13
\begin{ClosedQuestion}
  Web servers typically receive requests from different users
  concurrently (that is, either different users make requests
  simultaneously or they make them fast enough that it is not possible
  for the web server to answer one request from one user before
  receiving another request from another user).  To process all the
  requests, web servers may use different implementation strategies.
  Assuming that we want to develop a web server to serve only static
  pages with more or less the same size to a set of clients on the
  same LAN network as the server, which of the following strategies
  would be better?

  \begin{options}
  \option Launch a new process for processing each request
  \option Spawn a new thread for processing each request
  \option Put the requests into a queue and process them sequentially
  \end{options}
\end{ClosedQuestion}


%% 14
\begin{ClosedQuestion}
  The Transaction Script pattern

  \begin{options}
  \option Requires a more skilled team, because it is harder to develop
  \option Allows independent development with little communication
  between the team members
  \option Is better for more complex domains, because it becomes
  easier to maintain 
  \option Requires a more complex Data Access layer
  \end{options}
\end{ClosedQuestion}


%% 15
\begin{ClosedQuestion}
  The Service Layer pattern is often used in conjunction with
 
  \begin{options}
  \option The Transaction Script pattern to help demarcate the
  business transactions
  \option The Domain Model pattern to reduce the interface of the
  Domain Logic layer to a controlled set
  \option The Data Access layer to be able to access the data that it
  needs in each service
  \option The Table Module pattern to hide the details of the table
  structure for the Presentation layer
  \end{options}
\end{ClosedQuestion}


%% 16
\begin{ClosedQuestion}
  The Active Record pattern is best used when we are also using
 
  \begin{options}
  \option The Transaction Script pattern
  \option The Table Module pattern
  \option The Domain Model pattern
  \option The Service Layer pattern
  \end{options}
\end{ClosedQuestion}


%% 17
\begin{ClosedQuestion}
  The Identity Map pattern is used
 
  \begin{options}
  \option To prevent that data becomes incoherent when there are
  multiple accesses within the same business operation to the same
  entity
  \option To increase the performance of the application, because it
  caches previously loaded values in memory, thereby reducing the
  number of round-trips to the database
  \option To avoid loading many data from the database when a given
  entity that has many relationships with other entities is loaded
  \option None of the above
  \end{options}
\end{ClosedQuestion}


%% 18
\begin{ClosedQuestion}
  The Hibernate's class \texttt{Session} corresponds to an
  implementation of

  \begin{options}
  \option The Lazy Load pattern
  \option The Row Data Gateway pattern
  \option The Unit of Work pattern 
  \option The Data Mapper pattern
  \end{options}
\end{ClosedQuestion}


%% 19
\begin{ClosedQuestion}
  To map a Domain Model with both entity-types and value-types to a
  relational database, we must use the Identity Field pattern 
 
  \begin{options}
  \option Only for the entity-types
  \option Only for the value-types
  \option For both the entity-types and the value-types
  \option Neither for the entity-types nor for the value-types
  \end{options}
\end{ClosedQuestion}


%% 20
\begin{ClosedQuestion}
  To increase the liveliness of an enterprise application, the
  recommended approach is to use the Optimistic Offline Locking
  pattern to control the concurrent accesses to the shared data by the
  different requests.  The optimistic nature of this pattern results
  from the assumption conflicts between the concurrent requests are
  rare.  But, when that assumption fails,

  \begin{options}
  \option The data of the application may become corrupted, because no
  conflict is detected
  \option The system may enter into a deadlock that is not detected by
  the pattern
  \option A user's request may starve because it always conflicts with
  other requests
  \option We may have lost updates that override some of the
  previously written data
  \end{options}
\end{ClosedQuestion}

